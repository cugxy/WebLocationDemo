/**
 * @private
 */
(function(){
    window.GeoGlobe = window.GeoGlobe || {};
    window.GeoGlobe.Class = window.GeoGlobe.Class || {};
    window.GeoGlobe.LngLatBounds = window.GeoGlobe.LngLatBounds || {};
    window.GeoGlobe.LngLat = window.GeoGlobe.LngLat || {};
    window.GeoGlobe.Filter = window.GeoGlobe.Filter || {};
    window.GeoGlobe.Format = window.GeoGlobe.Format || {};
    window.GeoGlobe.Protocol = window.GeoGlobe.Protocol || {};
    window.GeoGlobe.Query = window.GeoGlobe.Query || {};
    window.GeoGlobe.Service = window.GeoGlobe.Service || {};
	
    /**
     * Method: getScriptLocation
     * 获取GeoGlobeJSAPI脚本文件名库脚本文件所在路径。
     *
     * Returns:
     * {String} GeoGlobeJSAPI脚本文件所在路径。
     */
    GeoGlobe.getScriptLocation = function (scriptName) {
        var scriptLocation = "";
        var isGV = new RegExp("(^|(.*?\\/))(" + scriptName + ")(\\?|$)");

        var scripts = document.getElementsByTagName('script');
        for (var i=0, len=scripts.length; i<len; i++) {
            var src = scripts[i].getAttribute('src');
            if (src) {
                var match = src.match(isGV);
                if(match) {
                    scriptLocation = match[1];
                    break;
                }
            }
        }
        return scriptLocation;
    };

    /**
     * Method: createNS
     * 创建名字空间,如果指定名字空间中的某一级已经存在不会覆盖已有内容。
     *
     * Parameters:
     * ns - {String} 名称空间。
     *
     */
    GeoGlobe.createNS = function(ns){
        var nsArr = ns.split(".");
        var currObj = window;
        for(var i=0; i<nsArr.length; i++){
            if(!currObj[nsArr[i]]){
                currObj[nsArr[i]] = {};
            }
            currObj = currObj[nsArr[i]];
        }
    };
})();



/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */
/**
 * @class GeoGlobe.Class
 * @classdesc Base class used to construct all other classes. Includes support for multiple inheritance.
 * This constructor is new in OpenLayers 2.5.  At OpenLayers 3.0, the old 
 *     syntax for creating classes and dealing with inheritance 
 *     will be removed.
 * @private
 * @example
 * To create a new OpenLayers-style class, use the following syntax:
 * (code)
 *     var MyClass = OpenLayers.Class(prototype);
 * (end)
 *
 * To create a new OpenLayers-style class with multiple inheritance, use the
 *     following syntax:
 * (code)
 *     var MyClass = OpenLayers.Class(Class1, Class2, prototype);
 * (end)
 * 
 * Note that instanceof reflection will only reveal Class1 as superclass.
 *
 */
GeoGlobe.Class = function() {
    var len = arguments.length;
    var P = arguments[0];
    var F = arguments[len-1];

    var C = typeof F.initialize == "function" ?
        F.initialize :
        function(){ P.prototype.initialize.apply(this, arguments); };

    if (len > 1) {
        var newArgs = [C, P].concat(
                Array.prototype.slice.call(arguments).slice(1, len-1), F);
        //GeoGlobe.inherit.apply(null, newArgs);
    } else {
        C.prototype = F;
    }
    return C;
};
GeoGlobe.Class4OL = function() {
    var len = arguments.length;
    var P = arguments[0];
    var F = arguments[len-1];

    var C = typeof F.initialize == "function" ?
        F.initialize :
        function(){ P.prototype.initialize.apply(this, arguments); };

    if (len > 1) {
        var newArgs = [C, P].concat(
                Array.prototype.slice.call(arguments).slice(1, len-1), F);
        GeoGlobe.inherit.apply(null, newArgs);
    } else {
        C.prototype = F;
    }
    return C;
};

/**
 * @memberof GeoGlobe.Class.prototype
 * @param {Object} C  - the class that inherits
 * @param {Object} P  - the superclass to inherit from
 *
 * In addition to the mandatory C and P parameters, an arbitrary number of
 * objects can be passed, which will extend C.
 */
GeoGlobe.inherit = function(C, P) {
   var F = function() {};
   F.prototype = P.prototype;
   C.prototype = new F;
   var i, l, o;
   for(i=2, l=arguments.length; i<l; i++) {
       o = arguments[i];
       if(typeof o === "function") {
           o = o.prototype;
       }
       GeoGlobe.Util.extend(C.prototype, o);
   }
};

/**
 * extend
 * Copy all properties of a source object to a destination object.  Modifies
 *     the passed in destination object.  Any properties on the source object
 *     that are set to undefined will not be (re)set on the destination object.
 * @memberof GeoGlobe.Class.prototype
 * @param {Object} destination  - The object that will be modified
 * @param {Object} source  - The object with properties to be set on the destination
 *
 * @returns {Object}  - The destination object.
 */
GeoGlobe.Util = GeoGlobe.Util || {};
GeoGlobe.Util.extend = function(destination, source) {
    destination = destination || {};
    if (source) {
        for (var property in source) {
            var value = source[property];
            if (value !== undefined) {
                destination[property] = value;
            }
        }

        /**
         * IE doesn't include the toString property when iterating over an object's
         * properties with the for(property in object) syntax.  Explicitly check if
         * the source has its own toString property.
         */

        /*
         * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
         * prototype object" when calling hawOwnProperty if the source object
         * is an instance of window.Event.
         */

        var sourceIsEvt = typeof window.Event == "function"
                          && source instanceof window.Event;

        if (!sourceIsEvt
           && source.hasOwnProperty && source.hasOwnProperty("toString")) {
            destination.toString = source.toString;
        }
    }
    return destination;
};
/**
 * 原生js实现$.extend深度继承，支持继承多个对象
 * @memberof GeoGlobe.Util
 * @param {Object} target 目标对象
 * @param {Object} obj1 源对象1
 * @param {Object} obj2 源对象2
 * @return {Object} target 目标对象
 */
GeoGlobe.Util.deepExtend = function (target) {
    for (var i = 1; i < arguments.length; i++) {
        for (var property in arguments[i]) {
            if (arguments[i].hasOwnProperty(property)) {
                switch (GeoGlobe.Util.getType(arguments[i][property])) {
                    case 'array':
                        if (target.hasOwnProperty(property) && GeoGlobe.Util.getType(target[property]) === 'array') {
                            GeoGlobe.Util.deepExtend(target[property], arguments[i][property]);
                        } else {
                            target[property] = GeoGlobe.Util.deepExtend([], arguments[i][property]);
                        }
                        break;
                    case 'object':
                        if (target.hasOwnProperty(property) && GeoGlobe.Util.getType(target[property]) === 'object') {
                            GeoGlobe.Util.deepExtend(target[property], arguments[i][property]);
                        } else {
                            target[property] = GeoGlobe.Util.deepExtend({}, arguments[i][property]);
                        }
                        break;
                    default:
                        target[property] = arguments[i][property];
                        break;
                }
            }
        }
    }
    return target;
};

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * 常用的工具方法
 * @namespace  GeoGlobe.Util
 * @private
 */
GeoGlobe.Util = GeoGlobe.Util || {};

/** 
 *
 * This is the old $() from prototype
 * @memberof GeoGlobe.Util
 * @param  {String | DOMElement | Window} e
 *
 * @returns {Array(DOMElement)| DOMElement}
 */
GeoGlobe.Util.getElement = function() {
    var elements = [];

    for (var i=0, len=arguments.length; i<len; i++) {
        var element = arguments[i];
        if (typeof element == 'string') {
            element = document.getElementById(element);
        }
        if (arguments.length == 1) {
            return element;
        }
        elements.push(element);
    }
    return elements;
};

/**
 *
 * A cross-browser implementation of "e instanceof Element".
 * @memberof GeoGlobe.Util
 * @param {Object} o  - The object to test.
 *
 * @returns {Boolean}
 */
GeoGlobe.Util.isElement = function(o) {
    return !!(o && o.nodeType === 1);
};

/**
 *
 * Tests that the provided object is an array.
 * This test handles the cross-IFRAME case not caught
 * by "a instanceof Array" and should be used instead.
 * @memberof GeoGlobe.Util
 * @param {Object} a  - the object test.
 * 
 * @returns {Boolean}  - true if the object is an array.
 */
GeoGlobe.Util.isArray = function(a) {
    return (Object.prototype.toString.call(a) === '[object Array]');
};

/** 
 *
 * Remove an object from an array. Iterates through the array to find the item, then removes it.
 * @memberof GeoGlobe.Util
 * @param {Array} array
 * @param {Object} item
 * 
 * @returns {Array}  - A reference to the array
 */
GeoGlobe.Util.removeItem = function(array, item) {
    for(var i = array.length - 1; i >= 0; i--) {
        if(array[i] == item) {
            array.splice(i,1);
            //break;more than once??
        }
    }
    return array;
};

/** 
 *
 * Seems to exist already in FF, but not in MOZ.
 * @memberof GeoGlobe.Util
 * @param {Array} array
 * @param {Obj} item
 * 
 * @returns {Integer}  - The index at which the first object was found in the array.If not found, returns -1.
 */
GeoGlobe.Util.indexOf = function(array, obj) {
    // use the build-in function if available.
    if (typeof array.indexOf == "function") {
        return array.indexOf(obj);
    } else {
        for (var i = 0, len = array.length; i < len; i++) {
            if (array[i] == obj) {
                return i;
            }
        }
        return -1;   
    }
};


/**
 * Compiled regular expression to match dots (".").  This is used for replacing
 *     dots in identifiers.  Because object identifiers are frequently used for
 *     DOM element identifiers by the library, we avoid using dots to make for
 *     more sensible CSS selectors.
 * @memberof GeoGlobe.Util
 *
 * TODO: Use a module pattern to avoid bloating the API with stuff like this.
 */
GeoGlobe.Util.dotless = /\./g;

/**
 *
 * Modifies many properties of a DOM element all at once.  Passing in 
 * null to an individual parameter will avoid setting the attribute.
 * @memberof GeoGlobe.Util
 * @param {DOMElement} element  - DOM element to modify.
 * @param {String} id  - The element id attribute to set.  Note that dots (".") will be
 *     replaced with underscore ("_") in setting the element id.
 * @param {GeoGlobe.Pixel|Object} px  -  The element left and top position,
 *                                  GeoGlobe.Pixel or an object with
 *                                  a 'x' and 'y' properties.
 * @param {GeoGlobe.Size|Object} sz  -  The element width and height,
 *                                 GeoGlobe.Size or an object with a
 *                                 'w' and 'h' properties.
 * @param {String} position  - The position attribute.  eg: absolute,relative, etc.
 * @param {String} border  -  The style.border attribute.  eg: solid black 2px
 * @param {String} overflow  -  The style.overview attribute.
 * @param {Float} opacity  -  Fractional value (0.0 - 1.0)
 */
/*
GeoGlobe.Util.modifyDOMElement = function(element, id, px, sz, position, 
                                            border, overflow, opacity) {

    if (id) {
        element.id = id.replace(GeoGlobe.Util.dotless, "_");
    }
    if (px) {
        element.style.left = px.x + "px";
        element.style.top = px.y + "px";
    }
    if (sz) {
        element.style.width = sz.w + "px";
        element.style.height = sz.h + "px";
    }
    if (position) {
        element.style.position = position;
    }
    if (border) {
        element.style.border = border;
    }
    if (overflow) {
        element.style.overflow = overflow;
    }
    if (parseFloat(opacity) >= 0.0 && parseFloat(opacity) < 1.0) {
        element.style.filter = 'alpha(opacity=' + (opacity * 100) + ')';
        element.style.opacity = opacity;
    } else if (parseFloat(opacity) == 1.0) {
        element.style.filter = '';
        element.style.opacity = '';
    }
};
*/
/** 
 *
 * Creates a new div and optionally set some standard attributes.
 * Null may be passed to each parameter if you do not wish to
 * set a particular attribute.
 * @memberof GeoGlobe.Util
 * Note - zIndex is NOT set on the resulting div.
 * 

 * @param {String} id  - An identifier for this element.  If no id is
 *               passed an identifier will be created 
 *               automatically.  Note that dots (".") will be replaced with
 *               underscore ("_") when generating ids.
 * @param {GeoGlobe.Pixel|Object} px   - The element left and top position,
 *                                  GeoGlobe.Pixel or an object with a 'x' and 'y' properties.
 * @param {GeoGlobe.Size|Object} sz  - The element width and height,
 *                                 GeoGlobe.Size or an object with a 'w' and 'h' properties.
 * @param {String} imgURL  -  A url pointing to an image to use as a background image.
 * @param {String} position  -  The style.position value. eg: absolute,relative etc.
 * @param {String} border  -  The the style.border value. eg: 2px solid black
 * @param {String} overflow -  The style.overflow value. Eg. hidden
 * @param {Float} opacity  - Fractional value (0.0 - 1.0)
 * 
 * @returns {DOMElement}   - A DOM Div created with the specified attributes.
 */
/*
GeoGlobe.Util.createDiv = function(id, px, sz, imgURL, position, 
                                     border, overflow, opacity) {

    var dom = document.createElement('div');

    if (imgURL) {
        dom.style.backgroundImage = 'url(' + imgURL + ')';
    }

    //set generic properties
    if (!id) {
        id = GeoGlobe.Util.createUniqueID("GeoGlobeDiv");
    }
    if (!position) {
        position = "absolute";
    }
    GeoGlobe.Util.modifyDOMElement(dom, id, px, sz, position, 
                                     border, overflow, opacity);

    return dom;
};
*/
/**
 *
 * Creates an img element with specific attribute values.
 *  @memberof GeoGlobe.Util

 * @param {String} id  - The id field for the img.  If none assigned one will be automatically generated.
 * @param {GeoGlobe.Pixel|Object} px -  The element left and top position,
 *                                  GeoGlobe.Pixel or an object with a 'x' and 'y' properties.
 * @param {GeoGlobe.Size|Object} sz -  The element width and height,
 *                                 GeoGlobe.Size or an object with a 'w' and 'h' properties.
 * @param {String} imgURL -The url to use as the image source.
 * @param {String} position - The style.position value.
 * @param {String} border  -  The border to place around the image.
 * @param {Float} opacity  -  Fractional value (0.0 - 1.0)
 * @param {Boolean} delayDisplay -If true waits until the image has been loaded.
 * 
 * @returns {DOMElement}  - A DOM Image created with the specified attributes.
/*
 * @example
GeoGlobe.Util.createImage = function(id, px, sz, imgURL, position, border,
                                       opacity, delayDisplay) {

    var image = document.createElement("img");

    //set generic properties
    if (!id) {
        id = GeoGlobe.Util.createUniqueID("OpenLayersDiv");
    }
    if (!position) {
        position = "relative";
    }
    GeoGlobe.Util.modifyDOMElement(image, id, px, sz, position, 
                                     border, null, opacity);

    if (delayDisplay) {
        image.style.display = "none";
        function display() {
            image.style.display = "";
            OpenLayers.Event.stopObservingElement(image);
        }
        OpenLayers.Event.observe(image, "load", display);
        OpenLayers.Event.observe(image, "error", display);
    }
    
    //set special properties
    image.style.alt = id;
    image.galleryImg = "no";
    if (imgURL) {
        image.src = imgURL;
    }
        
    return image;
};
*/

/**
 *How many times should we try to reload an image before giving up? Default is 0
 *  @memberof GeoGlobe.Util
 *   @type {Integer}
 */
GeoGlobe.IMAGE_RELOAD_ATTEMPTS = 0;

/**
 * true if the png alpha hack is necessary and possible, false otherwise.
 * @memberof GeoGlobe.Util
 * @type {Boolean}
 */
GeoGlobe.Util.alphaHackNeeded = null;

/**
 *
 * Checks whether it's necessary (and possible) to use the png alpha
 * hack which allows alpha transparency for png images under Internet
 * Explorer.
 *  @memberof GeoGlobe.Util
 * @returns {Boolean}   - true if the png alpha hack is necessary and possible, false otherwise.
 */
GeoGlobe.Util.alphaHack = function() {
    if (GeoGlobe.Util.alphaHackNeeded == null) {
        var arVersion = navigator.appVersion.split("MSIE");
        var version = parseFloat(arVersion[1]);
        var filter = false;
    
        // IEs4Lin dies when trying to access document.body.filters, because 
        // the property is there, but requires a DLL that can't be provided. This
        // means that we need to wrap this in a try/catch so that this can
        // continue.
    
        try { 
            filter = !!(document.body.filters);
        } catch (e) {}    
    
        GeoGlobe.Util.alphaHackNeeded = (filter && 
                                           (version >= 5.5) && (version < 7));
    }
    return GeoGlobe.Util.alphaHackNeeded;
};

/** 
 * @Function  modifyAlphaImageDiv
 * @memberof GeoGlobe.Util
 *
 * @param {DOMElement} div  - Div containing Alpha-adjusted Image
 * @param {String} id
 * @param {GeoGlobe.Pixel|Object} px  - GeoGlobe.Pixel or an object with a 'x' and 'y' properties.
 * @param {GeoGlobe.Size|Object} sz  -  GeoGlobe.Size or an object with a 'w' and 'h' properties.
 * @param {String} imgURL
 * @param {String} position
 * @param {String} border
 * @param {String} sizing   -  'crop', 'scale', or 'image'. Default is "scale"
 * @param {Float} opacity   -  Fractional value (0.0 - 1.0)
 */ 
/*
GeoGlobe.Util.modifyAlphaImageDiv = function(div, id, px, sz, imgURL, 
                                               position, border, sizing, 
                                               opacity) {

    GeoGlobe.Util.modifyDOMElement(div, id, px, sz, position,
                                     null, null, opacity);

    var img = div.childNodes[0];

    if (imgURL) {
        img.src = imgURL;
    }
    GeoGlobe.Util.modifyDOMElement(img, div.id + "_innerImage", null, sz, 
                                     "relative", border);
    
    if (GeoGlobe.Util.alphaHack()) {
        if(div.style.display != "none") {
            div.style.display = "inline-block";
        }
        if (sizing == null) {
            sizing = "scale";
        }
        
        div.style.filter = "progid:DXImageTransform.Microsoft" +
                           ".AlphaImageLoader(src='" + img.src + "', " +
                           "sizingMethod='" + sizing + "')";
        if (parseFloat(div.style.opacity) >= 0.0 && 
            parseFloat(div.style.opacity) < 1.0) {
            div.style.filter += " alpha(opacity=" + div.style.opacity * 100 + ")";
        }

        img.style.filter = "alpha(opacity=0)";
    }
};
*/
/**
 * @memberof GeoGlobe.Util
 *
 * @param {String} id
 * @param {GeoGlobe.Pixel|Object} px  -  GeoGlobe.Pixel or an object with a 'x' and 'y' properties.
 * @param {GeoGlobe.Size|Object} sz -GeoGlobe.Size or an object with a 'w' and 'h' properties.
 * @param {String} imgURL
 * @param {String} position
 * @param {String} border
 * @param {String} sizing   - 'crop', 'scale', or 'image'. Default is "scale"
 * @param {Float} opacity   - Fractional value (0.0 - 1.0)
 * @param {Boolean} delayDisplay -  If true waits until the image has been loaded.
 * 
 * @returns {DOMElement}  - A DOM Div created with a DOM Image inside it. If the hack is
 *              needed for transparency in IE, it is added.
 */
/*
GeoGlobe.Util.createAlphaImageDiv = function(id, px, sz, imgURL, 
                                               position, border, sizing, 
                                               opacity, delayDisplay) {
    
    var div = GeoGlobe.Util.createDiv();
    var img = GeoGlobe.Util.createImage(null, null, null, null, null, null, 
                                          null, delayDisplay);
    img.className = "olAlphaImg";
    div.appendChild(img);

    GeoGlobe.Util.modifyAlphaImageDiv(div, id, px, sz, imgURL, position, 
                                        border, sizing, opacity);
    
    return div;
};
*/

/** 
 *
 * Creates a new hashtable and copies over all the keys from the 
 *     passed-in object, but storing them under an uppercased
 *     version of the key at which they were stored.
 * @memberof GeoGlobe.Util
 * @param {Object} object
 * 
 * @returns {Object}  - A new Object with all the same keys but uppercased
 */
GeoGlobe.Util.upperCaseObject = function (object) {
    var uObject = {};
    for (var key in object) {
        uObject[key.toUpperCase()] = object[key];
    }
    return uObject;
};

/** 
 *
 * Takes an object and copies any properties that don't exist from
 *     another properties, by analogy with GeoGlobe.Util.extend() from
 *     Prototype.js.
 * @memberof GeoGlobe.Util
 * @param {Object} to  - The destination object.
 * @param {Object} from  -  The source object.  Any properties of this object that
 *     are undefined in the to object will be set on the to object.
 *
 * @returns {Object}  - A reference to the to object.  Note that the to argument is modified
 *     in place and returned by this function.
 */
GeoGlobe.Util.applyDefaults = function (to, from) {
    to = to || {};
    /*
     * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
     * prototype object" when calling hawOwnProperty if the source object is an
     * instance of window.Event.
     */
    var fromIsEvt = typeof window.Event == "function"
                    && from instanceof window.Event;

    for (var key in from) {
        if (to[key] === undefined ||
            (!fromIsEvt && from.hasOwnProperty
             && from.hasOwnProperty(key) && !to.hasOwnProperty(key))) {
            to[key] = from[key];
        }
    }
    /**
     * IE doesn't include the toString property when iterating over an object's
     * properties with the for(property in object) syntax.  Explicitly check if
     * the source has its own toString property.
     */
    if(!fromIsEvt && from && from.hasOwnProperty
       && from.hasOwnProperty('toString') && !to.hasOwnProperty('toString')) {
        to.toString = from.toString;
    }
    
    return to;
};

/**
 * @memberof GeoGlobe.Util
 * @param {Object} params
 * 
 * @returns {String}   - A concatenation of the properties of an object in http parameter notation.
 *          (ex. i"key1=value1&key2=value2&key3=value3"/i)
 *          If a parameter is actually a list, that parameter will then
 *          be set to a comma-seperated list of values (foo,bar) instead
 *          of being URL escaped (foo%3Abar). 
 */
GeoGlobe.Util.getParameterString = function(params) {
    var paramsArray = [];
    
    for (var key in params) {
      var value = params[key];
      if ((value != null) && (typeof value != 'function')) {
        var encodedValue;
        if (typeof value == 'object' && value.constructor == Array) {
          /* value is an array; encode items and separate with "," */
          var encodedItemArray = [];
          var item;
          for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
            item = value[itemIndex];
            encodedItemArray.push(encodeURIComponent(
                (item === null || item === undefined) ? "" : item)
            );
          }
          encodedValue = encodedItemArray.join(",");
        }
        else {
          /* value is a string; simply encode */
          encodedValue = encodeURIComponent(value);
        }
        paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
      }
    }
    
    return paramsArray.join("&");
};

/**
 *
 * Appends a parameter string to a url. This function includes the logic for
 * using the appropriate character (none, & or ?) to append to the url before
 * appending the param string.
 *  @memberof GeoGlobe.Util
 * @param {String} url - The url to append to
 * @param {String} paramStr  -  The param string to append
 * 
 * @returns {String}  - The new url
 */
GeoGlobe.Util.urlAppend = function(url, paramStr) {
    var newUrl = url;
    if(paramStr) {
        var parts = (url + " ").split(/[?&]/);
        newUrl += (parts.pop() === " " ?
            paramStr :
            parts.length ? "&" + paramStr : "?" + paramStr);
    }
    return newUrl;
};

/**
 * @memberof GeoGlobe.Util
 * @returns {String}  - The fully formatted image location string
 */
GeoGlobe.Util.getImagesLocation = function() {
    return GeoGlobe.ImgPath || (GeoGlobe._getScriptLocation() + "img/");
};

/**
 * @memberof GeoGlobe.Util
 * @returns {String}   - The fully formatted location string for a specified image
 */
GeoGlobe.Util.getImageLocation = function(image) {
    return GeoGlobe.Util.getImagesLocation() + image;
};


/** 
 *
 * Execute functions until one of them doesn't throw an error. 
 *     Capitalized because "try" is a reserved word in JavaScript.
 *     Taken directly from GeoGlobe.Util.Try()
 * @memberof GeoGlobe.Util
 * @param {Function}[*]  - Any number of parameters may be passed to Try()
 *    It will attempt to execute each of them until one of them 
 *    successfully executes. 
 *    If none executes successfully, returns null.
 * 
 * @returns {*}  - The value returned by the first successfully executed function.
 */
GeoGlobe.Util.Try = function() {
    var returnValue = null;

    for (var i=0, len=arguments.length; i<len; i++) {
      var lambda = arguments[i];
      try {
        returnValue = lambda();
        break;
      } catch (e) {}
    }

    return returnValue;
};

/**
 * @memberof GeoGlobe.Util
 * @param {XMLNode} node
 * 
 * @returns {String}  - The text value of the given node, without breaking in firefox or IE
 */
GeoGlobe.Util.getXmlNodeValue = function(node) {
    var val = null;
    GeoGlobe.Util.Try( 
        function() {
            val = node.text;
            if (!val) {
                val = node.textContent;
            }
            if (!val) {
                val = node.firstChild.nodeValue;
            }
        }, 
        function() {
            val = node.textContent;
        }); 
    return val;
};

/**
 * @memberof GeoGlobe.Util
 * @param {Event} evt
 * @param {HTMLDivElement} div
 * 
 * @returns {Boolean}
 */
GeoGlobe.Util.mouseLeft = function (evt, div) {
    // start with the element to which the mouse has moved
    var target = (evt.relatedTarget) ? evt.relatedTarget : evt.toElement;
    // walk up the DOM tree.
    while (target != div && target != null) {
        target = target.parentNode;
    }
    // if the target we stop at isn't the div, then we've left the div.
    return (target != div);
};

/**
 *The number of significant digits to retain to avoid floating point precision errors.
 * @memberof GeoGlobe.Util
 *
 * We use 14 as a "safe" default because, although IEEE 754 double floats
 * (standard on most modern operating systems) support up to about 16
 * significant digits, 14 significant digits are sufficient to represent
 * sub-millimeter accuracy in any coordinate system that anyone is likely to
 * use with OpenLayers.
 *
 * If DEFAULT_PRECISION is set to 0, the original non-truncating behavior
 * of OpenLayers <2.8 is preserved. Be aware that this will cause problems
 * with certain projections, e.g. spherical Mercator.
 *
 */
GeoGlobe.Util.DEFAULT_PRECISION = 14;

/**
 *
 * Convenience method to cast an object to a Number, rounded to the
 * desired floating point precision.
 * n@Function toFloat
 * @memberof GeoGlobe.Util
 * @param {Number} number    - The number to cast and round.
 * @param {Number}  precision  - An integer suitable for use with
 *      Number.toPrecision(). Defaults to GeoGlobe.Util.DEFAULT_PRECISION.
 *      If set to 0, no rounding is performed.
 *
 * @returns {Number}  - The cast, rounded number.
 */
GeoGlobe.Util.toFloat = function (number, precision) {
    if (precision == null) {
        precision = GeoGlobe.Util.DEFAULT_PRECISION;
    }
    if (typeof number !== "number") {
        number = parseFloat(number);
    }
    return precision === 0 ? number :
                             parseFloat(number.toPrecision(precision));
};

/**
 *  @memberof GeoGlobe.Util
 * @param {Float} x
 *
 * @returns {Float}
 */
GeoGlobe.Util.rad = function(x) {return x*Math.PI/180;};

/**
 * @memberof GeoGlobe.Util
 * @param {Float} x
 *
 * @returns  {Float}
 */
GeoGlobe.Util.deg = function(x) {return x*180/Math.PI;};

/**
 * @Property {Object} VincentyConstants  - Constants for Vincenty functions.
 *  @memberof GeoGlobe.Util
 */
GeoGlobe.Util.VincentyConstants = {
    a: 6378137,
    b: 6356752.3142,
    f: 1/298.257223563
};

/**
 *
 * Given two objects representing points with geographic coordinates, this
 *     calculates the distance between those points on the surface of an
 *     ellipsoid.
 * @memberof GeoGlobe.Util
 * @param {GeoGlobe.LngLat} p1  -  (or any object with both .lat, .lng properties)
 * @param {GeoGlobe.LngLat} p2  -  (or any object with both .lat, .lng properties)
 *
 * @returns {Float}  - The distance (in km) between the two input points as measured on an
 *     ellipsoid.  Note that the input point objects must be in geographic
 *     coordinates (decimal degrees) and the return distance is in kilometers.
 */
GeoGlobe.Util.distVincenty = function(p1, p2) {
    var ct = GeoGlobe.Util.VincentyConstants;
    var a = ct.a, b = ct.b, f = ct.f;

    var L = GeoGlobe.Util.rad(p2.lng - p1.lng);
    var U1 = Math.atan((1-f) * Math.tan(GeoGlobe.Util.rad(p1.lat)));
    var U2 = Math.atan((1-f) * Math.tan(GeoGlobe.Util.rad(p2.lat)));
    var sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
    var sinU2 = Math.sin(U2), cosU2 = Math.cos(U2);
    var lambda = L, lambdaP = 2*Math.PI;
    var iterLimit = 20;
    while (Math.abs(lambda-lambdaP) > 1e-12 && --iterLimit>0) {
        var sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda);
        var sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +
        (cosU1*sinU2-sinU1*cosU2*cosLambda) * (cosU1*sinU2-sinU1*cosU2*cosLambda));
        if (sinSigma==0) {
            return 0;  // co-incident points
        }
        var cosSigma = sinU1*sinU2 + cosU1*cosU2*cosLambda;
        var sigma = Math.atan2(sinSigma, cosSigma);
        var alpha = Math.asin(cosU1 * cosU2 * sinLambda / sinSigma);
        var cosSqAlpha = Math.cos(alpha) * Math.cos(alpha);
        var cos2SigmaM = cosSigma - 2*sinU1*sinU2/cosSqAlpha;
        var C = f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha));
        lambdaP = lambda;
        lambda = L + (1-C) * f * Math.sin(alpha) *
        (sigma + C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)));
    }
    if (iterLimit==0) {
        return NaN;  // formula failed to converge
    }
    var uSq = cosSqAlpha * (a*a - b*b) / (b*b);
    var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
    var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));
    var deltaSigma = B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-
        B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));
    var s = b*A*(sigma-deltaSigma);
    var d = s.toFixed(3)/1000; // round to 1mm precision
    return d;
};

/**
 *
 * Calculate destination point given start point lat/long (numeric degrees),
 * bearing (numeric degrees) & distance (in m).
 * Adapted from Chris Veness work, see
 * http://www.movable-type.co.uk/scripts/latlong-vincenty-direct.html
 * @memberof GeoGlobe.Util

 * @param {GeoGlobe.LngLat}  lonlat   - (or any object with both .lat, .lng
 *    properties) The start point.
 * @param {Float}  brng   - The bearing (degrees).
 * @param {Float}  dist   - The ground distance (meters).
 *
 * @returns {GeoGlobe.LngLat}  - The destination point.
 */
GeoGlobe.Util.destinationVincenty = function(lonlat, brng, dist) {
    var u = GeoGlobe.Util;
    var ct = u.VincentyConstants;
    var a = ct.a, b = ct.b, f = ct.f;

    var lon1 = lonlat.lng;
    var lat1 = lonlat.lat;

    var s = dist;
    var alpha1 = u.rad(brng);
    var sinAlpha1 = Math.sin(alpha1);
    var cosAlpha1 = Math.cos(alpha1);

    var tanU1 = (1-f) * Math.tan(u.rad(lat1));
    var cosU1 = 1 / Math.sqrt((1 + tanU1*tanU1)), sinU1 = tanU1*cosU1;
    var sigma1 = Math.atan2(tanU1, cosAlpha1);
    var sinAlpha = cosU1 * sinAlpha1;
    var cosSqAlpha = 1 - sinAlpha*sinAlpha;
    var uSq = cosSqAlpha * (a*a - b*b) / (b*b);
    var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
    var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));

    var sigma = s / (b*A), sigmaP = 2*Math.PI;
    while (Math.abs(sigma-sigmaP) > 1e-12) {
        var cos2SigmaM = Math.cos(2*sigma1 + sigma);
        var sinSigma = Math.sin(sigma);
        var cosSigma = Math.cos(sigma);
        var deltaSigma = B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-
            B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));
        sigmaP = sigma;
        sigma = s / (b*A) + deltaSigma;
    }

    var tmp = sinU1*sinSigma - cosU1*cosSigma*cosAlpha1;
    var lat2 = Math.atan2(sinU1*cosSigma + cosU1*sinSigma*cosAlpha1,
        (1-f)*Math.sqrt(sinAlpha*sinAlpha + tmp*tmp));
    var lambda = Math.atan2(sinSigma*sinAlpha1, cosU1*cosSigma - sinU1*sinSigma*cosAlpha1);
    var C = f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha));
    var L = lambda - (1-C) * f * sinAlpha *
        (sigma + C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)));

    var revAz = Math.atan2(sinAlpha, -tmp);  // final bearing

    return new GeoGlobe.LngLat(lon1+u.deg(L), u.deg(lat2));
};

/**
 *
 * Parse the parameters from a URL or from the current page itself into a 
 *     JavaScript Object. Note that parameter values with commas are separated
 *     out into an Array.
 * @memberof GeoGlobe.Util
 * @param {String} url - Optional url used to extract the query string.
 *                If url is null or is not supplied, query string is taken from the page location.
 * @param {Object} options  - Additional options. Optional.
 *
 * Valid options:
 * @param  {Boolean} splitArgs - Split comma delimited params into arrays? Default is true.
 * 
 * @returns Object}  - An object of key/value pairs from the query string.
 */
GeoGlobe.Util.getParameters = function(url, options) {
    options = options || {};
    // if no url specified, take it from the location bar
    url = (url === null || url === undefined) ? window.location.href : url;

    //parse out parameters portion of url string
    var paramsString = "";
    if (GeoGlobe.String.contains(url, '?')) {
        var start = url.indexOf('?') + 1;
        var end = GeoGlobe.String.contains(url, "#") ?
                    url.indexOf('#') : url.length;
        paramsString = url.substring(start, end);
    }

    var parameters = {};
    var pairs = paramsString.split(/[&;]/);
    for(var i=0, len=pairs.length; i<len; ++i) {
        var keyValue = pairs[i].split('=');
        if (keyValue[0]) {

            var key = keyValue[0];
            try {
                key = decodeURIComponent(key);
            } catch (err) {
                key = unescape(key);
            }
            
            // being liberal by replacing "+" with " "
            var value = (keyValue[1] || '').replace(/\+/g, " ");

            try {
                value = decodeURIComponent(value);
            } catch (err) {
                value = unescape(value);
            }
            
            // follow OGC convention of comma delimited values
            if (options.splitArgs !== false) {
                value = value.split(",");
            }

            //if there's only one value, do not return as array                    
            if (value.length == 1) {
                value = value[0];
            }                
            
            parameters[key] = value;
         }
     }
    return parameters;
};

/**
 * The ever-incrementing count variable. Used for generating unique ids.
 * @memberof GeoGlobe.Util
 * @type {Integer}
 */
GeoGlobe.Util.lastSeqID = 0;

/**
 *
 * Create a unique identifier for this session.  Each time this function
 *     is called, a counter is incremented.  The return will be the optional
 *     prefix (defaults to "id_") appended with the counter value.
 *  @memberof GeoGlobe.Util
 * @param {String} prefix  - Optional string to prefix unique id. Default is "id_".
 *     Note that dots (".") in the prefix will be replaced with underscore ("_").
 * 
 * @returns {String}  - A unique id string, built on the passed in prefix.
 */
GeoGlobe.Util.createUniqueID = function(prefix) {
    if (prefix == null) {
        prefix = "id_";
    } else {
        prefix = prefix.replace(GeoGlobe.Util.dotless, "_");
    }
    GeoGlobe.Util.lastSeqID += 1; 
    return prefix + GeoGlobe.Util.lastSeqID;        
};

/**
 * @Constant
 *  Constant inches per unit -- borrowed from MapServer mapscale.c
 * derivation of nautical miles from http://en.wikipedia.org/wiki/Nautical_mile
 * Includes the full set of units supported by CS-MAP (http://trac.osgeo.org/csmap/)
 * and PROJ.4 (http://trac.osgeo.org/proj/)
 * The hardcoded table is maintain in a CS-MAP source code module named CSdataU.c
 * The hardcoded table of PROJ.4 units are in pj_units.c.
 *  @memberof GeoGlobe.Util
 * @type {Object}
 */
GeoGlobe.INCHES_PER_UNIT = { 
    'inches': 1.0,
    'ft': 12.0,
    'mi': 63360.0,
    'm': 1/0.0254,//39.37,
    'km': 39370,
    'dd': 4374754,
    'yd': 36
};
GeoGlobe.INCHES_PER_UNIT["in"]= GeoGlobe.INCHES_PER_UNIT.inches;
GeoGlobe.INCHES_PER_UNIT["degrees"] = GeoGlobe.INCHES_PER_UNIT.dd;
GeoGlobe.INCHES_PER_UNIT["nmi"] = 1852 * GeoGlobe.INCHES_PER_UNIT.m;

// Units from CS-Map
GeoGlobe.METERS_PER_INCH = 0.02540005080010160020;
GeoGlobe.Util.extend(GeoGlobe.INCHES_PER_UNIT, {
    "Inch": GeoGlobe.INCHES_PER_UNIT.inches,
    "Meter": 1.0 / GeoGlobe.METERS_PER_INCH,   //EPSG:9001
    "Foot": 0.30480060960121920243 / GeoGlobe.METERS_PER_INCH,   //EPSG:9003
    "IFoot": 0.30480000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9002
    "ClarkeFoot": 0.3047972651151 / GeoGlobe.METERS_PER_INCH,   //EPSG:9005
    "SearsFoot": 0.30479947153867624624 / GeoGlobe.METERS_PER_INCH,   //EPSG:9041
    "GoldCoastFoot": 0.30479971018150881758 / GeoGlobe.METERS_PER_INCH,   //EPSG:9094
    "IInch": 0.02540000000000000000 / GeoGlobe.METERS_PER_INCH,
    "MicroInch": 0.00002540000000000000 / GeoGlobe.METERS_PER_INCH,
    "Mil": 0.00000002540000000000 / GeoGlobe.METERS_PER_INCH,
    "Centimeter": 0.01000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Kilometer": 1000.00000000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9036
    "Yard": 0.91440182880365760731 / GeoGlobe.METERS_PER_INCH,
    "SearsYard": 0.914398414616029 / GeoGlobe.METERS_PER_INCH,   //EPSG:9040
    "IndianYard": 0.91439853074444079983 / GeoGlobe.METERS_PER_INCH,   //EPSG:9084
    "IndianYd37": 0.91439523 / GeoGlobe.METERS_PER_INCH,   //EPSG:9085
    "IndianYd62": 0.9143988 / GeoGlobe.METERS_PER_INCH,   //EPSG:9086
    "IndianYd75": 0.9143985 / GeoGlobe.METERS_PER_INCH,   //EPSG:9087
    "IndianFoot": 0.30479951 / GeoGlobe.METERS_PER_INCH,   //EPSG:9080
    "IndianFt37": 0.30479841 / GeoGlobe.METERS_PER_INCH,   //EPSG:9081
    "IndianFt62": 0.3047996 / GeoGlobe.METERS_PER_INCH,   //EPSG:9082
    "IndianFt75": 0.3047995 / GeoGlobe.METERS_PER_INCH,   //EPSG:9083
    "Mile": 1609.34721869443738887477 / GeoGlobe.METERS_PER_INCH,
    "IYard": 0.91440000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9096
    "IMile": 1609.34400000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9093
    "NautM": 1852.00000000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9030
    "Lat-66": 110943.316488932731 / GeoGlobe.METERS_PER_INCH,
    "Lat-83": 110946.25736872234125 / GeoGlobe.METERS_PER_INCH,
    "Decimeter": 0.10000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Millimeter": 0.00100000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Dekameter": 10.00000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Decameter": 10.00000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Hectometer": 100.00000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "GermanMeter": 1.0000135965 / GeoGlobe.METERS_PER_INCH,   //EPSG:9031
    "CaGrid": 0.999738 / GeoGlobe.METERS_PER_INCH,
    "ClarkeChain": 20.1166194976 / GeoGlobe.METERS_PER_INCH,   //EPSG:9038
    "GunterChain": 20.11684023368047 / GeoGlobe.METERS_PER_INCH,   //EPSG:9033
    "BenoitChain": 20.116782494375872 / GeoGlobe.METERS_PER_INCH,   //EPSG:9062
    "SearsChain": 20.11676512155 / GeoGlobe.METERS_PER_INCH,   //EPSG:9042
    "ClarkeLink": 0.201166194976 / GeoGlobe.METERS_PER_INCH,   //EPSG:9039
    "GunterLink": 0.2011684023368047 / GeoGlobe.METERS_PER_INCH,   //EPSG:9034
    "BenoitLink": 0.20116782494375872 / GeoGlobe.METERS_PER_INCH,   //EPSG:9063
    "SearsLink": 0.2011676512155 / GeoGlobe.METERS_PER_INCH,   //EPSG:9043
    "Rod": 5.02921005842012 / GeoGlobe.METERS_PER_INCH,
    "IntnlChain": 20.1168 / GeoGlobe.METERS_PER_INCH,   //EPSG:9097
    "IntnlLink": 0.201168 / GeoGlobe.METERS_PER_INCH,   //EPSG:9098
    "Perch": 5.02921005842012 / GeoGlobe.METERS_PER_INCH,
    "Pole": 5.02921005842012 / GeoGlobe.METERS_PER_INCH,
    "Furlong": 201.1684023368046 / GeoGlobe.METERS_PER_INCH,
    "Rood": 3.778266898 / GeoGlobe.METERS_PER_INCH,
    "CapeFoot": 0.3047972615 / GeoGlobe.METERS_PER_INCH,
    "Brealey": 375.00000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "ModAmFt": 0.304812252984505969011938 / GeoGlobe.METERS_PER_INCH,
    "Fathom": 1.8288 / GeoGlobe.METERS_PER_INCH,
    "NautM-UK": 1853.184 / GeoGlobe.METERS_PER_INCH,
    "50kilometers": 50000.0 / GeoGlobe.METERS_PER_INCH,
    "150kilometers": 150000.0 / GeoGlobe.METERS_PER_INCH
});

//unit abbreviations supported by PROJ.4
GeoGlobe.Util.extend(GeoGlobe.INCHES_PER_UNIT, {
    "mm": GeoGlobe.INCHES_PER_UNIT["Meter"] / 1000.0,
    "cm": GeoGlobe.INCHES_PER_UNIT["Meter"] / 100.0,
    "dm": GeoGlobe.INCHES_PER_UNIT["Meter"] * 100.0,
    "km": GeoGlobe.INCHES_PER_UNIT["Meter"] * 1000.0,
    "kmi": GeoGlobe.INCHES_PER_UNIT["nmi"],    //International Nautical Mile
    "fath": GeoGlobe.INCHES_PER_UNIT["Fathom"], //International Fathom
    "ch": GeoGlobe.INCHES_PER_UNIT["IntnlChain"],  //International Chain
    "link": GeoGlobe.INCHES_PER_UNIT["IntnlLink"], //International Link
    "us-in": GeoGlobe.INCHES_PER_UNIT["inches"], //U.S. Surveyor's Inch
    "us-ft": GeoGlobe.INCHES_PER_UNIT["Foot"], //U.S. Surveyor's Foot
    "us-yd": GeoGlobe.INCHES_PER_UNIT["Yard"], //U.S. Surveyor's Yard
    "us-ch": GeoGlobe.INCHES_PER_UNIT["GunterChain"], //U.S. Surveyor's Chain
    "us-mi": GeoGlobe.INCHES_PER_UNIT["Mile"],   //U.S. Surveyor's Statute Mile
    "ind-yd": GeoGlobe.INCHES_PER_UNIT["IndianYd37"],  //Indian Yard
    "ind-ft": GeoGlobe.INCHES_PER_UNIT["IndianFt37"],  //Indian Foot
    "ind-ch": 20.11669506 / GeoGlobe.METERS_PER_INCH  //Indian Chain
});


GeoGlobe.DOTS_PER_INCH = 96;

/**
 *  @memberof GeoGlobe.Util
 * 
 * @param {float} scale
 * 
 * @returns {Float}  - A normalized scale value, in 1 / X format.
 *         This means that if a value less than one ( already 1/x) is passed
 *         in, it just returns scale directly. Otherwise, it returns 1 / scale
 */
GeoGlobe.Util.normalizeScale = function (scale) {
    var normScale = (scale > 1.0) ? (1.0 / scale) 
                                  : scale;
    return normScale;
};

/**
 * @memberof GeoGlobe.Util
 *
 * @param {Float} scale
 * @param {String} units  -  Index into GeoGlobe.INCHES_PER_UNIT hashtable. Default is degrees
 * 
 * @returns {Float}  - The corresponding resolution given passed-in scale and unit
 *     parameters.  If the given scale is falsey, the returned resolution will be undefined.
 */
GeoGlobe.Util.getResolutionFromScale = function (scale, units) {
    var resolution;
    if (scale) {
        if (units == null) {
            units = "degrees";
        }
        var normScale = GeoGlobe.Util.normalizeScale(scale);
        resolution = 1 / (normScale * GeoGlobe.INCHES_PER_UNIT[units]
                                        * GeoGlobe.DOTS_PER_INCH);        
    }
    return resolution;
};

/**
 * @memberof GeoGlobe.Util
 *
 * @param {Float} resolution
 * @param {String}  units  - Index into GeoGlobe.INCHES_PER_UNIT hashtable. Default is degrees
 * 
 * @returns {Float}  - The corresponding scale given passed-in resolution and unit parameters.
 */
GeoGlobe.Util.getScaleFromResolution = function (resolution, units) {

    if (units == null) {
        units = "degrees";
    }

    var scale = resolution * GeoGlobe.INCHES_PER_UNIT[units] *
                    GeoGlobe.DOTS_PER_INCH;
    return scale;
};

/**
 *
 * Calculates the position of an element on the page (see
 * http://code.google.com/p/doctype/wiki/ArticlePageOffset)
 * @memberof GeoGlobe.Util
 * GeoGlobe.Util.pagePosition is based on Yahoo's getXY method, which is
 * Copyright (c) 2006, Yahoo! Inc.
 * All rights reserved.
 * 
 * Redistribution and use of this software in source and binary forms, with or
 * without modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * Neither the name of Yahoo! Inc. nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission of Yahoo! Inc.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * @param {DOMElement} forElement
 * 
 * @returns {Array}  - two item array, Left value then Top value.
 */
GeoGlobe.Util.pagePosition =  function(forElement) {
    // NOTE: If element is hidden (display none or disconnected or any the
    // ancestors are hidden) we get (0,0) by default but we still do the
    // accumulation of scroll position.

    var pos = [0, 0];
    var viewportElement = GeoGlobe.Util.getViewportElement();
    if (!forElement || forElement == window || forElement == viewportElement) {
        // viewport is always at 0,0 as that defined the coordinate system for
        // this function - this avoids special case checks in the code below
        return pos;
    }

    // Gecko browsers normally use getBoxObjectFor to calculate the position.
    // When invoked for an element with an implicit absolute position though it
    // can be off by one. Therefore the recursive implementation is used in
    // those (relatively rare) cases.
    var BUGGY_GECKO_BOX_OBJECT =
        GeoGlobe.IS_GECKO && document.getBoxObjectFor &&
        GeoGlobe.Element.getStyle(forElement, 'position') == 'absolute' &&
        (forElement.style.top == '' || forElement.style.left == '');

    var parent = null;
    var box;

    if (forElement.getBoundingClientRect) { // IE
        box = forElement.getBoundingClientRect();
        var scrollTop = window.pageYOffset || viewportElement.scrollTop;
        var scrollLeft = window.pageXOffset || viewportElement.scrollLeft;
        
        pos[0] = box.left + scrollLeft;
        pos[1] = box.top + scrollTop;

    } else if (document.getBoxObjectFor && !BUGGY_GECKO_BOX_OBJECT) { // gecko
        // Gecko ignores the scroll values for ancestors, up to 1.9.  See:
        // https://bugzilla.mozilla.org/show_bug.cgi?id=328881 and
        // https://bugzilla.mozilla.org/show_bug.cgi?id=330619

        box = document.getBoxObjectFor(forElement);
        var vpBox = document.getBoxObjectFor(viewportElement);
        pos[0] = box.screenX - vpBox.screenX;
        pos[1] = box.screenY - vpBox.screenY;

    } else { // safari/opera
        pos[0] = forElement.offsetLeft;
        pos[1] = forElement.offsetTop;
        parent = forElement.offsetParent;
        if (parent != forElement) {
            while (parent) {
                pos[0] += parent.offsetLeft;
                pos[1] += parent.offsetTop;
                parent = parent.offsetParent;
            }
        }

        var browser = GeoGlobe.BROWSER_NAME;

        // opera & (safari absolute) incorrectly account for body offsetTop
        if (browser == "opera" || (browser == "safari" &&
              GeoGlobe.Element.getStyle(forElement, 'position') == 'absolute')) {
            pos[1] -= document.body.offsetTop;
        }

        // accumulate the scroll positions for everything but the body element
        parent = forElement.offsetParent;
        while (parent && parent != document.body) {
            pos[0] -= parent.scrollLeft;
            // see https://bugs.opera.com/show_bug.cgi?id=249965
            if (browser != "opera" || parent.tagName != 'TR') {
                pos[1] -= parent.scrollTop;
            }
            parent = parent.offsetParent;
        }
    }
    
    return pos;
};

/**
 *
 * Returns die viewport element of the document. The viewport element is
 * usually document.documentElement, except in IE,where it is either
 * document.body or document.documentElement, depending on the document's
 * compatibility mode (see
 * http://code.google.com/p/doctype/wiki/ArticleClientViewportElement)
 * @memberof GeoGlobe.Util
 * @returns {DOMElement}
 */
GeoGlobe.Util.getViewportElement = function() {
    var viewportElement = arguments.callee.viewportElement;
    if (viewportElement == undefined) {
        viewportElement = (GeoGlobe.BROWSER_NAME == "msie" &&
            document.compatMode != 'CSS1Compat') ? document.body :
            document.documentElement;
        arguments.callee.viewportElement = viewportElement;
    }
    return viewportElement;
};

/** 
 *
 * Test two URLs for equivalence.
 *  @memberof GeoGlobe.Util
 * Setting 'ignoreCase' allows for case-independent comparison.
 * 
 * Comparison is based on: 
 *  - Protocol
 *  - Host (evaluated without the port)
 *  - Port (set 'ignorePort80' to ignore "80" values)
 *  - Hash ( set 'ignoreHash' to disable)
 *  - Pathname (for relative <-> absolute comparison) 
 *  - Arguments (so they can be out of order)
 *  

 * @param {String} url1
 * @param {String} url2
 * @param {Object} options  -  Allows for customization of comparison:
 *                    'ignoreCase' - Default is True
 *                    'ignorePort80' - Default is True
 *                    'ignoreHash' - Default is True
 *
 * @returns {Boolean}  - Whether or not the two URLs are equivalent
 */
GeoGlobe.Util.isEquivalentUrl = function(url1, url2, options) {
    options = options || {};

    GeoGlobe.Util.applyDefaults(options, {
        ignoreCase: true,
        ignorePort80: true,
        ignoreHash: true,
        splitArgs: false
    });

    var urlObj1 = GeoGlobe.Util.createUrlObject(url1, options);
    var urlObj2 = GeoGlobe.Util.createUrlObject(url2, options);

    //compare all keys except for "args" (treated below)
    for(var key in urlObj1) {
        if(key !== "args") {
            if(urlObj1[key] != urlObj2[key]) {
                return false;
            }
        }
    }

    // compare search args - irrespective of order
    for(var key in urlObj1.args) {
        if(urlObj1.args[key] != urlObj2.args[key]) {
            return false;
        }
        delete urlObj2.args[key];
    }
    // urlObj2 shouldn't have any args left
    for(var key in urlObj2.args) {
        return false;
    }
    
    return true;
};

/**
 * @memberof GeoGlobe.Util
 *
 * @param {String} url1
 * @param {String} url2
 *
 * Valid options:
 * @param {Boolean}  ignoreCase  - lowercase url,
 * @param {Boolean} ignorePort80  -  don't include explicit port if port is 80,
 * @param {Boolean}  ignoreHash  - Don't include part of url after the hash (#).
 * @param {Boolean} splitArgs  - Split comma delimited params into arrays? Default is true.
 * 
 * @returns {Object}  - An object with separate url, a, port, host, and args parsed out
 *          and ready for comparison
 */
GeoGlobe.Util.createUrlObject = function(url, options) {
    options = options || {};

    // deal with relative urls first
    if(!(/^\w+:\/\//).test(url)) {
        var loc = window.location;
        var port = loc.port ? ":" + loc.port : "";
        var fullUrl = loc.protocol + "//" + loc.host.split(":").shift() + port;
        if(url.indexOf("/") === 0) {
            // full pathname
            url = fullUrl + url;
        } else {
            // relative to current path
            var parts = loc.pathname.split("/");
            parts.pop();
            url = fullUrl + parts.join("/") + "/" + url;
        }
    }
  
    if (options.ignoreCase) {
        url = url.toLowerCase(); 
    }

    var a = document.createElement('a');
    a.href = url;
    
    var urlObject = {};
    
    //host (without port)
    urlObject.host = a.host.split(":").shift();

    //protocol
    urlObject.protocol = a.protocol;  

    //port (get uniform browser behavior with port 80 here)
    if(options.ignorePort80) {
        urlObject.port = (a.port == "80" || a.port == "0") ? "" : a.port;
    } else {
        urlObject.port = (a.port == "" || a.port == "0") ? "80" : a.port;
    }

    //hash
    urlObject.hash = (options.ignoreHash || a.hash === "#") ? "" : a.hash;  
    
    //args
    var queryString = a.search;
    if (!queryString) {
        var qMark = url.indexOf("?");
        queryString = (qMark != -1) ? url.substr(qMark) : "";
    }
    urlObject.args = GeoGlobe.Util.getParameters(queryString,
            {splitArgs: options.splitArgs});

    // pathname
    //
    // This is a workaround for Internet Explorer where
    // window.location.pathname has a leading "/", but
    // a.pathname has no leading "/".
    urlObject.pathname = (a.pathname.charAt(0) == "/") ? a.pathname : "/" + a.pathname;
    
    return urlObject; 
};
 
/**
 * Takes a url and removes everything after the ? and #
 *  @memberof GeoGlobe.Util
 * @param {String} url  -  The url to process
 * 
 * @returns {String}  - The string with all queryString and Hash removed
 */
GeoGlobe.Util.removeTail = function(url) {
    var head = null;
    
    var qMark = url.indexOf("?");
    var hashMark = url.indexOf("#");

    if (qMark == -1) {
        head = (hashMark != -1) ? url.substr(0,hashMark) : url;
    } else {
        head = (hashMark != -1) ? url.substr(0,Math.min(qMark, hashMark)) 
                                  : url.substr(0, qMark);
    }
    return head;
};


GeoGlobe.IS_GECKO = (function() {
    var ua = navigator.userAgent.toLowerCase();
    return ua.indexOf("webkit") == -1 && ua.indexOf("gecko") != -1;
})();


GeoGlobe.CANVAS_SUPPORTED = (function() {
    var elem = document.createElement('canvas');
    return !!(elem.getContext && elem.getContext('2d'));
})();


GeoGlobe.BROWSER_NAME = (function() {
    var name = "";
    var ua = navigator.userAgent.toLowerCase();
    if (ua.indexOf("opera") != -1) {
        name = "opera";
    } else if (ua.indexOf("msie") != -1) {
        name = "msie";
    } else if (ua.indexOf("safari") != -1) {
        name = "safari";
    } else if (ua.indexOf("mozilla") != -1) {
        if (ua.indexOf("firefox") != -1) {
            name = "firefox";
        } else {
            name = "mozilla";
        }
    }
    return name;
})();

/**
 * @memberof GeoGlobe.Util
 * 
 * @returns {String}  - A string which specifies which is the current
 *          browser in which we are running. 
 * 
 *          Currently-supported browser detection and codes:
 *           * 'opera' -- Opera
 *           * 'msie'  -- Internet Explorer
 *           * 'safari' -- Safari
 *           * 'firefox' -- Firefox
 *           * 'mozilla' -- Mozilla
 * 
 *          If we are unable to property identify the browser, we 
 *           return an empty string.
 */
GeoGlobe.Util.getBrowserName = function() {
    return GeoGlobe.BROWSER_NAME;
};

/**
 * Renders the contentHTML offscreen to determine actual dimensions for
 *     popup sizing. As we need layout to determine dimensions the content
 *     is rendered -9999px to the left and absolute to ensure the 
 *     scrollbars do not flicker
 * @memberof GeoGlobe.Util

 * @param contentHTML
 * @param {GeoGlobe.Size} size  - If either the 'w' or 'h' properties is
 *     specified, we fix that dimension of the div to be measured. This is 
 *     useful in the case where we have a limit in one dimension and must 
 *     therefore meaure the flow in the other dimension.
 * @param {Object} options
 *
 * Allowed Options:
 *  @param {String} displayClass -  Optional parameter.  A CSS class name(s) string
 *         to provide the CSS context of the rendered content.
 * @param {DOMElement} containerElement  - Optional parameter. Insert the HTML to
 *         this node instead of the body root when calculating dimensions. 
 * 
 * @returns {GeoGlobe.Size}
 */
//GeoGlobe.Util.getRenderedDimensions = function(contentHTML, size, options) {
//    
//    var w, h;
//    
//    // create temp container div with restricted size
//    var container = document.createElement("div");
//    container.style.visibility = "hidden";
//        
//    var containerElement = (options && options.containerElement) 
//        ? options.containerElement : document.body;
//    
//    // Opera and IE7 can't handle a node with position:aboslute if it inherits
//    // position:absolute from a parent.
//    var parentHasPositionAbsolute = false;
//    var superContainer = null;
//    var parent = containerElement;
//    while (parent && parent.tagName.toLowerCase()!="body") {
//        var parentPosition = GeoGlobe.Element.getStyle(parent, "position");
//        if(parentPosition == "absolute") {
//            parentHasPositionAbsolute = true;
//            break;
//        } else if (parentPosition && parentPosition != "static") {
//            break;
//        }
//        parent = parent.parentNode;
//    }
//    if(parentHasPositionAbsolute && (containerElement.clientHeight === 0 || 
//                                     containerElement.clientWidth === 0) ){
//        superContainer = document.createElement("div");
//        superContainer.style.visibility = "hidden";
//        superContainer.style.position = "absolute";
//        superContainer.style.overflow = "visible";
//        superContainer.style.width = document.body.clientWidth + "px";
//        superContainer.style.height = document.body.clientHeight + "px";
//        superContainer.appendChild(container);
//    }
//    container.style.position = "absolute";
//
//    //fix a dimension, if specified.
//    if (size) {
//        if (size.w) {
//            w = size.w;
//            container.style.width = w + "px";
//        } else if (size.h) {
//            h = size.h;
//            container.style.height = h + "px";
//        }
//    }
//
//    //add css classes, if specified
//    if (options && options.displayClass) {
//        container.className = options.displayClass;
//    }
//    
//    // create temp content div and assign content
//    var content = document.createElement("div");
//    content.innerHTML = contentHTML;
//    
//    // we need overflow visible when calculating the size
//    content.style.overflow = "visible";
//    if (content.childNodes) {
//        for (var i=0, l=content.childNodes.length; i<l; i++) {
//            if (!content.childNodes[i].style) continue;
//            content.childNodes[i].style.overflow = "visible";
//        }
//    }
//    
//    // add content to restricted container 
//    container.appendChild(content);
//    
//    // append container to body for rendering
//    if (superContainer) {
//        containerElement.appendChild(superContainer);
//    } else {
//        containerElement.appendChild(container);
//    }
//    
//    // calculate scroll width of content and add corners and shadow width
//    if (!w) {
//        w = parseInt(content.scrollWidth);
//    
//        // update container width to allow height to adjust
//        container.style.width = w + "px";
//    }        
//    // capture height and add shadow and corner image widths
//    if (!h) {
//        h = parseInt(content.scrollHeight);
//    }
//
//    // remove elements
//    container.removeChild(content);
//    if (superContainer) {
//        superContainer.removeChild(container);
//        containerElement.removeChild(superContainer);
//    } else {
//        containerElement.removeChild(container);
//    }
//    
//    return new GeoGlobe.Size(w, h);
//};

/**
 * This function has been modified by the OpenLayers from the original version,
 *     written by Matthew Eernisse and released under the Apache 2 license here:
 *     http://www.fleegix.org/articles/2006/05/30/getting-the-scrollbar-width-in-pixels
 * @memberof GeoGlobe.Util
 *     It has been modified simply to cache its value, since it is physically 
 *     impossible that this code could ever run in more than one browser at once.
 * 
 * @returns {Integer}
 */
GeoGlobe.Util.getScrollbarWidth = function() {
    
    var scrollbarWidth = GeoGlobe.Util._scrollbarWidth;
    
    if (scrollbarWidth == null) {
        var scr = null;
        var inn = null;
        var wNoScroll = 0;
        var wScroll = 0;
    
        // Outer scrolling div
        scr = document.createElement('div');
        scr.style.position = 'absolute';
        scr.style.top = '-1000px';
        scr.style.left = '-1000px';
        scr.style.width = '100px';
        scr.style.height = '50px';
        // Start with no scrollbar
        scr.style.overflow = 'hidden';
    
        // Inner content div
        inn = document.createElement('div');
        inn.style.width = '100%';
        inn.style.height = '200px';
    
        // Put the inner div in the scrolling div
        scr.appendChild(inn);
        // Append the scrolling div to the doc
        document.body.appendChild(scr);
    
        // Width of the inner div sans scrollbar
        wNoScroll = inn.offsetWidth;
    
        // Add the scrollbar
        scr.style.overflow = 'scroll';
        // Width of the inner div width scrollbar
        wScroll = inn.offsetWidth;
    
        // Remove the scrolling div from the doc
        document.body.removeChild(document.body.lastChild);
    
        // Pixel width of the scroller
        GeoGlobe.Util._scrollbarWidth = (wNoScroll - wScroll);
        scrollbarWidth = GeoGlobe.Util._scrollbarWidth;
    }

    return scrollbarWidth;
};

/**
 *
 * This function will return latitude or longitude value formatted as
 * @memberof GeoGlobe.Util
 * @param {Float} coordinate  - the coordinate value to be formatted
 * @param {String} axis  - value of either 'lat' or 'lon' to indicate which axis is to to be formatted (default = lat)
 * @param {String} dmsOption -  specify the precision of the output can be one of:
 *           'dms' show degrees minutes and seconds
 *           'dm' show only degrees and minutes
 *           'd' show only degrees
 * 
 * @returns {String}  - the coordinate value formatted as a string
 */
/*
GeoGlobe.Util.getFormattedLonLat = function(coordinate, axis, dmsOption) {
    if (!dmsOption) {
        dmsOption = 'dms';    //default to show degree, minutes, seconds
    }

    coordinate = (coordinate+540)%360 - 180; // normalize for sphere being round

    var abscoordinate = Math.abs(coordinate);
    var coordinatedegrees = Math.floor(abscoordinate);

    var coordinateminutes = (abscoordinate - coordinatedegrees)/(1/60);
    var tempcoordinateminutes = coordinateminutes;
    coordinateminutes = Math.floor(coordinateminutes);
    var coordinateseconds = (tempcoordinateminutes - coordinateminutes)/(1/60);
    coordinateseconds =  Math.round(coordinateseconds*10);
    coordinateseconds /= 10;

    if( coordinateseconds >= 60) { 
        coordinateseconds -= 60; 
        coordinateminutes += 1; 
        if( coordinateminutes >= 60) { 
            coordinateminutes -= 60; 
            coordinatedegrees += 1; 
        } 
    }
    
    if( coordinatedegrees < 10 ) {
        coordinatedegrees = "0" + coordinatedegrees;
    }
    var str = coordinatedegrees + "\u00B0";

    if (dmsOption.indexOf('dm') >= 0) {
        if( coordinateminutes < 10 ) {
            coordinateminutes = "0" + coordinateminutes;
        }
        str += coordinateminutes + "'";
  
        if (dmsOption.indexOf('dms') >= 0) {
            if( coordinateseconds < 10 ) {
                coordinateseconds = "0" + coordinateseconds;
            }
            str += coordinateseconds + '"';
        }
    }
    
    if (axis == "lon") {
        str += coordinate < 0 ? GeoGlobe.i18n("W") : GeoGlobe.i18n("E");
    } else {
        str += coordinate < 0 ? GeoGlobe.i18n("S") : GeoGlobe.i18n("N");
    }
    return str;
};
*/
//生成num个数的随机字符串
GeoGlobe.Util.randomStr = function (num) {
	var random = "";
	var randArr = [];
	for(var i=0;i<num;i++){
		var randNum = Math.ceil(Math.random() * 25);
		randArr.push(String.fromCharCode(97+randNum));
	}
	for(var i=0;i<num;i++){
		random += randArr[i];
	}
	return random;
};
//执行js
GeoGlobe.Util.globalEval = function(data) {
	if (data && GeoGlobe.String.trim(data)){
		// We use execScript on Internet Explorer
		// We use an anonymous function so that context is window
		// rather than in Firefox
		(window.execScript || function(data){
			window["eval"].call(window, data);
		})(data);
	}
};

//根据比例尺，单位和dpi获取分辨率
GeoGlobe.Util.getResolutionFromScale_DPI = function(scale, units, dpi){
	var resolution;
    if (scale) {
        if (units == null) {
            units = "degrees";
        }
        var normScale = GeoGlobe.Util.normalizeScale(scale);
        resolution = 1 / (normScale * GeoGlobe.INCHES_PER_UNIT[units] * dpi);
    }
    return resolution;
};

//根据分辨率，单位和dpi获取比例尺
GeoGlobe.Util.getScaleFromResolution_DPI = function(resolution, units, dpi){
	if (units == null) {
        units = "degrees";
    }

    var scale = resolution * GeoGlobe.INCHES_PER_UNIT[units] * dpi;
    return scale;
};

/**
 * 根据分辨率获取层级
 *  @memberof GeoGlobe.Util
 */
GeoGlobe.Util.getMapLevelFormResolution = function(map, resolution){
    if (!resolution) {
        return 0;
    }
	var zoom, i, diff;
	var minDiff = Number.POSITIVE_INFINITY;
	var resolutions = map.getResolutions();
	for (i = 0, len = resolutions.length; i < len; i++) {
		//判断当前分辨率与金字塔中分辨率最接近的
        diff = Math.abs(resolutions[i] - resolution);
        if (diff > minDiff) {
            break;
        }
        minDiff = diff;
	}
	zoom = Math.max(0, i - 1);//0和(i - 1)中取大数。
	return zoom ;
};

/**
 * 根据比例尺获取层级
 *  @memberof GeoGlobe.Util
 */
GeoGlobe.Util.getMapLevelFormScale = function(map, scale, units, dpi){
	////var lvl_arcgis_gd = getLevelFormScale(2.792281947544293E8); //1
	var units = units ? units : "degrees";
	var dpi = dpi ? dpi : 96;
	var resolution = GeoGlobe.Util.getResolutionFromScale_DPI(scale, units, dpi);
	var lvl = GeoGlobe.Util.getMapLevelFormResolution(map, resolution);
	return lvl;
};

/**
 * 这里返回一个函数，如果它被不间断地调用，它将不会得到执行。
 * 该函数在停止调用 N 毫秒后，再次调用它才会得到执行。
 * 如果有传递 ‘immediate’ 参数，会马上将函数安排到执行队列中，而不会延迟。
 * exam: 	var myEfficientFn = GeoGlobe.Util.delayFun (function() {
 * 				// 所有繁重的操作
 * 			}, 250);
 * 			window.addEventListener('resize', myEfficientFn);
 * @memberof GeoGlobe.Util
 */
GeoGlobe.Util.delayFun = function(func, wait, immediate) {
    var timeout;
    return function() {
        var context = this, args = arguments;
        var later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
};

/**
 * 深度克隆方法。
 * @memberof GeoGlobe.Util
 */
GeoGlobe.Util.clone = function(myObj){
    if (typeof(myObj) != 'object') 
        return myObj;
    if (myObj == null) 
        return myObj;
    //var myNewObj = new Object();
    var myNewObj = (myObj.constructor == Array) ? [] : {};
    
    for (var i in myObj) 
        myNewObj[i] = GeoGlobe.Util.clone(myObj[i]);
    
    return myNewObj;
};

/**
 * 获取对象的类型
 * @memberof GeoGlobe.Util
 * @param {Object} obj 目标对象
 * @return {String} type 对象类型
 */
GeoGlobe.Util.getType = function (obj) {
    var toString = Object.prototype.toString;
    var map = {
        '[object Boolean]': 'boolean',
        '[object Number]': 'number',
        '[object String]': 'string',
        '[object Function]': 'function',
        '[object Array]': 'array',
        '[object Date]': 'date',
        '[object RegExp]': 'regExp',
        '[object Undefined]': 'undefined',
        '[object Null]': 'null',
        '[object Object]': 'object'
    };
    if (obj instanceof Element) {
        return 'element';
    }
    return map[toString.call(obj)];
};

/**
 * 将数字转化为千位分隔与保留多少位小数num：数字，cent，保留小数位数，是否转化为千分位分隔（默认false）
 * @memberof GeoGlobe.Util
 * @param {Object} num 数字
 * @param {Number} cent 保留小数位数
 * @param {Boolean} isThousand 是否转化为千分位分隔（默认false）
 */
GeoGlobe.Util.formatNumberToThousands = function (num, cent, isThousand) {
    num = num.toString().replace(/\$|\,/g, '');

    // 检查传入数值为数值类型
    if (isNaN(num))
        num = "0";

    // 获取符号(正/负数)
    var sign = (num === (num = Math.abs(num)));

    num = Math.floor(num * Math.pow(10, cent) + 0.50000000001); // 把指定的小数位先转换成整数.多余的小数位四舍五入
    var cents = num % Math.pow(10, cent);       // 求出小数位数值
    num = Math.floor(num / Math.pow(10, cent)).toString();  // 求出整数位数值
    cents = cents.toString();        // 把小数位转换成字符串,以便求小数位长度

    // 补足小数位到指定的位数
    while (cents.length < cent)
        cents = "0" + cents;

    if (isThousand) {
        // 对整数部分进行千分位格式化.
        for (var i = 0; i < Math.floor((num.length - (1 + i)) / 3); i++)
            num = num.substring(0, num.length - (4 * i + 3)) + ',' + num.substring(num.length - (4 * i + 3));
    }

    if (cent > 0)
        return (((sign) ? '' : '-') + num + '.' + cents);
    else
        return (((sign) ? '' : '-') + num);
};

/**
 * 获取根据模板格式化后的字符串
 * @memberof GeoGlobe.Util
 * @param {Object} metadata 元数据，如：{a: '北京市', b: '统计数', c: 99.99}
 * @param {String} formatter 模板，如：'{a}<br/>{c} {c2}'
 * @returns {String} str 字符串
 */
GeoGlobe.Util.getFormattedString = function (metadata, formatter) {
    var str = formatter;
    str = str.replace(/{a}/g, metadata['a']);
    str = str.replace(/{b}/g, metadata['b']);

    if (str.contains('{c')) {
        var arrs = str.split('{c');
        var fixed = 0;
        for (var i = 0; i < arrs.length - 1; i++) {
            fixed = arrs[i + 1].split('}')[0];
            str = str.replace(new RegExp("{c" + fixed + "}", "g"), GeoGlobe.Util.formatNumberToThousands(parseFloat(metadata['c']), fixed === '' ? 2 : fixed, true));
        }
    }
    return str;
};

/**
 * 生成渐进色像素数据
 * @memberof GeoGlobe.Util
 * @param {Object} gradientColor 渐进色配置
 * @return {CanvasPixelArray} data 像素数据
 */
GeoGlobe.Util.getGradientImageData = function (gradientColor) {
    var cvs = document.createElement('canvas');
    var ctx = cvs.getContext('2d');
    cvs.width = 1;
    cvs.height = 256;

    var gradient = ctx.createLinearGradient(0, 0, 0, 256);
    for (var i in gradientColor) {
        if (gradientColor.hasOwnProperty(i)) {
            gradient.addColorStop(i, gradientColor[i]);
        }
    }
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 1, 256);
    return ctx.getImageData(0, 0, 1, 256).data;
};

/**
 * 转换为rgb|hsl颜色
 * @memberof GeoGlobe.Util
 * @param {String} color 颜色，支持：#f00|#ff0000、rgb(255,0,0)、rgba(255,0,0,1)、hsl(360,100%,50%)、hsla(360,100%,50%,1)
 * @returns {String} color rgb|hsl颜色
 */
GeoGlobe.Util.getRgbColor = function (color) {
    color = color.toLowerCase();

    //十六进制颜色值的正则表达式
    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
    if (color && reg.test(color)) {
        if (color.length === 4) {
            var tmp = "#";
            for (var i = 1; i < 4; i += 1) {
                tmp += color.slice(i, i + 1).concat(color.slice(i, i + 1));
            }
            color = tmp;
        }
        tmp = [];
        for (var i = 1; i < 7; i += 2) {
            tmp.push(parseInt("0x" + color.slice(i, i + 2)));
        }
        return "rgb(" + tmp.join(",") + ")";
    } else {
        if (color.startsWith("rgba") || color.startsWith("hsla")) {
            return color.substring(0, 3) + color.substring(4, color.lastIndexOf(',')) + ')';
        }
        if (color.startsWith("rgb") || color.startsWith("hsl")) {
            return color;
        }
        return '';
    }
};

/**
 * 获取颜色的明暗色
 * @memberof GeoGlobe.Util
 * @param {String} color 颜色
 * @param {Number} percent 明暗程度
 * @returns {String} color 计算后的颜色
 */
GeoGlobe.Util.getShadeColor = function (color, percent) {
    color = GeoGlobe.Util.getHexColor(color);
    color = color.substr(1);
    var num = parseInt(color, 16),
        amt = Math.round(2.55 * percent),
        R = (num >> 16) + amt,
        G = (num >> 8 & 0x00FF) + amt,
        B = (num & 0x0000FF) + amt;
    return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
};

/**
 * 转换为十六进制颜色
 * @memberof GeoGlobe.Util
 * @param {String} color 颜色，支持：#f00|#ff0000、rgb(255,0,0)|rgba(255,0,0,1)
 * @returns {String} color 十六进制颜色
 */
GeoGlobe.Util.getHexColor = function (color) {
    color = color.toLowerCase();

    if (/^(rgb|rgba)/.test(color)) {
        var colors = color.split('(')[1].split(')')[0].split(",");
        var strHex = "#";
        for (var i = 0; i < 3; i++) {
            var hex = Number(colors[i]).toString(16);
            if (hex === "0") {
                hex += hex;
            }
            if (hex.length ===1){
                hex = "0" + hex;
            }
            strHex += hex;
        }
        if (strHex.length !== 7) {
            strHex = color;
        }
        return strHex;
    } else if (/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(color)) {
        var aNum = color.replace(/#/, "").split("");
        if (aNum.length === 6) {
            return color;
        } else if (aNum.length === 3) {
            var numHex = "#";
            for (var i = 0; i < aNum.length; i += 1) {
                numHex += (aNum[i] + aNum[i]);
            }
            return numHex;
        }
    } else {
        return color;
    }
};

/**
 * 墨卡托转换标准经纬度坐标
 * @memberof GeoGlobe.Util
 * @param {Array} mercator 墨卡托坐标
 * @return {Array} lonLat 标准经纬度坐标
 */
GeoGlobe.Util.transferToLonLat = function (mercator) {
    if (mercator[1] === -238107693.23182276) {
        return [mercator[0] / 20037508.34 * 180, -90];
    } else {
        return [mercator[0] / 20037508.34 * 180, 180 / Math.PI * (2 * Math.atan(Math.exp(mercator[1] / 20037508.34 * 180 * Math.PI / 180)) - Math.PI / 2)];
    }
};

/**
 * 标准经纬度转换墨卡托坐标
 * @memberof GeoGlobe.Util
 * @param {Array} lonLat 标准经纬度坐标
 * @return {Array} mercator 墨卡托坐标
 */
GeoGlobe.Util.transferToMercator = function (lonLat) {
    if (lonLat[1] === -90) {
        return [lonLat[0] * 20037508.34 / 180, -238107693.23182276];
    } else {
        return [lonLat[0] * 20037508.34 / 180, Math.log(Math.tan((90 + lonLat[1]) * Math.PI / 360)) / (Math.PI / 180) * 20037508.34 / 180];
    }
};

/**
 * 本命名空间是对在GeoGlobe原生的基础上进行的扩展，用于定义常用投影坐标轴读取的方向。
 * 说明:
 * 目前WMS图层类的添加；WMTS能力描述信息的解析，以及WFS能力描述信息的解析需要用到本命名空间下的属性。
 * @namespace  GeoGlobe.ProjAxisOrder
 * @private
 */
GeoGlobe.ProjAxisOrder = {
	//East/North ordering (lat/lon)
	AXIS_ORDER_EN: true, //经度，纬度
	AXIS_ORDER_NE: false //纬度，经度
};
//
GeoGlobe.ProjAxisOrder.AxisOrder = {
	'EPSG:900913': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'WGS84': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	'IGNF:WGS84G': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	'EPSG:4326': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,//纬度，经度
	"EPSG:4490": GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,//纬度，经度
	'EPSG:4269': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	'EPSG:2361': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	'EPSG:27700': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:904490': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	
	'EPSG:4171'	: GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE, 
	
	'EPSG:32637': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:32638': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:32639': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:32640': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:32641': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,			 
	
	'EPSG:28991': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:28992': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,					 
	
	'EPSG:31300': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:31370': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,			
	
	'EPSG:2176': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2177': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2178': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2179': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2180': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	
	'EPSG:2154'	: GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN, 	
	
	'EPSG:3346' : GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:3857' : GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2065' : GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN
};
GeoGlobe.SpatialReference = GeoGlobe.Class({

    /**
     * Proj4js.Proj instance.
     * @memberof GeoGlobe.SpatialReference.prototype
     * @type {Object}
     * @private
     */
    proj: null,
    
    /**
     * @memberof GeoGlobe.SpatialReference.prototype
     * @type {String}
     *
     */
    projCode: null,
    
    /**
     *  regular expression to strip the title from a proj4js definition
     *  @memberof GeoGlobe.SpatialReference.prototype
     *  @type {RegExp}
     */
    titleRegEx: /\+title=[^\+]*/,

    /**
     * @class GeoGlobe.Projection
     * @classdesc This class offers several methods for interacting with a wrapped pro4js projection object.
     *
     * @param {String} projCode  -  A string identifying the Well Known Identifier for
     *    the projection.
     * @param {Object}  options  - An optional object to set additional properties
     *     on the projection.
     *
     * @returns {GeoGlobe.Projection}  - A projection object.
     * @private
     */
    initialize: function(projCode, options) {
        GeoGlobe.Util.extend(this, options);
        this.projCode = projCode;
        if (typeof Proj4js == "object") {
            this.proj = new Proj4js.Proj(projCode);
        }
    },
    
    /**
     *  Get the string SRS code.
     * @memberof GeoGlobe.Projection.prototype
     * @returns {String}  - The SRS code.
     */
    getCode: function() {
        return this.proj ? this.proj.srsCode : this.projCode;
    },
   
    /**
     * Get the units string for the projection -- returns null if 
     *     proj4js is not available.
     * @memberof GeoGlobe.Projection.prototype
     * @returns {String}  - The units abbreviation.
     */
    getUnits: function() {
        return this.proj ? this.proj.units : null;
    },

    /**
     *  Convert projection to string (getCode wrapper).
     * @memberof GeoGlobe.Projection.prototype
     * @returns  {String}  - The projection code.
     */
    toString: function() {
        return this.getCode();
    },

    /**
     * Test equality of two projection instances.  Determines equality based
     *     soley on the projection code.
     * @memberof GeoGlobe.Projection.prototype
     * @returns {Boolean}  - The two projections are equivalent.
     */
    equals: function(projection) {
        var p = projection, equals = false;
        if (p) {
            if (!(p instanceof GeoGlobe.SpatialReference)) {
                p = new GeoGlobe.SpatialReference(p);
            }
            if ((typeof Proj4js == "object") && this.proj.defData && p.proj.defData) {
                equals = this.proj.defData.replace(this.titleRegEx, "") ==
                    p.proj.defData.replace(this.titleRegEx, "");
            } else if (p.getCode) {
                var source = this.getCode(), target = p.getCode();
                equals = source == target ||
                    !!GeoGlobe.SpatialReference.transforms[source] &&
                    GeoGlobe.SpatialReference.transforms[source][target] ===
                    GeoGlobe.SpatialReference.nullTransform;
            }
        }
        return equals;   
    },

    /* Method: destroy
     * Destroy projection object.
     */
    destroy: function() {
        delete this.proj;
        delete this.projCode;
    },
    
    CLASS_NAME: "GeoGlobe.SpatialReference"
});     

/**
 * Transforms is an object, with from properties, each of which may
 *      have a to property. This allows you to define projections without
 *      requiring support for proj4js to be included.
 *
 * This object has keys which correspond to a 'source' projection object.  The
 * keys should be strings, corresponding to the projection.getCode() value.
 * Each source projection object should have a set of destination projection
 * keys included in the object. 
 * 
 * Each value in the destination object should be a transformation function,
 * where the function is expected to be passed an object with a .x and a .y
 * property.  The function should return the object, with the .x and .y
 * transformed according to the transformation function.
 *
 * Note - Properties on this object should not be set directly.  To add a
 *     transform method to this object, use the <addTransform> method.  For an
 *     example of usage, see the OpenLayers.Layer.SphericalMercator file.
 * @memberof GeoGlobe.Projection.prototype
 * @type {Object}
 */
GeoGlobe.SpatialReference.transforms = {};

/**
 * Defaults for the SRS codes known to OpenLayers (currently
 *      EPSG:4326, CRS:84, urn:ogc:def:crs:EPSG:6.6:4326, EPSG:900913, EPSG:3857,
 *      EPSG:102113 and EPSG:102100). Keys are the SRS code, values are units,
 *      maxExtent (the validity extent for the SRS) and yx (true if this SRS is
 *      known to have a reverse axis order).
 * @memberof GeoGlobe.Projection.prototype
 * @type {Object}
 */
GeoGlobe.SpatialReference.defaults = {
    "EPSG:4326": {
        units: "degrees",
        maxExtent: [-180, -90, 180, 90],
        yx: true
    },
    "CRS:84": {
        units: "degrees",
        maxExtent: [-180, -90, 180, 90]
    },
    "EPSG:900913": {
        units: "m",
        maxExtent: [-20037508.34, -20037508.34, 20037508.34, 20037508.34]
    }
};

/**
 * Set a custom transform method between two projections.  Use this method in
 *     cases where the proj4js lib is not available or where custom projections
 *     need to be handled.
 * @memberof GeoGlobe.Projection.prototype
 * @param  {String} from  - The code for the source projection
 * @param {String} to  - the code for the destination projection
 * @param {Function} method  -  A function that takes a point as an argument and
 *     transforms that point from the source to the destination projection
 *     in place.  The original point should be modified.
 */
GeoGlobe.SpatialReference.addTransform = function(from, to, method) {
    if (method === GeoGlobe.SpatialReference.nullTransform) {
        var defaults = GeoGlobe.SpatialReference.defaults[from];
        if (defaults && !GeoGlobe.SpatialReference.defaults[to]) {
            GeoGlobe.SpatialReference.defaults[to] = defaults;
        }
    }
    if(!GeoGlobe.SpatialReference.transforms[from]) {
        GeoGlobe.SpatialReference.transforms[from] = {};
    }
    GeoGlobe.SpatialReference.transforms[from][to] = method;
};

/**
 * Transform a point coordinate from one projection to another.  Note that
 *     the input point is transformed in place.
 * @memberof GeoGlobe.Projection.prototype
 * @param {OpenLayers.Geometry.Point | Object}  point  - An object with x and y
 *     properties representing coordinates in those dimensions.
 * @param {OpenLayers.Projection} source  - Source map coordinate system
 * @param {OpenLayers.Projection} dest  - Destination map coordinate system
 *
 * @returns {object} point  -  A transformed coordinate.  The original point is modified.
 */
GeoGlobe.SpatialReference.transform = function(point, source, dest) {
    if (source && dest) {
        if (!(source instanceof GeoGlobe.SpatialReference)) {
            source = new GeoGlobe.SpatialReference(source);
        }
        if (!(dest instanceof GeoGlobe.SpatialReference)) {
            dest = new GeoGlobe.SpatialReference(dest);
        }
        if (source.proj && dest.proj) {
            point = Proj4js.transform(source.proj, dest.proj, point);
        } else {
            var sourceCode = source.getCode();
            var destCode = dest.getCode();
            var transforms = GeoGlobe.SpatialReference.transforms;
            if (transforms[sourceCode] && transforms[sourceCode][destCode]) {
                transforms[sourceCode][destCode](point);
            }
        }
    }
    return point;
};

/**
 * A null transformation - useful for defining projection aliases when
 * proj4js is not available:
 * @memberof GeoGlobe.Projection.prototype
 * @example
 * (code)
 * GeoGlobe.Projection.addTransform("EPSG:3857", "EPSG:900913",
 *     GeoGlobe.Projection.nullTransform);
 * GeoGlobe.Projection.addTransform("EPSG:900913", "EPSG:3857",
 *     GeoGlobe.Projection.nullTransform);
 * (end)
 */
GeoGlobe.SpatialReference.nullTransform = function(point) {
    return point;
};

/**
 * Note: Transforms for web mercator <-> geographic
 * OpenLayers recognizes EPSG:3857, EPSG:900913, EPSG:102113 and EPSG:102100.
 * OpenLayers originally started referring to EPSG:900913 as web mercator.
 * The EPSG has declared EPSG:3857 to be web mercator.
 * ArcGIS 10 recognizes the EPSG:3857, EPSG:102113, and EPSG:102100 as
 * equivalent.  See http://blogs.esri.com/Dev/blogs/arcgisserver/archive/2009/11/20/ArcGIS-Online-moving-to-Google-_2F00_-Bing-tiling-scheme_3A00_-What-does-this-mean-for-you_3F00_.aspx#12084.
 * For geographic, OpenLayers recognizes EPSG:4326, CRS:84 and
 * urn:ogc:def:crs:EPSG:6.6:4326. OpenLayers also knows about the reverse axis
 * order for EPSG:4326. 
 */
(function() {

    var pole = 20037508.34;

    function inverseMercator(xy) {
        xy.x = 180 * xy.x / pole;
        xy.y = 180 / Math.PI * (2 * Math.atan(Math.exp((xy.y / pole) * Math.PI)) - Math.PI / 2);
        return xy;
    }

    function forwardMercator(xy) {
        xy.x = xy.x * pole / 180;
        var y = Math.log(Math.tan((90 + xy.y) * Math.PI / 360)) / Math.PI * pole;
        xy.y = Math.max(-20037508.34, Math.min(y, 20037508.34));
        return xy;
    }

    function map(base, codes) {
        var add = GeoGlobe.SpatialReference.addTransform;
        var same = GeoGlobe.SpatialReference.nullTransform;
        var i, len, code, other, j;
        for (i=0, len=codes.length; i<len; ++i) {
            code = codes[i];
            add(base, code, forwardMercator);
            add(code, base, inverseMercator);
            for (j=i+1; j<len; ++j) {
                other = codes[j];
                add(code, other, same);
                add(other, code, same);
            }
        }
    }
    
    // list of equivalent codes for web mercator
    var mercator = ["EPSG:900913", "EPSG:3857", "EPSG:102113", "EPSG:102100"],
        geographic = ["CRS:84", "urn:ogc:def:crs:EPSG:6.6:4326", "EPSG:4326"],
        i;
    for (i=mercator.length-1; i>=0; --i) {
        map(mercator[i], geographic);
    }
    for (i=geographic.length-1; i>=0; --i) {
        map(geographic[i], mercator);
    }

})();

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * The GeoGlobe.Console namespace is used for debugging and error logging.
 *      If the Firebug Lite (../Firebug/firebug.js) is included before this script,
 *      calls to GeoGlobe.Console methods will get redirected to window.console.
 *      This makes use of the Firebug extension where available and allows for
 *      cross-browser debugging Firebug style.
 *
 *
 * Note:
 * Note that behavior will differ with the Firebug extention and Firebug Lite.
 * Most notably, the Firebug Lite console does not currently allow for
 * hyperlinks to code or for clicking on object to explore their properties.
 * @namespace  GeoGlobe.Console
 * @private
 */
GeoGlobe.Console = {
    /**
     * Create empty functions for all console methods.  The real value of these
     * properties will be set if Firebug Lite (../Firebug/firebug.js script) is
     * included.  We explicitly require the Firebug Lite script to trigger
     * functionality of the GeoGlobe.Console methods.
     */
    
    /**
     * Log an object in the console.  The Firebug Lite console logs string
     * representation of objects.  Given multiple arguments, they will
     * be cast to strings and logged with a space delimiter.  If the first
     * argument is a string with printf-like formatting, subsequent arguments
     * will be used in string substitution.  Any additional arguments (beyond
     * the number substituted in a format string) will be appended in a space-
     * delimited line.
     * @function log
     * @memberof GeoGlobe.Console
     * @param {Object} object
     */
    log: function() {},

    /**
     * Writes a message to the console, including a hyperlink to the line
     * where it was called.
     * @function debug
     * @memberof GeoGlobe.Console
     *
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     *
     * @param {Object} object
     */
    debug: function() {},

    /**
     * Writes a message to the console with the visual "info" icon and color
     * coding and a hyperlink to the line where it was called.
     * @function info
     * @memberof GeoGlobe.Console
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     *
     * @param {Object} object
     */
    info: function() {},

    /**
     * Writes a message to the console with the visual "warning" icon and
     * color coding and a hyperlink to the line where it was called.
     * @function warn
     * @memberof GeoGlobe.Console
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     *
     * @param {Object} object
     */
    warn: function() {},

    /**
     * Writes a message to the console with the visual "error" icon and color
     * coding and a hyperlink to the line where it was called.
     * @function error
     * @memberof GeoGlobe.Console
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     *
     * @param {Object} object
     */
    error: function() {},
    
    /**
     * A single interface for showing error messages to the user. The default
     * behavior is a Javascript alert, though this can be overridden by
     * reassigning GeoGlobe.Console.userError to a different function.
     * @function userError
     * @memberof GeoGlobe.Console
     * Expects a single error message
     *
     * @param  {Object} error
     */
    userError: function(error) {
        alert(error);
    },

    /**
     * Tests that an expression is true. If not, it will write a message to
     * the console and throw an exception.
     * @function assert
     * @memberof GeoGlobe.Console
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     *
     * @param {Object}  object
     */
    assert: function() {},

    /**
     * Prints an interactive listing of all properties of the object. This
     * looks identical to the view that you would see in the DOM tab.
     * @function dir
     * @memberof GeoGlobe.Console
     * @param {Object} object
     */
    dir: function() {},

    /**
     * Prints the XML source tree of an HTML or XML element. This looks
     * identical to the view that you would see in the HTML tab. You can click
     * on any node to inspect it in the HTML tab.
     * @function dirxml
     * @memberof GeoGlobe.Console
     * @param  {Object} object
     */
    dirxml: function() {},

    /**
     * Prints an interactive stack trace of JavaScript execution at the point
     * where it is called.  The stack trace details the functions on the stack,
     * as well as the values that were passed as arguments to each function.
     * You can click each function to take you to its source in the Script tab,
     * and click each argument value to inspect it in the DOM or HTML tabs.
     * @function trace
     *  @memberof GeoGlobe.Console
     */
    trace: function() {},

    /**
     * Writes a message to the console and opens a nested block to indent all
     * future messages sent to the console. Call GeoGlobe.Console.groupEnd()
     * to close the block.
     * @function group
     * @memberof GeoGlobe.Console
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     *
     * @param {Object} object
     */
    group: function() {},

    /**
     * Closes the most recently opened block created by a call to
     * GeoGlobe.Console.group
     * @function groupEnd
     * @memberof GeoGlobe.Console
     */
    groupEnd: function() {},
    
    /**
     * Creates a new timer under the given name. Call
     * GeoGlobe.Console.timeEnd(name)
     * with the same name to stop the timer and print the time elapsed.
     * @function time
     * @memberof GeoGlobe.Console
     * @param {String} name
     */
    time: function() {},

    /**
     * Stops a timer created by a call to GeoGlobe.Console.time(name) and
     * writes the time elapsed.
     * @function timeEnd
     * @memberof GeoGlobe.Console
     * @param {String} name
     */
    timeEnd: function() {},

    /**
     * Turns on the JavaScript profiler. The optional argument title would
     * contain the text to be printed in the header of the profile report.
     * @function profile
     * @memberof GeoGlobe.Console
     * This function is not currently implemented in Firebug Lite.
     *
     * @param {String}  title - Optional title for the profiler
     */
    profile: function() {},

    /**
     * Turns off the JavaScript profiler and prints its report.
     * @function profileEnd
     *  @memberof GeoGlobe.Console
     * This function is not currently implemented in Firebug Lite.
     */
    profileEnd: function() {},

    /**
     * Writes the number of times that the line of code where count was called
     * was executed. The optional argument title will print a message in
     * addition to the number of the count.
     * @function count
     * @memberof GeoGlobe.Console
     * This function is not currently implemented in Firebug Lite.
     *
     * @param {String}  title - Optional title to be printed with count
     */
    count: function() {},

    CLASS_NAME: "GeoGlobe.Console"
};

/**
 * Execute an anonymous function to extend the GeoGlobe.Console namespace
 * if the firebug.js script is included.  This closure is used so that the
 * "scripts" and "i" variables don't pollute the global namespace.
 */
(function() {
    /**
     * If Firebug Lite is included (before this script), re-route all
     * GeoGlobe.Console calls to the console object.
     */
    var scripts = document.getElementsByTagName("script");
    for(var i=0, len=scripts.length; i<len; ++i) {
        if(scripts[i].src.indexOf("firebug.js") != -1) {
            if(console) {
                GeoGlobe.Util.extend(GeoGlobe.Console, console);
                break;
            }
        }
    }
})();

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * TODO: deprecate me
 * Use GeoGlobe.Request.proxy instead.
 */
GeoGlobe.ProxyHost = "";

/**
 * The GeoGlobe.Request namespace contains convenience methods for working
 *     with XMLHttpRequests.  These methods work with a cross-browser
 *     W3C compliant GeoGlobe.Request.XMLHttpRequest class.
 * @namespace GeoGlobe.Request
 * @private
 */
if (!GeoGlobe.Request) {
    /**
     * This allows for tool/Request/XMLHttpRequest.js to be included
     * before or after this script.
     */
    GeoGlobe.Request = {};
}
GeoGlobe.Util.extend(GeoGlobe.Request, {

    DEFAULT_CONFIG: {
        method: "GET",
        url: window.location.href,
        async: true,
        user: undefined,
        password: undefined,
        params: null,
        proxy: GeoGlobe.ProxyHost,
        headers: {},
        data: null,
        callback: function() {},
        success: null,
        failure: null,
        scope: null
    },
    

    URL_SPLIT_REGEX: /([^:]*:)\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/,
    
    /**
     * An events object that handles all events on the {GeoGlobe.Request} object.
     * @memberof GeoGlobe.Request
     *
     *
     * All event listeners will receive an event object with three properties:
     * @param {GeoGlobe.Request.XMLHttpRequest} request  -  The request object.
     * @param {Object} config  - The config object sent to the specific request method.
     * @param {String} requestUrl  - The request url.
     * 
     * Supported event types:
     * complete - Triggered when we have a response from the request, if a
     *     listener returns false, no further response processing will take
     *     place.
     * success - Triggered when the HTTP response has a success code (200-299).
     * failure - Triggered when the HTTP response does not have a success code.
     */
    //events: new GeoGlobe.Events(this),
    
    /**
     *  Using the specified proxy, returns a same origin url of the provided url.
     * @memberof GeoGlobe.Request
     * @param {String} url  - An arbitrary url
     * @param {String|Function} proxy   - The proxy to use to make the provided url a same origin url.
     *
     * @returns {String}
     * - the same origin url. If no proxy is provided, the returned url
     *     will be the same as the provided url.
     */
    makeSameOrigin: function(url, proxy) {
        var sameOrigin = url.indexOf("http") !== 0;
        var urlParts = !sameOrigin && url.match(this.URL_SPLIT_REGEX);
        if (urlParts) {
            var location = window.location;
            sameOrigin =
                urlParts[1] == location.protocol &&
                urlParts[3] == location.hostname;
            var uPort = urlParts[4], lPort = location.port;
            if (uPort != 80 && uPort != "" || lPort != "80" && lPort != "") {
                sameOrigin = sameOrigin && uPort == lPort;
            }
        }
        if (!sameOrigin) {
            if (proxy) {
                if (typeof proxy == "function") {
                    url = proxy(url);
                } else {
                      if(url.indexOf("cts?") >= 0){
                        url = proxy + url;
                    }else{
                        url = proxy + encodeURIComponent(url);
                    }
                }
            }
        }
        return url;
    },

    /**
     * Create a new XMLHttpRequest object, open it, set any headers, bind
     *     a callback to done state, and send any data.  It is recommended that
     *     you use one GET, POST, PUT, DELETE, OPTIONS, or HEAD.
     *     This method is only documented to provide detail on the configuration
     *     options available to all request methods.
     * @memberof GeoGlobe.Request
     * @param {Object} config  - Object containing properties for configuring the
     *     request.  Allowed configuration properties are described below.
     *     This object is modified and should not be reused.
     *
     * Allowed config properties:
     * @param {String} method  - One of GET, POST, PUT, DELETE, HEAD, or OPTIONS.  Default is GET.
     * @param  {String} url  - URL for the request.
     * @param {Boolean} async  - Open an asynchronous request.  Default is true.
     * @param {String}  user  - User for relevant authentication scheme.  Set to null to clear current user.
     * @param {String} password  - Password for relevant authentication scheme.
     *     Set to null to clear current password.
     * @param {String} proxy  - Optional proxy.  Defaults to GeoGlobe.ProxyHost.
     * @param {Object} params -  Any key:value pairs to be appended to the
     *     url as a query string.  Assumes url doesn't already include a query
     *     string or hash.  Typically, this is only appropriate for GET
     *     requests where the query string will be appended to the url.
     *     Parameter values that are arrays will be
     *     concatenated with a comma (note that this goes against form-encoding)
     *     as is done with GeoGlobe.Util.getParameterString.
     * @param {Object} headers - Object with header:value pairs to be set on the request.
     * @param {String | Document} data  - Optional data to send with the request.
     *     Typically, this is only used with POST and PUT requests.
     *     Make sure to provide the appropriate "Content-Type" header for your
     *     data.  For POST and PUT requests, the content type defaults to
     *     "application-xml".  If your data is a different content type, or
     *     if you are using a different HTTP method, set the "Content-Type"
     *     header to match your data type.
     * @param {Function} callback  - Function to call when request is done.
     *     To determine if the request failed, check request.status (200
     *     indicates success).
     * @param {Function} success  -  Optional function to call if request status is in
     *     the 200s.  This will be called in addition to callback above and
     *     would typically only be used as an alternative.
     * @param {Function} failure  - Optional function to call if request status is not
     *     in the 200s.  This will be called in addition to callback above and
     *     would typically only be used as an alternative.
     * @param {Object}  scope  - If callback is a public method on some object,
     *     set the scope to that object.
     *
     * @returns {XMLHttpRequest}  - Request object.  To abort the request before a response
     *     is received, call abort() on the request object.
     */
    issue: function(config) {        
        // apply default config - proxy host may have changed
        var defaultConfig = GeoGlobe.Util.extend(
            this.DEFAULT_CONFIG,
            {proxy: GeoGlobe.ProxyHost}
        );
        config = config || {};
        config.headers = config.headers || {};
        config = GeoGlobe.Util.applyDefaults(config, defaultConfig);
        config.headers = GeoGlobe.Util.applyDefaults(config.headers, defaultConfig.headers);
        // Always set the "X-Requested-With" header to signal that this request
        // was issued through the XHR-object. Since header keys are case 
        // insensitive and we want to allow overriding of the "X-Requested-With"
        // header through the user we cannot use applyDefaults, but have to 
        // check manually whether we were called with a "X-Requested-With"
        // header.
        var customRequestedWithHeader = false,
            headerKey;
        for(headerKey in config.headers) {
            if (config.headers.hasOwnProperty( headerKey )) {
                if (headerKey.toLowerCase() === 'x-requested-with') {
                    customRequestedWithHeader = true;
                }
            }
        }
        if (customRequestedWithHeader === false) {
            // we did not have a custom "X-Requested-With" header
            config.headers['X-Requested-With'] = 'XMLHttpRequest';
        }

        // create request, open, and set headers
        var request = new GeoGlobe.Request.XMLHttpRequest();
		config.url = encodeURI(config.url);//20170911，进行编码一次，解决带中文的url，无法请求的问题。
        var url = GeoGlobe.Util.urlAppend(config.url, 
            GeoGlobe.Util.getParameterString(config.params || {}));
        url = GeoGlobe.Request.makeSameOrigin(url, config.proxy);
        request.open(
            config.method, url, config.async, config.user, config.password
        );
        for(var header in config.headers) {
            request.setRequestHeader(header, config.headers[header]);
        }

        //var events = this.events;

        // we want to execute runCallbacks with "this" as the
        // execution scope
        var self = this;
        
        request.onreadystatechange = function() {
            if(request.readyState == GeoGlobe.Request.XMLHttpRequest.DONE) {
				/*
                var proceed = events.triggerEvent(
                    "complete",
                    {request: request, config: config, requestUrl: url}
                );
                */
				var proceed = null;//TODO by sw.2017.5.8 
                if(proceed !== false) {
                    self.runCallbacks(
                        {request: request, config: config, requestUrl: url}
                    );
                }
            }
        };
        
        // send request (optionally with data) and return
        // call in a timeout for asynchronous requests so the return is
        // available before readyState == 4 for cached docs
        if(config.async === false) {
            request.send(config.data);
        } else {
            window.setTimeout(function(){
                if (request.readyState !== 0) { // W3C: 0-UNSENT
                    request.send(config.data);
                }
            }, 0);
        }
        return request;
    },
    
    /**
     * Calls the complete, success and failure callbacks. Application
     *    can listen to the "complete" event, have the listener 
     *    display a confirm window and always return false, and
     *    execute GeoGlobe.Request.runCallbacks if the user
     *    hits "yes" in the confirm window.
     * @memberof GeoGlobe.Request
     * @param {Object} options  -  Hash containing request, config and requestUrl keys
     */
    runCallbacks: function(options) {
        var request = options.request;
        var config = options.config;
        
        // bind callbacks to readyState 4 (done)
        var complete = (config.scope) ?
            GeoGlobe.Function.bind(config.callback, config.scope) :
            config.callback;
        
        // optional success callback
        var success;
        if(config.success) {
            success = (config.scope) ?
                GeoGlobe.Function.bind(config.success, config.scope) :
                config.success;
        }

        // optional failure callback
        var failure;
        if(config.failure) {
            failure = (config.scope) ?
                GeoGlobe.Function.bind(config.failure, config.scope) :
                config.failure;
        }

        if (GeoGlobe.Util.createUrlObject(config.url).protocol == "file:" &&
                                                        request.responseText) {
            request.status = 200;
        }
        complete(request);

        if (!request.status || (request.status >= 200 && request.status < 300)) {
            //this.events.triggerEvent("success", options);//TODO
            if(success) {
                success(request);
            }
        }
        if(request.status && (request.status < 200 || request.status >= 300)) {                    
            //this.events.triggerEvent("failure", options);//TODO
            if(failure) {
                failure(request);
            }
        }
    },
    
    /**
     * Send an HTTP GET request.  Additional configuration properties are
     *     documented in the issue method, with the method property set
     *     to GET.
     * @memberof GeoGlobe.Request
     * @param {Object} config  -  Object with properties for configuring the request.
     *     See the issue method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * @returns {XMLHttpRequest}  - Request object.
     */
    GET: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "GET"});
        return GeoGlobe.Request.issue(config);
    },
    
    /**
     * Send a POST request.  Additional configuration properties are
     *     documented in the issue method, with the method property set
     *     to POST and "Content-Type" header set to "application/xml".
     * @memberof GeoGlobe.Request
     * @param {Object} config   -  Object with properties for configuring the request.
     *     See the issue method for documentation of allowed properties.  The
     *     default "Content-Type" header will be set to "application-xml" if
     *     none is provided.  This object is modified and should not be reused.
     * 
     * @returns {XMLHttpRequest}  - Request object.
     */
    POST: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "POST"});
        // set content type to application/xml if it isn't already set
        config.headers = config.headers ? config.headers : {};
        if(!("CONTENT-TYPE" in GeoGlobe.Util.upperCaseObject(config.headers))) {
            config.headers["Content-Type"] = "application/xml";
        }
        return GeoGlobe.Request.issue(config);
    },
    
    /**
     * Send an HTTP PUT request.  Additional configuration properties are
     *     documented in the issue method, with the method property set
     *     to PUT and "Content-Type" header set to "application/xml".
     * @memberof GeoGlobe.Request
     * @param {Object} config
     * - Object with properties for configuring the request.
     *     See the issue method for documentation of allowed properties.  The
     *     default "Content-Type" header will be set to "application-xml" if
     *     none is provided.  This object is modified and should not be reused.
     * 
     * @returns {XMLHttpRequest}  - Request object.
     */
    PUT: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "PUT"});
        // set content type to application/xml if it isn't already set
        config.headers = config.headers ? config.headers : {};
        if(!("CONTENT-TYPE" in GeoGlobe.Util.upperCaseObject(config.headers))) {
            config.headers["Content-Type"] = "application/xml";
        }
        return GeoGlobe.Request.issue(config);
    },
    
    /**
     * Send an HTTP DELETE request.  Additional configuration properties are
     *     documented in the issue method, with the method property set
     *     to DELETE.
     * @memberof GeoGlobe.Request
     * @param {Object} config
     *  -  Object with properties for configuring the request.
     *     See the issue method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * @returns {XMLHttpRequest}  - Request object.
     */
    DELETE: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "DELETE"});
        return GeoGlobe.Request.issue(config);
    },
  
    /**
     * Send an HTTP HEAD request.  Additional configuration properties are
     *     documented in the issue method, with the method property set
     *     to HEAD.
     * @memberof GeoGlobe.Request
     * @param {Object} config
     * - Object with properties for configuring the request.
     *     See the issue method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * @returns {XMLHttpRequest}  - Request object.
     */
    HEAD: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "HEAD"});
        return GeoGlobe.Request.issue(config);
    },
    
    /**
     * Send an HTTP OPTIONS request.  Additional configuration properties are
     *     documented in the issue method, with the method property set to OPTIONS.
     * @memberof GeoGlobe.Request
     * @param {Object} config
     *  - Object with properties for configuring the request.
     *     See the issue method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * @returns {XMLHttpRequest}  - Request object.
     */
    OPTIONS: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "OPTIONS"});
        return GeoGlobe.Request.issue(config);
    }

});


/**
 * @memberof GeoGlobe.Request
 * @param {} request
 */
GeoGlobe.nullHandler = function(request) {
    GeoGlobe.Console.userError(GeoGlobe.i18n("unhandledRequest", {'statusText':request.statusText}));
};

/**
 * Background load a document.
 * *Deprecated*.  Use GeoGlobe.Request.GET method instead.
 * @memberof GeoGlobe.Request
 * @param {String} uri  - URI of source doc
 * @param {String} or {Object}  params   -  GET params. Either a string in the form
 *     "?hello=world&foo=bar" (do not forget the leading question mark)
 *     or an object in the form {'hello': 'world', 'foo': 'bar}
 * @param {Object} caller  - object which gets callbacks
 * @param {Function} onComplete  - Optional callback for success.  The callback
 *     will be called with this set to caller and will receive the request
 *     object as an argument.  Note that if you do not specify an onComplete
 *     function, GeoGlobe.nullHandler will be called (which pops up a
 *     user friendly error message dialog).
 * @param {Function} onFailure   -  Optional callback for failure.  In the event of
 *     a failure, the callback will be called with this set to caller and will
 *     receive the request object as an argument.  Note that if you do not
 *     specify an onComplete function, GeoGlobe.nullHandler will be called
 *     (which pops up a user friendly error message dialog).
 *
 * @returns {GeoGlobe.Request.XMLHttpRequest}  - The request object. To abort loading,
 *     call request.abort().
 */
GeoGlobe.loadURL = function(uri, params, caller,
                                  onComplete, onFailure) {
    
    if(typeof params == 'string') {
        params = GeoGlobe.Util.getParameters(params);
    }
    var success = (onComplete) ? onComplete : GeoGlobe.nullHandler;
    var failure = (onFailure) ? onFailure : GeoGlobe.nullHandler;
    
    return GeoGlobe.Request.GET({
        url: uri, params: params,
        success: success, failure: failure, scope: caller
    });
};

/**
 * 设置代理地址,根据自己的代理器地址来配置
 * @memberof GeoGlobe.Request
 * @param {String} proxyHost  - 代理地址
 */
GeoGlobe.Request.setProxyHost = function(proxyHost){
	GeoGlobe.ProxyHost = proxyHost;
};

/**
 * 代理地址
 * @memberof GeoGlobe.Request
 * @returns  {String}  - 代理地址
 */
GeoGlobe.Request.getProxyHost = function(){
	return GeoGlobe.ProxyHost;
};

/**
 * 处理带中文的url
 * @memberof GeoGlobe.Request
 * @returns {String}  - 带代理地址的url
 */
GeoGlobe.appendToProxy = function(url){
	var arr = url.split("?");
	var u1 = GeoGlobe.ProxyHost + encodeURI(encodeURI(arr[0]));
	if(arr.length === 2){
		u1 += "?" + arr[1];
	}
	return u1;
};

/**
 * 加载javascript文件
 * @memberof GeoGlobe.Request
 * @param {String} url  - js文件路径。
 */
GeoGlobe.loadScript = function(url){
	GeoGlobe.Request.GET({
		url: url,
		async: false,
		headers: {
			"Accept": "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01"
		},
		//callback: callback,
		success: function(e){
			GeoGlobe.Util.globalEval(e.responseText);
			//if(typeof(callback) === "function"){
			//	callback(e);
			//}
		},
		failure: function(e){
			alert("加载:"+url+" 失败。");
		}
	});
};

// XMLHttpRequest.js Copyright (C) 2010 Sergey Ilinsky (http://www.ilinsky.com)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

    
/**
 * @private
 */
(function () {


    // Save reference to earlier defined object implementation (if any)
    var oXMLHttpRequest    = window.XMLHttpRequest;

    // Define on browser type
    var bGecko    = !!window.controllers,
        bIE        = window.document.all && !window.opera,
        bIE7    = bIE && window.navigator.userAgent.match(/MSIE 7.0/);

    // Enables "XMLHttpRequest()" call next to "new XMLHttpReques()"
    function fXMLHttpRequest() {
        this._object    = oXMLHttpRequest && !bIE7 ? new oXMLHttpRequest : new window.ActiveXObject("Microsoft.XMLHTTP");
        this._listeners    = [];
    };

    // Constructor
    function cXMLHttpRequest() {
        return new fXMLHttpRequest;
    };
    cXMLHttpRequest.prototype    = fXMLHttpRequest.prototype;

    // BUGFIX: Firefox with Firebug installed would break pages if not executed
    if (bGecko && oXMLHttpRequest.wrapped)
        cXMLHttpRequest.wrapped    = oXMLHttpRequest.wrapped;

    // Constants
    cXMLHttpRequest.UNSENT                = 0;
    cXMLHttpRequest.OPENED                = 1;
    cXMLHttpRequest.HEADERS_RECEIVED    = 2;
    cXMLHttpRequest.LOADING                = 3;
    cXMLHttpRequest.DONE                = 4;

    // Public Properties
    cXMLHttpRequest.prototype.readyState    = cXMLHttpRequest.UNSENT;
    cXMLHttpRequest.prototype.responseText    = '';
    cXMLHttpRequest.prototype.responseXML    = null;
    cXMLHttpRequest.prototype.status        = 0;
    cXMLHttpRequest.prototype.statusText    = '';

    // Priority proposal
    cXMLHttpRequest.prototype.priority        = "NORMAL";

    // Instance-level Events Handlers
    cXMLHttpRequest.prototype.onreadystatechange    = null;

    // Class-level Events Handlers
    cXMLHttpRequest.onreadystatechange    = null;
    cXMLHttpRequest.onopen                = null;
    cXMLHttpRequest.onsend                = null;
    cXMLHttpRequest.onabort                = null;

    // Public Methods
    cXMLHttpRequest.prototype.open    = function(sMethod, sUrl, bAsync, sUser, sPassword) {
        // Delete headers, required when object is reused
        delete this._headers;

        // When bAsync parameter value is omitted, use true as default
        if (arguments.length < 3)
            bAsync    = true;

        // Save async parameter for fixing Gecko bug with missing readystatechange in synchronous requests
        this._async        = bAsync;

        // Set the onreadystatechange handler
        var oRequest    = this,
            nState        = this.readyState,
            fOnUnload;

        // BUGFIX: IE - memory leak on page unload (inter-page leak)
        if (bIE && bAsync) {
            fOnUnload = function() {
                if (nState != cXMLHttpRequest.DONE) {
                    fCleanTransport(oRequest);
                    // Safe to abort here since onreadystatechange handler removed
                    oRequest.abort();
                }
            };
            window.attachEvent("onunload", fOnUnload);
        }

        // Add method sniffer
        if (cXMLHttpRequest.onopen)
            cXMLHttpRequest.onopen.apply(this, arguments);

        if (arguments.length > 4)
            this._object.open(sMethod, sUrl, bAsync, sUser, sPassword);
        else
        if (arguments.length > 3)
            this._object.open(sMethod, sUrl, bAsync, sUser);
        else
            this._object.open(sMethod, sUrl, bAsync);

        /*
         * 解决在IE10下请求后返回的XML数据不是文档类型，从而无法使用selectNodes方法的问题。
         * 在此设置响应返回的数据类型为"msxml-document"，就可以得到XML document，也能使用selectNodes方法了。
         */
		try {
			this._object.responseType = "msxml-document";
		}catch(e){
			
		}
		this.readyState    = cXMLHttpRequest.OPENED;
        fReadyStateChange(this);

        this._object.onreadystatechange    = function() {
            if (bGecko && !bAsync)
                return;

            // Synchronize state
            oRequest.readyState        = oRequest._object.readyState;

            //
            fSynchronizeValues(oRequest);

            // BUGFIX: Firefox fires unnecessary DONE when aborting
            if (oRequest._aborted) {
                // Reset readyState to UNSENT
                oRequest.readyState    = cXMLHttpRequest.UNSENT;

                // Return now
                return;
            }

            if (oRequest.readyState == cXMLHttpRequest.DONE) {
                // Free up queue
                delete oRequest._data;
/*                if (bAsync)
                    fQueue_remove(oRequest);*/
                //
                fCleanTransport(oRequest);
// Uncomment this block if you need a fix for IE cache
/*
                // BUGFIX: IE - cache issue
                if (!oRequest._object.getResponseHeader("Date")) {
                    // Save object to cache
                    oRequest._cached    = oRequest._object;

                    // Instantiate a new transport object
                    cXMLHttpRequest.call(oRequest);

                    // Re-send request
                    if (sUser) {
                         if (sPassword)
                            oRequest._object.open(sMethod, sUrl, bAsync, sUser, sPassword);
                        else
                            oRequest._object.open(sMethod, sUrl, bAsync, sUser);
                    }
                    else
                        oRequest._object.open(sMethod, sUrl, bAsync);
                    oRequest._object.setRequestHeader("If-Modified-Since", oRequest._cached.getResponseHeader("Last-Modified") || new window.Date(0));
                    // Copy headers set
                    if (oRequest._headers)
                        for (var sHeader in oRequest._headers)
                            if (typeof oRequest._headers[sHeader] == "string")    // Some frameworks prototype objects with functions
                                oRequest._object.setRequestHeader(sHeader, oRequest._headers[sHeader]);

                    oRequest._object.onreadystatechange    = function() {
                        // Synchronize state
                        oRequest.readyState        = oRequest._object.readyState;

                        if (oRequest._aborted) {
                            //
                            oRequest.readyState    = cXMLHttpRequest.UNSENT;

                            // Return
                            return;
                        }

                        if (oRequest.readyState == cXMLHttpRequest.DONE) {
                            // Clean Object
                            fCleanTransport(oRequest);

                            // get cached request
                            if (oRequest.status == 304)
                                oRequest._object    = oRequest._cached;

                            //
                            delete oRequest._cached;

                            //
                            fSynchronizeValues(oRequest);

                            //
                            fReadyStateChange(oRequest);

                            // BUGFIX: IE - memory leak in interrupted
                            if (bIE && bAsync)
                                window.detachEvent("onunload", fOnUnload);
                        }
                    };
                    oRequest._object.send(null);

                    // Return now - wait until re-sent request is finished
                    return;
                };
*/
                // BUGFIX: IE - memory leak in interrupted
                if (bIE && bAsync)
                     window.detachEvent("onunload", fOnUnload);
            }

            // BUGFIX: Some browsers (Internet Explorer, Gecko) fire OPEN readystate twice
            if (nState != oRequest.readyState)
                fReadyStateChange(oRequest);

            nState    = oRequest.readyState;
        }
    };
    function fXMLHttpRequest_send(oRequest) {
        oRequest._object.send(oRequest._data);

        // BUGFIX: Gecko - missing readystatechange calls in synchronous requests
        if (bGecko && !oRequest._async) {
            oRequest.readyState    = cXMLHttpRequest.OPENED;

            // Synchronize state
            fSynchronizeValues(oRequest);

            // Simulate missing states
            while (oRequest.readyState < cXMLHttpRequest.DONE) {
                oRequest.readyState++;
                fReadyStateChange(oRequest);
                // Check if we are aborted
                if (oRequest._aborted)
                    return;
            }
        }
    };
    cXMLHttpRequest.prototype.send    = function(vData) {
        // Add method sniffer
        if (cXMLHttpRequest.onsend)
            cXMLHttpRequest.onsend.apply(this, arguments);

        if (!arguments.length)
            vData    = null;

        // BUGFIX: Safari - fails sending documents created/modified dynamically, so an explicit serialization required
        // BUGFIX: IE - rewrites any custom mime-type to "text/xml" in case an XMLNode is sent
        // BUGFIX: Gecko - fails sending Element (this is up to the implementation either to standard)
        if (vData && vData.nodeType) {
            vData    = window.XMLSerializer ? new window.XMLSerializer().serializeToString(vData) : vData.xml;
            if (!this._headers["Content-Type"])
                this._object.setRequestHeader("Content-Type", "application/xml");
        }

        this._data    = vData;
/*
        // Add to queue
        if (this._async)
            fQueue_add(this);
        else*/
            fXMLHttpRequest_send(this);
    };
    cXMLHttpRequest.prototype.abort    = function() {
        // Add method sniffer
        if (cXMLHttpRequest.onabort)
            cXMLHttpRequest.onabort.apply(this, arguments);

        // BUGFIX: Gecko - unnecessary DONE when aborting
        if (this.readyState > cXMLHttpRequest.UNSENT)
            this._aborted    = true;

        this._object.abort();

        // BUGFIX: IE - memory leak
        fCleanTransport(this);

        this.readyState    = cXMLHttpRequest.UNSENT;

        delete this._data;
/*        if (this._async)
            fQueue_remove(this);*/
    };
    cXMLHttpRequest.prototype.getAllResponseHeaders    = function() {
        return this._object.getAllResponseHeaders();
    };
    cXMLHttpRequest.prototype.getResponseHeader    = function(sName) {
        return this._object.getResponseHeader(sName);
    };
    cXMLHttpRequest.prototype.setRequestHeader    = function(sName, sValue) {
        // BUGFIX: IE - cache issue
        if (!this._headers)
            this._headers    = {};
        this._headers[sName]    = sValue;

        return this._object.setRequestHeader(sName, sValue);
    };

    // EventTarget interface implementation
    cXMLHttpRequest.prototype.addEventListener    = function(sName, fHandler, bUseCapture) {
        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
            if (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture)
                return;
        // Add listener
        this._listeners.push([sName, fHandler, bUseCapture]);
    };

    cXMLHttpRequest.prototype.removeEventListener    = function(sName, fHandler, bUseCapture) {
        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
            if (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture)
                break;
        // Remove listener
        if (oListener)
            this._listeners.splice(nIndex, 1);
    };

    cXMLHttpRequest.prototype.dispatchEvent    = function(oEvent) {
        var oEventPseudo    = {
            'type':            oEvent.type,
            'target':        this,
            'currentTarget':this,
            'eventPhase':    2,
            'bubbles':        oEvent.bubbles,
            'cancelable':    oEvent.cancelable,
            'timeStamp':    oEvent.timeStamp,
            'stopPropagation':    function() {},    // There is no flow
            'preventDefault':    function() {},    // There is no default action
            'initEvent':        function() {}    // Original event object should be initialized
        };

        // Execute onreadystatechange
        if (oEventPseudo.type == "readystatechange" && this.onreadystatechange)
            (this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [oEventPseudo]);

        // Execute listeners
        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
            if (oListener[0] == oEventPseudo.type && !oListener[2])
                (oListener[1].handleEvent || oListener[1]).apply(this, [oEventPseudo]);
    };

    //
    cXMLHttpRequest.prototype.toString    = function() {
        return '[' + "object" + ' ' + "XMLHttpRequest" + ']';
    };

    cXMLHttpRequest.toString    = function() {
        return '[' + "XMLHttpRequest" + ']';
    };

    // Helper function
    function fReadyStateChange(oRequest) {
        // Sniffing code
        if (cXMLHttpRequest.onreadystatechange)
            cXMLHttpRequest.onreadystatechange.apply(oRequest);

        // Fake event
        oRequest.dispatchEvent({
            'type':            "readystatechange",
            'bubbles':        false,
            'cancelable':    false,
            'timeStamp':    new Date + 0
        });
    };

    function fGetDocument(oRequest) {
        var oDocument    = oRequest.responseXML,
            sResponse    = oRequest.responseText;
        // Try parsing responseText
        if (bIE && sResponse && oDocument && !oDocument.documentElement && oRequest.getResponseHeader("Content-Type").match(/[^\/]+\/[^\+]+\+xml/)) {
            oDocument    = new window.ActiveXObject("Microsoft.XMLDOM");
            oDocument.async                = false;
            oDocument.validateOnParse    = false;
            oDocument.loadXML(sResponse);
        }
        // Check if there is no error in document
        if (oDocument)
            if ((bIE && oDocument.parseError != 0) || !oDocument.documentElement || (oDocument.documentElement && oDocument.documentElement.tagName == "parsererror"))
                return null;
        return oDocument;
    };

    function fSynchronizeValues(oRequest) {
        try {    oRequest.responseText    = oRequest._object.responseText;    } catch (e) {}
        try {    oRequest.responseXML    = fGetDocument(oRequest._object);    } catch (e) {}
        try {    oRequest.status            = oRequest._object.status;            } catch (e) {}
        try {    oRequest.statusText        = oRequest._object.statusText;        } catch (e) {}
    };

    function fCleanTransport(oRequest) {
        // BUGFIX: IE - memory leak (on-page leak)
        oRequest._object.onreadystatechange    = new window.Function;
    };
/*
    // Queue manager
    var oQueuePending    = {"CRITICAL":[],"HIGH":[],"NORMAL":[],"LOW":[],"LOWEST":[]},
        aQueueRunning    = [];
    function fQueue_add(oRequest) {
        oQueuePending[oRequest.priority in oQueuePending ? oRequest.priority : "NORMAL"].push(oRequest);
        //
        setTimeout(fQueue_process);
    };

    function fQueue_remove(oRequest) {
        for (var nIndex = 0, bFound    = false; nIndex < aQueueRunning.length; nIndex++)
            if (bFound)
                aQueueRunning[nIndex - 1]    = aQueueRunning[nIndex];
            else
            if (aQueueRunning[nIndex] == oRequest)
                bFound    = true;
        if (bFound)
            aQueueRunning.length--;
        //
        setTimeout(fQueue_process);
    };

    function fQueue_process() {
        if (aQueueRunning.length < 6) {
            for (var sPriority in oQueuePending) {
                if (oQueuePending[sPriority].length) {
                    var oRequest    = oQueuePending[sPriority][0];
                    oQueuePending[sPriority]    = oQueuePending[sPriority].slice(1);
                    //
                    aQueueRunning.push(oRequest);
                    // Send request
                    fXMLHttpRequest_send(oRequest);
                    break;
                }
            }
        }
    };
*/
    // Internet Explorer 5.0 (missing apply)
    if (!window.Function.prototype.apply) {
        window.Function.prototype.apply    = function(oRequest, oArguments) {
            if (!oArguments)
                oArguments    = [];
            oRequest.__func    = this;
            oRequest.__func(oArguments[0], oArguments[1], oArguments[2], oArguments[3], oArguments[4]);
            delete oRequest.__func;
        };
    };

    // Register new object with window

    /**
     * @class GeoGlobe.Request.XMLHttpRequest
     * @classdesc Standard-compliant (W3C) cross-browser implementation of the
     *     XMLHttpRequest object.  From
     *     http://code.google.com/p/xmlhttprequest/.。
     *
     */
    if (!GeoGlobe.Request) {
        /**
         * This allows for tool/Request/Request.js to be included
         * before or after this script.
         */
        GeoGlobe.Request = {};
    }
    GeoGlobe.Request.XMLHttpRequest = cXMLHttpRequest;
})();

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */
/**
 * Internationalization namespace.  Contains dictionaries in various languages
 *     and methods to set and get the current language.
 * @namespace  GeoGlobe.Lang
 * @private
 */
GeoGlobe.Lang = {
    
    /**
     *  Current language code to use in GeoGlobe.  Use the
     *     setCode method to set this value and the getCode method to
     *     retrieve it.
     * @memberof GeoGlobe.Lang
     * @type {String}
     *
     */
    code: null,

    /**
     *  Default language to use when a specific language can't be found.  Default is "zh-CN".
     * @memberof GeoGlobe.Lang
     * @type {String}
     */
    defaultCode: "zh-CN",//en
        
    /**
     * Get the current language code.getCode
     * @memberof GeoGlobe.Lang
     * @returns {String}  - The current language code.
     */
    getCode: function() {
        if(!GeoGlobe.Lang.code) {
            GeoGlobe.Lang.setCode();
        }
        return GeoGlobe.Lang.code;
    },

    /**
     * Set the language code for string translation.  This code is used by
     *     the GeoGlobe.Lang.translate method.
     * @memberof GeoGlobe.Lang
     * @param {String} code  - These codes follow the IETF recommendations at
     *     http://www.ietf.org/rfc/rfc3066.txt.  If no value is set, the
     *     browser's language setting will be tested.  If no GeoGlobe.Lang
     *     dictionary exists for the code, the GeoGlobe.String.defaultLang
     *     will be used.
     */
    setCode: function(code) {
        var lang;
        if(!code) {
            code = (GeoGlobe.BROWSER_NAME == "msie") ?
                navigator.userLanguage : navigator.language;
        }
        var parts = code.split('-');
        parts[0] = parts[0].toLowerCase();
        if(typeof GeoGlobe.Lang[parts[0]] == "object") {
            lang = parts[0];
        }

        // check for regional extensions
        if(parts[1]) {
            var testLang = parts[0] + '-' + parts[1].toUpperCase();
            if(typeof GeoGlobe.Lang[testLang] == "object") {
                lang = testLang;
            }
        }
        if(!lang) {
            GeoGlobe.Console.warn(
                'Failed to find GeoGlobe.Lang.' + parts.join("-") +
                ' dictionary, falling back to default language'
            );
            lang = GeoGlobe.Lang.defaultCode;
        }
        
        GeoGlobe.Lang.code = lang;
    },

    /**
     * Looks up a key from a dictionary based on the current language string.
     *     The value of getCode will be used to determine the appropriate
     *     dictionary.  Dictionaries are stored in GeoGlobe.Lang.
     * @memberof GeoGlobe.Lang
     * @param {String} key  - The key for an i18n string value in the dictionary.
     * @param {Object} context  - Optional context to be used with
     *     GeoGlobe.String.format.
     * 
     * @returns {String}  -  A internationalized string.
     */
    translate: function(key, context) {
        var dictionary = GeoGlobe.Lang[GeoGlobe.Lang.getCode()];
        var message = dictionary && dictionary[key];
        if(!message) {
            // Message not found, fall back to message key
            message = key;
        }
        if(context) {
            message = GeoGlobe.String.format(message, context);
        }
        return message;
    }
    
};


/**
 * Alias for GeoGlobe.Lang.translate.  Looks up a key from a dictionary
 *     based on the current language string. The value of
 *     GeoGlobe.Lang.getCode>will be used to determine the appropriate
 *     dictionary.  Dictionaries are stored in GeoGlobe.Lang.
 * @memberof GeoGlobe.Lang
 * @param {String} key - The key for an i18n string value in the dictionary.
 * @param {Object} ontext - Optional context to be used with GeoGlobe.String.format.
 * 
 * @returns  {String}  - A internationalized string.
 */
GeoGlobe.i18n = GeoGlobe.Lang.translate;

/**
 *
 * Dictionary for English.  Keys for entries are used in calls to
 *     GeoGlobe.Lang.translate.  Entry bodies are normal strings or
 *     strings formatted for use with GeoGlobe.String.format calls.
 * @namespace  GeoGlobe.Lang["en"]
 * @private
 */
GeoGlobe.Lang.en = {

    'unhandledRequest': "Unhandled request return ${statusText}",

    'end': ''
    
};

/**
 *
 * Dictionary for Simplified Chinese.  Keys for entries are used in calls to
 *     GeoGlobe.Lang.translate.  Entry bodies are normal strings or
 *     strings formatted for use with GeoGlobe.String.format calls.
 *  @namespace   GeoGlobe.Lang["zh-CN"]
 *  @private
 */
GeoGlobe.Lang["zh-CN"] = {

    'unhandledRequest': "未处理的请求，返回值为 ${statusText}",

    'end': ''
};

/**
 *  Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license.
 * */


/**
 * 包含对字符串方便操作的方法
 * @namespace GeoGlobe.String
 * @private
 *
 */
GeoGlobe.String = {

    /**
     * Test whether a string starts with another string.
     * @memberof GeoGlobe.BaseTypes.prototype
     * @param {String} str -  The string to test.
     * @param {String} sub -  The substring to look for.
     * @returns {Boolean} The first string starts with the second.
     */
    startsWith: function(str, sub) {
        return (str.indexOf(sub) == 0);
    },

    /**

     * Test whether a string contains another string.
     * @memberof GeoGlobe.BaseTypes.prototype
     * @param {String}  str - The string to test.
     *  @param {String}sub - The substring to look for.
     * 
     * @returns
     * {Boolean} The first string contains the second.
     */
    contains: function(str, sub) {
        return (str.indexOf(sub) != -1);
    },
    
    /**

     * Removes leading and trailing whitespace characters from a string.
     * @memberof GeoGlobe.BaseTypes.prototype

     * @param {String}str -  The (potentially) space padded string.  This string is not
     *     modified.
     * 
     * @returns {String} A trimmed version of the string with all leading and
     *     trailing spaces removed.
     */
    trim: function(str) {
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    },
    
    /**

     * Camel-case a hyphenated string. 
     *     Ex. "chicken-head" becomes "chickenHead", and
     *     "-chicken-head" becomes "ChickenHead".
     *     @memberof GeoGlobe.BaseTypes.prototype


     * @param {String}str - The string to be camelized.  The original is not modified.
     * 
     * @returns {String} The string, camelized
     */
    camelize: function(str) {
        var oStringList = str.split('-');
        var camelizedString = oStringList[0];
        for (var i=1, len=oStringList.length; i<len; i++) {
            var s = oStringList[i];
            camelizedString += s.charAt(0).toUpperCase() + s.substring(1);
        }
        return camelizedString;
    },
    
    /**

     * Given a string with tokens in the form ${token}, return a string
     *     with tokens replaced with properties from the given context
     *     object.  Represent a literal "${" by doubling it, e.g. "${${".
     *     @memberof GeoGlobe.BaseTypes.prototype

     * @param {String} template -  A string with tokens to be replaced.  A template
     *     has the form "literal ${token}" where the token will be replaced
     *     by the value of context["token"].
     * @param {Object}context -  An optional object with properties corresponding
     *     to the tokens in the format string.  If no context is sent, the
     *     window object will be used.
     *  @param {Array}args -  Optional arguments to pass to any functions found in
     *     the context.  If a context property is a function, the token
     *     will be replaced by the return from the function called with
     *     these arguments.
     *
     * @returns {String} A string with tokens replaced from the context object.
     */
    format: function(template, context, args) {
        if(!context) {
            context = window;
        }

        // Example matching: 
        // str   = ${foo.bar}
        // match = foo.bar
        var replacer = function(str, match) {
            var replacement;

            // Loop through all subs. Example: ${a.b.c}
            // 0 -> replacement = context[a];
            // 1 -> replacement = context[a][b];
            // 2 -> replacement = context[a][b][c];
            var subs = match.split(/\.+/);
            for (var i=0; i< subs.length; i++) {
                if (i == 0) {
                    replacement = context;
                }
                if (replacement === undefined) {
                    break;
                }
                replacement = replacement[subs[i]];
            }

            if(typeof replacement == "function") {
                replacement = args ?
                    replacement.apply(null, args) :
                    replacement();
            }

            // If replacement is undefined, return the string 'undefined'.
            // This is a workaround for a bugs in browsers not properly 
            // dealing with non-participating groups in regular expressions:
            // http://blog.stevenlevithan.com/archives/npcg-javascript
            if (typeof replacement == 'undefined') {
                return 'undefined';
            } else {
                return replacement; 
            }
        };

        return template.replace(GeoGlobe.String.tokenRegEx, replacer);
    },

    /**

     * Used to find tokens in a string.
     *  @memberof GeoGlobe.BaseTypes.prototype
     *  @param tokenRegEx
     * @example ${a}, ${a.b.c}, ${a-b}, ${5}
     */
    tokenRegEx:  /\$\{([\w.]+?)\}/g,
    
    /**
     *
     * Used to test strings as numbers
     * @memberof GeoGlobe.BaseTypes.prototype
     * @param numberRegEx
     */
    numberRegEx: /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/,
    
    /**
     *  Determine whether a string contains only a numeric value.
     *  @memberof GeoGlobe.BaseTypes.prototype


     *
     * @example
     * (code)
     * GeoGlobe.String.isNumeric("6.02e23") // true
     * GeoGlobe.String.isNumeric("12 dozen") // false
     * GeoGlobe.String.isNumeric("4") // true
     * GeoGlobe.String.isNumeric(" 4 ") // false
     * (end)
     *
     * @returns
     * {Boolean} String contains only a number.
     */
    isNumeric: function(value) {
        return GeoGlobe.String.numberRegEx.test(value);
    },
    
    /**

     * Converts a string that appears to be a numeric value into a number.
     * @memberof GeoGlobe.BaseTypes.prototype


     * @param {String}value
     * @param {Boolean} trimWhitespace
     *
     * @returns
     * {Number|String} a Number if the passed value is a number, a String
     *     otherwise. 
     */
    numericIf: function(value, trimWhitespace) {
        var originalValue = value;
        if (trimWhitespace === true && value != null && value.replace) {
            value = value.replace(/^\s*|\s*$/g, "");
        }
        return GeoGlobe.String.isNumeric(value) ? parseFloat(value) : originalValue;
    }

};

/**
 * @namespace GeoGlobe.Number
 * @private
 */
GeoGlobe.Number = {

    /**

     * Decimal separator to use when formatting numbers.
     * @memberof GeoGlobe.BaseTypes.prototype
     * @param decimalSeparator
     */
    decimalSeparator: ".",
    
    /**
     *

     * Thousands separator to use when formatting numbers.
     * @memberof GeoGlobe.BaseTypes.prototype
     *  @param thousandsSeparator
     */
    thousandsSeparator: ",",
    
    /**
     *
     * Limit the number of significant digits on a float.
     * @memberof GeoGlobe.BaseTypes.prototype

     * @param {Float}num
     * @param {Integer} sig
     *
     * @returns
     * {Float} The number, rounded to the specified number of significant
     *     digits.
     */
    limitSigDigs: function(num, sig) {
        var fig = 0;
        if (sig > 0) {
            fig = parseFloat(num.toPrecision(sig));
        }
        return fig;
    },
    
    /**

     * Formats a number for output.
     * @memberof GeoGlobe.BaseTypes.prototype
     * @param {Float}num
     *  @param {Integer} dec  - {Integer} Number of decimal places to round to.
     *        Defaults to 0. Set to null to leave decimal places unchanged.
     * @param {String}tsep -Thousands separator.
     *        Default is ",".
     * @param {String} dsep -  Decimal separator.
     *        Default is ".".
     *
     * @returns
     * {String} A string representing the formatted number.
     */
    format: function(num, dec, tsep, dsep) {
        dec = (typeof dec != "undefined") ? dec : 0; 
        tsep = (typeof tsep != "undefined") ? tsep :
            GeoGlobe.Number.thousandsSeparator; 
        dsep = (typeof dsep != "undefined") ? dsep :
            GeoGlobe.Number.decimalSeparator;

        if (dec != null) {
            num = parseFloat(num.toFixed(dec));
        }

        var parts = num.toString().split(".");
        if (parts.length == 1 && dec == null) {
            // integer where we do not want to touch the decimals
            dec = 0;
        }
        
        var integer = parts[0];
        if (tsep) {
            var thousands = /(-?[0-9]+)([0-9]{3})/; 
            while(thousands.test(integer)) { 
                integer = integer.replace(thousands, "$1" + tsep + "$2"); 
            }
        }
        
        var str;
        if (dec == 0) {
            str = integer;
        } else {
            var rem = parts.length > 1 ? parts[1] : "0";
            if (dec != null) {
                rem = rem + new Array(dec - rem.length + 1).join("0");
            }
            str = integer + dsep + rem;
        }
        return str;
    },

    /**

     * Create a zero padded string optionally with a radix for casting numbers.
     * @memberof GeoGlobe.BaseTypes.prototype

     * @param {Number}num -  The number to be zero padded.
     * @param {Number} len - The length of the string to be returned.
     * @param {Number} radix -  An integer between 2 and 36 specifying the base to use
     *     for representing numeric values.
     */
    zeroPad: function(num, len, radix) {
        var str = num.toString(radix || 10);
        while (str.length < len) {
            str = "0" + str;
        }
        return str;
    }    
};

/**

 * Contains convenience functions for function manipulation.
 * @namespace GeoGlobe.Function
 * @private
 */
GeoGlobe.Function = {
    /**

     * Bind a function to an object.  Method to easily create closures with
     *     'this' altered.
     *  @memberof GeoGlobe.BaseTypes.prototype
     * @param {Function}func - Input function.
     *  @param {Object}object -  The object to bind to the input function (as this).
     * 
     * @returns
     * {Function} A closure with 'this' set to the passed in object.
     */
    bind: function(func, object) {
        // create a reference to all arguments past the second one
        var args = Array.prototype.slice.apply(arguments, [2]);
        return function() {
            // Push on any additional arguments from the actual function call.
            // These will come after those sent to the bind call.
            var newArgs = args.concat(
                Array.prototype.slice.apply(arguments, [0])
            );
            return func.apply(object, newArgs);
        };
    },
    
    /**

     * Bind a function to an object, and configure it to receive the event
     *     object as first parameter when called.
     *     @memberof GeoGlobe.BaseTypes.prototype

     * @param {Function}func -  Input function to serve as an event listener.
     * @param {Object}object -  A reference to this.
     * 
     * @returns
     * {Function}
     */
    bindAsEventListener: function(func, object) {
        return function(event) {
            return func.call(object, event || window.event);
        };
    },
    
    /**

     * A simple function to that just does "return false". We use this to 
     * avoid attaching anonymous functions to DOM event handlers, which 
     * causes "issues" on IE<8.
     * @memberof GeoGlobe.BaseTypes.prototype
     * 
     * @returns
     * {Boolean}
     */
    False : function() {
        return false;
    },

    /**

     * A simple function to that just does "return true". We use this to 
     * avoid attaching anonymous functions to DOM event handlers, which 
     * causes "issues" on IE<8.
     *  @memberof GeoGlobe.BaseTypes.prototype
     * 
     * @returns
     * {Boolean}
     */
    True : function() {
        return true;
    },
    /**

     * A reusable function that returns ``undefined``.
     * @memberof GeoGlobe.BaseTypes.prototype
     * @returns
     * {undefined}
     */
    Void: function() {}

};

/**

 * Contains convenience functions for array manipulation.
 * @namespace GeoGlobe.Array
 * @private
 */
GeoGlobe.Array = {

    /**

     * Filter an array.  Provides the functionality of the
     *     Array.prototype.filter extension to the ECMA-262 standard.  Where
     *     available, Array.prototype.filter will be used.
     *
     * Based on well known example from http://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter
     * @memberof GeoGlobe.BaseTypes.prototype


     * @param {Array}array -  The array to be filtered.  This array is not mutated.
     *     Elements added to this array by the callback will not be visited.
     *  @param {Function}callback - A function that is called for each element in
     *     the array.  If this function returns true, the element will be
     *     included in the return.  The function will be called with three
     *     arguments: the element in the array, the index of that element, and
     *     the array itself.  If the optional caller parameter is specified
     *     the callback will be called with this set to caller.
     * @param {Object}caller - Optional object to be set as this when the callback
     *     is called.
     *
     * @returns
     * {Array} An array of elements from the passed in array for which the
     *     callback returns true.
     */
    filter: function(array, callback, caller) {
        var selected = [];
        if (Array.prototype.filter) {
            selected = array.filter(callback, caller);
        } else {
            var len = array.length;
            if (typeof callback != "function") {
                throw new TypeError();
            }
            for(var i=0; i<len; i++) {
                if (i in array) {
                    var val = array[i];
                    if (callback.call(caller, val, i, array)) {
                        selected.push(val);
                    }
                }
            }        
        }
        return selected;
    }
    
};


/**

 * 处理浏览器兼容性问题的扩展函数endsWith
 *  @memberof GeoGlobe.BaseTypes.prototype
 * @param {Object} searchString
 * @param {Object} position
 * 
 * @example
 * 
 * var str = 'To be, or not to be, that is the question.';
 * 
 * console.log(str.endsWith('question.')); // true
 * console.log(str.endsWith('to be'));     // false
 * console.log(str.endsWith('to be', 19)); // true
 */
if (!String.prototype.endsWith) {
    String.prototype.endsWith = function(searchString, position){
        var subjectString = this.toString();
        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.lastIndexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    };
}
/**
 *  Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**

 * Contains implementations of Date.parse and date.toISOString that match the
 *     ECMAScript 5 specification for parsing RFC 3339 dates.
 *     http://tools.ietf.org/html/rfc3339
 *      @namespace GeoGlobe.Date
 * @private
 */
GeoGlobe.Date = {

    /** 

     * The regex to be used for validating dates. You can provide your own
     * regex for instance for adding support for years before BC. Default
     * value is: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/
     * @memberof GeoGlobe.Date.prototype
     *  @param dateRegEx
     *
     */
    dateRegEx: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/,

    /**

     * Generates a string representing a date.  The format of the string follows
     *     the profile of ISO 8601 for date and time on the Internet (see
     *     http://tools.ietf.org/html/rfc3339).  If the toISOString method is
     *     available on the Date prototype, that is used.  The toISOString
     *     method for Date instances is defined in ECMA-262.
     *     @memberof GeoGlobe.Date.prototype

     *

     * @param  {Date} date -A date object.
     *
     * @returns
     * {String} A string representing the date (e.g.
     *     "2010-08-07T16:58:23.123Z").  If the date does not have a valid time
     *     (i.e. isNaN(date.getTime())) this method returns the string "Invalid
     *     Date".  The ECMA standard says the toISOString method should throw
     *     RangeError in this case, but Firefox returns a string instead.  For
     *     best results, use isNaN(date.getTime()) to determine date validity
     *     before generating date strings.
     */
    toISOString: (function() {
        if ("toISOString" in Date.prototype) {
            return function(date) {
                return date.toISOString();
            };
        } else {
            return function(date) {
                var str;
                if (isNaN(date.getTime())) {
                    // ECMA-262 says throw RangeError, Firefox returns
                    // "Invalid Date"
                    str = "Invalid Date";
                } else {
                    str =
                        date.getUTCFullYear() + "-" +
                        GeoGlobe.Number.zeroPad(date.getUTCMonth() + 1, 2) + "-" +
                        GeoGlobe.Number.zeroPad(date.getUTCDate(), 2) + "T" +
                        GeoGlobe.Number.zeroPad(date.getUTCHours(), 2) + ":" +
                        GeoGlobe.Number.zeroPad(date.getUTCMinutes(), 2) + ":" +
                        GeoGlobe.Number.zeroPad(date.getUTCSeconds(), 2) + "." +
                        GeoGlobe.Number.zeroPad(date.getUTCMilliseconds(), 3) + "Z";
                }
                return str;
            };
        }

    })(),

    /**

     * Generate a date object from a string.  The format for the string follows
     *     the profile of ISO 8601 for date and time on the Internet (see
     *     http://tools.ietf.org/html/rfc3339).  We don't call the native
     *     Date.parse because of inconsistency between implmentations.  In
     *     Chrome, calling Date.parse with a string that doesn't contain any
     *     indication of the timezone (e.g. "2011"), the date is interpreted
     *     in local time.  On Firefox, the assumption is UTC.
     *     @memberof GeoGlobe.Date.prototype
     *
     *

     * @param  {String}str -  A string representing the date (e.g.
     *     "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z",
     *     "2010-08-07T11:58:23.123-06").
     *
     * @returns
     * {Date} A date object.  If the string could not be parsed, an invalid
     *     date is returned (i.e. isNaN(date.getTime())).
     */
    parse: function(str) {
        var date;
        var match = str.match(this.dateRegEx);
        if (match && (match[1] || match[7])) { // must have at least year or time
            var year = parseInt(match[1], 10) || 0;
            var month = (parseInt(match[2], 10) - 1) || 0;
            var day = parseInt(match[3], 10) || 1;
            date = new Date(Date.UTC(year, month, day));
            // optional time
            var type = match[7];
            if (type) {
                var hours = parseInt(match[4], 10);
                var minutes = parseInt(match[5], 10);
                var secFrac = parseFloat(match[6]);
                var seconds = secFrac | 0;
                var milliseconds = Math.round(1000 * (secFrac - seconds));
                date.setUTCHours(hours, minutes, seconds, milliseconds);
                // check offset
                if (type !== "Z") {
                    var hoursOffset = parseInt(type, 10);
                    var minutesOffset = parseInt(match[8], 10) || 0;
                    var offset = -1000 * (60 * (hoursOffset * 60) + minutesOffset * 60);
                    date = new Date(date.getTime() + offset);
                }
            }
        } else {
            date = new Date("invalid");
        }
        return date;
    }
};

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g._GeoGlobe = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';//      

var wrap = function (n        , min        , max        )         {
    var d = max - min;
    var w = ((n - min) % d + d) % d + min;
    return (w === min) ? max : w;
};

/**
 * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.
 *
 * uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON.
 *
 * Note that any MG method that accepts a `LngLat` object as an argument or option
 * can also accept an `Array` of two numbers and will perform an implicit conversion.
 * This flexible type is documented as {@link LngLatLike}.
 *
 * @param {number} lng Longitude, measured in degrees.
 * @param {number} lat Latitude, measured in degrees.
 * @example
 * var ll = new GeoGlobe.LngLat(-73.9749, 40.7736);
 * @see [Get coordinates of the mouse pointer]()
 * @see [Display a popup]()
 * @see [Highlight features within a bounding box]()
 * @see [Create a timeline animation]()
 */
var LngLat = function LngLat(lng    , lat    ) {
    if (isNaN(lng) || isNaN(lat)) {
        throw new Error(("Invalid LngLat object: (" + lng + ", " + lat + ")"));
    }
    this.lng = +lng;
    this.lat = +lat;
    //if (this.lat > 90 || this.lat < -90) {
    //throw new Error('Invalid LngLat latitude value: must be between -90 and 90');
    //}
};

/**
 * Returns a new `LngLat` object whose longitude is wrapped to the range (-180, 180).
 *
 * @returns {LngLat} The wrapped `LngLat` object.
 * @example
 * var ll = new GeoGlobe.LngLat(286.0251, 40.7736);
 * var wrapped = ll.wrap();
 * wrapped.lng; // = -73.9749
 */
LngLat.prototype.wrap = function wrap$1 () {
    return new LngLat(wrap(this.lng, -180, 180), this.lat);
};

/**
 * Returns the coordinates represented as an array of two numbers.
 *
 * @returns {Array<number>} The coordinates represeted as an array of longitude and latitude.
 * @example
 * var ll = new GeoGlobe.LngLat(-73.9749, 40.7736);
 * ll.toArray(); // = [-73.9749, 40.7736]
 */
LngLat.prototype.toArray = function toArray () {
    return [this.lng, this.lat];
};

/**
 * Returns the coordinates represent as a string.
 *
 * @returns {string} The coordinates represented as a string of the format `'LngLat(lng, lat)'`.
 * @example
 * var ll = new GeoGlobe.LngLat(-73.9749, 40.7736);
 * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
 */
LngLat.prototype.toString = function toString () {
    return ("LngLat(" + (this.lng) + ", " + (this.lat) + ")");
};

/**
 * Returns a `LngLatBounds` from the coordinates extended by a given `radius`.
 *
 * @param {number} radius Distance in meters from the coordinates to extend the bounds.
 * @returns {LngLatBounds} A new `LngLatBounds` object representing the coordinates extended by the `radius`.
 * @example
 * var ll = new GeoGlobe.LngLat(-73.9749, 40.7736);
 * ll.toBounds(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]
 */
LngLat.prototype.toBounds = function toBounds (radius    ) {
    var earthCircumferenceInMetersAtEquator = 40075017;
    var latAccuracy = 360 * radius / earthCircumferenceInMetersAtEquator,
        lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

    var LngLatBounds = require('./lng_lat_bounds');
    return new LngLatBounds(new LngLat(this.lng - lngAccuracy, this.lat - latAccuracy),
        new LngLat(this.lng + lngAccuracy, this.lat + latAccuracy));
};

/**
 * Converts an array of two numbers to a `LngLat` object.
 *
 * If a `LngLat` object is passed in, the function returns it unchanged.
 *
 * @param {LngLatLike} input An array of two numbers to convert, or a `LngLat` object to return.
 * @returns {LngLat} A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.
 * @example
 * var arr = [-73.9749, 40.7736];
 * var ll = GeoGlobe.LngLat.convert(arr);
 * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}
 */
LngLat.convert = function convert (input        )     {
    if (input instanceof LngLat) {
        return input;
    }
    if (Array.isArray(input) && input.length === 2) {
        return new LngLat(Number(input[0]), Number(input[1]));
    }
    if (!Array.isArray(input) && typeof input === 'object' && input !== null) {
        return new LngLat(Number(input.lng), Number(input.lat));
    }
    throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
};

/**
 * A {@link LngLat} object, an array of two numbers representing longitude and latitude,
 * or an object with `lng` and `lat` properties.
 *
 * @typedef {LngLat | {lng: number, lat: number} | [number, number]} LngLatLike
 * @example
 * var v1 = new GeoGlobe.LngLat(-122.420679, 37.772537);
 * var v2 = [-122.420679, 37.772537];
 */
                                                                                

module.exports = LngLat;

},{"./lng_lat_bounds":2}],2:[function(require,module,exports){
'use strict';//      

var LngLat = require('./lng_lat');

                                          

/**
 * A `LngLatBounds` object represents a geographical bounding box,
 * defined by its southwest and northeast points in longitude and latitude.
 *
 * If no arguments are provided to the constructor, a `null` bounding box is created.
 *
 * Note that any MG method that accepts a `LngLatBounds` object as an argument or option
 * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.
 * This flexible type is documented as {@link LngLatBoundsLike}.
 *
 * @param {LngLatLike} [sw] The southwest corner of the bounding box.
 * @param {LngLatLike} [ne] The northeast corner of the bounding box.
 * @example
 * var sw = new GeoGlobe.LngLat(-73.9876, 40.7661);
 * var ne = new GeoGlobe.LngLat(-73.9397, 40.8002);
 * var llb = new GeoGlobe.LngLatBounds(sw, ne);
 */
var LngLatBounds = function LngLatBounds(sw , ne ) {
    if (!sw) {
        return;
    } else if (ne) {
        this.setSouthWest(sw).setNorthEast(ne);
    } else if (sw.length === 4) {
        this.setSouthWest([sw[0], sw[1]]).setNorthEast([sw[2], sw[3]]);
    } else {
        this.setSouthWest(sw[0]).setNorthEast(sw[1]);
    }
};

/**
 * Set the northeast corner of the bounding box
 *
 * @param {LngLatLike} ne
 * @returns {LngLatBounds} `this`
 */
LngLatBounds.prototype.setNorthEast = function setNorthEast (ne        ) {
    this._ne = ne instanceof LngLat ? new LngLat(ne.lng, ne.lat) : LngLat.convert(ne);
    return this;
};

/**
 * Set the southwest corner of the bounding box
 *
 * @param {LngLatLike} sw
 * @returns {LngLatBounds} `this`
 */
LngLatBounds.prototype.setSouthWest = function setSouthWest (sw        ) {
    this._sw = sw instanceof LngLat ? new LngLat(sw.lng, sw.lat) : LngLat.convert(sw);
    return this;
};

/**
 * Extend the bounds to include a given LngLat or LngLatBounds.
 *
 * @param {LngLat|LngLatBounds} obj object to extend to
 * @returns {LngLatBounds} `this`
 */
LngLatBounds.prototype.extend = function extend (obj) {
    var sw = this._sw,
        ne = this._ne;
    var sw2, ne2;

    if (obj instanceof LngLat) {
        sw2 = obj;
        ne2 = obj;

    } else if (obj instanceof LngLatBounds) {
        sw2 = obj._sw;
        ne2 = obj._ne;

        if (!sw2 || !ne2) { return this; }

    } else {
        if (Array.isArray(obj)) {
            if (obj.every(Array.isArray)) {
                return this.extend(LngLatBounds.convert(obj));
            } else {
                return this.extend(LngLat.convert(obj));
            }
        }
        return this;
    }

    if (!sw && !ne) {
        this._sw = new LngLat(sw2.lng, sw2.lat);
        this._ne = new LngLat(ne2.lng, ne2.lat);

    } else {
        sw.lng = Math.min(sw2.lng, sw.lng);
        sw.lat = Math.min(sw2.lat, sw.lat);
        ne.lng = Math.max(ne2.lng, ne.lng);
        ne.lat = Math.max(ne2.lat, ne.lat);
    }

    return this;
};

/**
 * Returns the geographical coordinate equidistant from the bounding box's corners.
 *
 * @returns {LngLat} The bounding box's center.
 * @example
 * var llb = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
 * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
 */
LngLatBounds.prototype.getCenter = function getCenter ()     {
    return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
};

/**
 * Returns the southwest corner of the bounding box.
 *
 * @returns {LngLat} The southwest corner of the bounding box.
 */
LngLatBounds.prototype.getSouthWest = function getSouthWest ()     { return this._sw; };

/**
* Returns the northeast corner of the bounding box.
*
* @returns {LngLat} The northeast corner of the bounding box.
 */
LngLatBounds.prototype.getNorthEast = function getNorthEast ()     { return this._ne; };

/**
* Returns the northwest corner of the bounding box.
*
* @returns {LngLat} The northwest corner of the bounding box.
 */
LngLatBounds.prototype.getNorthWest = function getNorthWest ()     { return new LngLat(this.getWest(), this.getNorth()); };

/**
* Returns the southeast corner of the bounding box.
*
* @returns {LngLat} The southeast corner of the bounding box.
 */
LngLatBounds.prototype.getSouthEast = function getSouthEast ()     { return new LngLat(this.getEast(), this.getSouth()); };

/**
* Returns the west edge of the bounding box.
*
* @returns {number} The west edge of the bounding box.
 */
LngLatBounds.prototype.getWest = function getWest ()     { return this._sw.lng; };

/**
* Returns the south edge of the bounding box.
*
* @returns {number} The south edge of the bounding box.
 */
LngLatBounds.prototype.getSouth = function getSouth ()     { return this._sw.lat; };

/**
* Returns the east edge of the bounding box.
*
* @returns {number} The east edge of the bounding box.
 */
LngLatBounds.prototype.getEast = function getEast ()     { return this._ne.lng; };

/**
* Returns the north edge of the bounding box.
*
* @returns {number} The north edge of the bounding box.
 */
LngLatBounds.prototype.getNorth = function getNorth ()     { return this._ne.lat; };

/**
 * Returns the bounding box represented as an array.
 *
 * @returns {Array<Array<number>>} The bounding box represented as an array, consisting of the
 *   southwest and northeast coordinates of the bounding represented as arrays of numbers.
 * @example
 * var llb = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
 * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
 */
LngLatBounds.prototype.toArray = function toArray () {
    return [this._sw.toArray(), this._ne.toArray()];
};

/**
 * Return the bounding box represented as a string.
 *
 * @returns {string} The bounding box represents as a string of the format
 *   `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.
 * @example
 * var llb = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
 * llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
 */
LngLatBounds.prototype.toString = function toString () {
    return ("LngLatBounds(" + (this._sw.toString()) + ", " + (this._ne.toString()) + ")");
};

/**
 * Converts an array to a `LngLatBounds` object.
 *
 * If a `LngLatBounds` object is passed in, the function returns it unchanged.
 *
 * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.
 *
 * @param {LngLatBoundsLike} input An array of two coordinates to convert, or a `LngLatBounds` object to return.
 * @returns {LngLatBounds} A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.
 * @example
 * var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
 * var llb = GeoGlobe.LngLatBounds.convert(arr);
 * llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
 */
LngLatBounds.convert = function convert (input              )           {
    if (!input || input instanceof LngLatBounds) { return input; }
    return new LngLatBounds(input);
};

/**
 * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,
 * or an array of numbers in [west, south, east, north] order.
 *
 * @typedef {LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number]} LngLatBoundsLike
 * @example
 * var v1 = new GeoGlobe.LngLatBounds(
 *   new GeoGlobe.LngLat(-73.9876, 40.7661),
 *   new GeoGlobe.LngLat(-73.9397, 40.8002)
 * );
 * var v2 = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002])
 * var v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
 */
                                                                                                          

module.exports = LngLatBounds;

},{"./lng_lat":1}],3:[function(require,module,exports){
'use strict';//      

var LngLat = require('./geo/lng_lat');
var LngLatBounds = require('./geo/lng_lat_bounds');
module.exports = {
    LngLat: LngLat,
    LngLatBounds: LngLatBounds,
};

},{"./geo/lng_lat":1,"./geo/lng_lat_bounds":2}]},{},[3])(3)
});
window.GeoGlobe.Util.extend(window.GeoGlobe , window._GeoGlobe);
//GeoGlobe.LngLat
//GeoGlobe.LngLatBounds

/**
 * @class GeoGlobe.LngLat
 * @classdesc 以经度和纬度表示的地理坐标点。
 *
 */



/**
 * 地图上的经度（X轴坐标）。
 * @name lon
 * @memberof GeoGlobe.LngLat.prototype
 * @type {number}
 * @default null
 */

/**
 * 地图上的纬度（Y轴坐标）。
 * @name lat
 * @memberof GeoGlobe.Lng_Lat_geo.prototype
 * @type {String}
 * @default null
 */

/**
 * GeoGlobe.LngLat构造函数。
 * @method initialize
 * @memberof GeoGlobe.LngLat.prototype
 * @param {Object}options -  LngLat相关选项设置。
 * @example
 * var var ll = new GeoGlobe.LngLat(-73.9749, 40.7736);
 *
 */

/**
 *将一个数组转换为坐标对象。
    *@method convert
    *@memberof GeoGlobe.LngLat.prototype
    *@param {array}arr -  数组坐标。
    *@returns {GeoGlobe.LngLat}LngLat -  数组转成的坐标对象。
    *@example
    * var arr = [-73.9749, 40.7736];
    * var ll = GeoGlobe.LngLat.convert(arr);
    * alert(ll);
    */

/**

    * 返回新经纬度对象,其经度范围（-180,180）。
    *@method wrap
    *@memberof GeoGlobe.LngLat.prototype
    *@returns {GeoGlobe.LngLat}LngLat -  新经纬度对象。
    *@example
    * var ll = new GeoGlobe.LngLat(286.0251, 40.7736);
    * var wrapped = ll.wrap();
    * wrapped.lng; // = -73.9749
    *
    */

/**
 * 返回坐标的一个数组。
 * @method toArray
 * @memberof GeoGlobe.LngLat.prototype
 * @returns {array}array -  坐标的一个数组。
 * @example
 * var ll = new GeoGlobe.LngLat(286.0251, 40.7736);
 * ll.toArray(); // = [-73.9749, 40.7736]
 *
 */

/**
 * 返回坐标为字符串。
 * @method toString
 * @memberof GeoGlobe.LngLat.prototype
 * @returns {string} string - 坐标为字符串。
 *
 * @example
 * var ll = new GeoGlobe.LngLat(286.0251, 40.7736);
 * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
 */

/**
 * 返回坐标为字符串。
 * @method toBounds
 * @memberof GeoGlobe.LngLat.prototype
 * @param {Number} radius - 半径。
 * @returns {string} string - 返回一个经纬度范围对象。
 *
 * @example
 *var ll = new GeoGlobe.LngLat(-73.9749, 40.7736);
 *ll.toBounds(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]
 */ 

//GeoGlobe.LngLat = mapboxgl.LngLat;
GeoGlobe.LngLat.prototype.CLASS_NAME = "GeoGlobe.LngLat";
/**
 * @class  GeoGlobe.LngLatBounds
 * @classdesc LngLatBounds是以西南和东北点的经度和纬度，来表示的地理边界。
 */


/**
 * 西南边界。
 * @name sw
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @type {object}
 * @default null
 */

/**
 * 东北边界。
 * @name ne
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @type {object}
 * @default null
 */

/**
 * GeoGlobe.LngLatBounds构造函数。
 * @method initialize
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @param {Object}options - LngLatBounds相关选项设置。
 *
 * @example
 * var sw = new GeoGlobe.LngLat(-73.9876, 40.7661);
 * var ne = new GeoGlobe.LngLat(-73.9397, 40.8002);
 * var llb = new GeoGlobe.LngLatBounds(sw, ne);
 *
 */


/**

* 将两个坐标的数组转换为LngLatBounds对象返回。
* @method convert
* @memberof GeoGlobe.LngLatBounds.prototype
* @param {Array}arr -  数组坐标。
* @returns {Array} LngLat - {GeoGlobe.LngLat} 数组转成的坐标对象.
*
* @example
* var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
* var llb = GeoGlobe.LngLatBounds.convert(arr);
* llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
*/

/**
 * 设置西南边界。
 * @method setNorthEast
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @param {Array} ne -  西南边界坐标。
 *
 */


/**
 * 设置东北边界。
 * @method setSouthWest
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @param {Array}sw -  东北边界。
 */


/**

    * 扩展到指定范围。
    * @method extend
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @param {GeoGlobe.LngLatBounds}obj -  指定范围。
    *
    */

/**

    * 返回边界框地理坐标。
    * @method getCenter
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns
    * LngLat - {GeoGlobe.LngLat} 边界框地理坐标
    * 
    * @example
    * var llb = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
    * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
    *
    */


/**

    * 返回边界的西南角。
    * @method getSouthWest
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns
    * LngLat - {GeoGlobe.LngLat} 边界的西南角
    *
    */


/**

    * 返回边界的东北角。
    * @method getNorthEast
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns
    * LngLat - {GeoGlobe.LngLat} 边界的东北角
    *
    */


/**

    * 返回边界的西北角。
    * @method getNorthWest
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns {GeoGlobe.LngLat} LngLat - 边界的西北角
    */


/**

    * 返回边界的东南角。
    * @method getSouthEast
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns {GeoGlobe.LngLat}LngLat -边界的东南角
    */


/**

    * 返回西边界的边缘。
    * @method getWest
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns {GeoGlobe.LngLat}LngLat -  西边界的边缘
    *
    */

/**

    * 返回东边界的边缘。
    * @method getEast
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns {GeoGlobe.LngLat}LngLat -  东边界的边缘
    *
    */

/**
 * 返回南边界的边缘。
 * @method getSouth
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @returns {GeoGlobe.LngLat}LngLat -  南边界的边缘
 *
 */

/**

    * 返回北边界的边缘。
    * @method getNorth
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns {GeoGlobe.LngLat}LngLat -  返回北边界的边缘
    */

/**

    * 返回边界的一个数组。
    * @method toArray
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns {Array}Array - 边界的一个数组
    *
    * @example
    * var llb = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
    * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
    */

/**
 * 返回边界为字符串。
 * @method toString
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @returns {string}string -  边界为字符串
 *
 * @example
 * var llb = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
 *  llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
 *
 */

/**
 * 返回边界为字符串。
 * @method isEmpty
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @returns {Boolean}   边界如果被定义则为true
 *
 */ 

//GeoGlobe.LngLatBounds = mapboxgl.LngLatBounds;

//因为GeoGlobe.class此方法存在问题，造成类定义的接口无法调用，
//现在临时使用原型对象来扩展接口，达到外部可以调用的效果。

/**
    * 创建这个边界的克隆实例。
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns
    * {GeoGlobe.LngLatBounds} 一个新的边界副本
    */
GeoGlobe.LngLatBounds.prototype.clone = function(){
	return new GeoGlobe.LngLatBounds(this._sw, this._ne);
};

/**
    * 返回边界对象是否包含给定的x和y。
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @param {Float} x

    * @param {Float}y
    * @param {Boolean} inclusive -  是否包含边框。 默认值是true。
    *
    * @returns
    * {Boolean} 传入的坐标是否在这个范围内。
    */
GeoGlobe.LngLatBounds.prototype.contains = function(x, y, inclusive){
	//set default
    if (inclusive == null) {
        inclusive = true;
    }

    if (x == null || y == null) {
        return false;
    }

    x = GeoGlobe.Util.toFloat(x);
    y = GeoGlobe.Util.toFloat(y);

    var contains = false;
    if (inclusive) {
        contains = ((x >= this._sw.lng) && (x <= this._ne.lng) && 
                    (y >= this._sw.lat) && (y <= this._ne.lat));
    } else {
        contains = ((x > this._sw.lng) && (x < this._ne.lng) && 
                    (y > this._sw.lat) && (y < this._ne.lat));
    }              
    return contains;
};
/**
* 返回边界的宽度。
* @memberof GeoGlobe.LngLatBounds.prototype
* @returns {Float} 边界的宽度（右减左）。
*/
GeoGlobe.LngLatBounds.prototype.getWidth = function(){
	return (this._ne.lng - this._sw.lng);
};
/**

    * 返回边界对象是否包含给定的<GeoGlobe.LngLat>。
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @param {GeoGlobe.LngLat|Object}ll - GeoGlobe.LngLat或具有'lon'和'lat'属性的对象。
    * @param {Object}options -  可选参数。
    *
    *可接受的选项：
    * @param {Boolean} inclusive -  是否包含边界。默认是真的。
    * @param {GeoGlobe.LngLatBounds}  worldBounds -如果提供了worldBounds，
    * 如果它超出了世界范围，则ll将被视为包含，
    * 但可以包裹在日期线中，以便它包含在此范围内。
    *
    * @returns
    * {Boolean} 传入的lonlat在这个界限内。
    */
GeoGlobe.LngLatBounds.prototype.containsLonLat = function(ll, options){
	if (typeof options === "boolean") {
        options =  {inclusive: options};
    }
    options = options || {};
    var contains = this.contains(ll.lng, ll.lat, options.inclusive),
        worldBounds = options.worldBounds;
    if (worldBounds && !contains) {
        var worldWidth = worldBounds.getWidth();
        var worldCenterX = (worldBounds._sw.lng + worldBounds._ne.lng) / 2;
        var worldsAway = Math.round((ll.lng - worldCenterX) / worldWidth);
        contains = this.containsLonLat({
            lng: ll.lng - worldsAway * worldWidth,
            lat: ll.lat
        }, {inclusive: options.inclusive});
    }
    return contains;

};
/**
    * 判断地理范围是否相同
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @param {GeoGlobe.LngLatBounds}bounds -
    *
    * @returns{Boolean} 返回值为true，则相等，否则不等
    */
GeoGlobe.LngLatBounds.prototype.equals = function(bounds){
	var equals = false;
    if (bounds != null) {
		/*
        equals = ((this.left == bounds.left) && 
                  (this.right == bounds.right) &&
                  (this.top == bounds.top) && 
                  (this.bottom == bounds.bottom));
                  */
        equals = ((this._sw.lng == bounds._sw.lng) && 
                  (this._ne.lng == bounds._ne.lng) &&
                  (this._ne.lat == bounds._ne.lat) && 
                  (this._sw.lat == bounds._sw.lat));
    }
    return equals;
};
/** 

* 生成一个描述范围的字符串。
* @memberof GeoGlobe.LngLatBounds.prototype
* @param {Integer} decimal -  小数点的精度，默认精确到小数点后6位。
* reverseAxisOrder - {Boolean} 是否需要反转坐标。
* 
* @returns
* {String} 范围字符串(e.g. "5,42,10,45")
*/
GeoGlobe.LngLatBounds.prototype.toBBOX = function(decimal, reverseAxisOrder){
	if (decimal== null) {
        decimal = 6; 
    }
    var mult = Math.pow(10, decimal);
    var xmin = Math.round(this._sw.lng * mult) / mult;
    var ymin = Math.round(this._sw.lat * mult) / mult;
    var xmax = Math.round(this._ne.lng * mult) / mult;
    var ymax = Math.round(this._ne.lat * mult) / mult;
    if (reverseAxisOrder === true) {
        return ymin + "," + xmin + "," + ymax + "," + xmax;
    } else {
        return xmin + "," + ymin + "," + xmax + "," + ymax;
    }
};
/**

* 基于这个范围对象创建一个新的几何面。
* @memberof GeoGlobe.LngLatBounds.prototype
* @returns
* {GeoGlobe.Geometry.Polygon} 新的几何面。
*/
GeoGlobe.LngLatBounds.prototype.toGeometry = function() {
    return new GeoGlobe.Geometry.Polygon([
        new GeoGlobe.Geometry.LinearRing([
            new GeoGlobe.Geometry.Point(this._sw.lng, this._sw.lat),
            new GeoGlobe.Geometry.Point(this._ne.lng, this._sw.lat),
            new GeoGlobe.Geometry.Point(this._ne.lng, this._ne.lat),
            new GeoGlobe.Geometry.Point(this._sw.lng, this._ne.lat)
        ])
    ]);
};
/**
* 返回范围的中心点对象。
* @memberof GeoGlobe.LngLatBounds.prototype
* @returns
* {GeoGlobe.LngLat} 范围的中心点。
*/
GeoGlobe.LngLatBounds.prototype.getCenterLonLat = function() {
	if(!this.centerLonLat) {
        this.centerLonLat = new GeoGlobe.LngLat(
            (this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2
        );
    }
    return this.centerLonLat;
};

GeoGlobe.LngLatBounds.prototype.CLASS_NAME = "GeoGlobe.LngLatBounds";



/** 

 * 从以逗号分隔的bbox字符串创建GeoGlobe.LngLatBounds对象实例。
 *
 * (begin code)
 * GeoGlobe.LngLatBounds.fromString("5,42,10,45");
 * // => equivalent to ...
 * new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(5,42), new GeoGlobe.LngLat(10,45));
 * (end)
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @param {String}str - 逗号分隔的边界字符串。 （例如“5,42,10,45”）
 * @param {Boolean}reverseAxisOrder -  字符串是否反转顺序？
 *
 * @returns
 * {GeoGlobe.LngLatBounds} 根据传入的字符串构建的新边界对象。
 */
GeoGlobe.LngLatBounds.fromString = function(str, reverseAxisOrder) {
    var bounds = str.split(",");
    return GeoGlobe.LngLatBounds.fromArray(bounds, reverseAxisOrder);
};

/** 

 * 从数组中构建新的GeoGlobe.LngLatBounds的替代构造函数。
 *
 * (begin code)
 * GeoGlobe.LngLatBounds.fromArray( [5, 42, 10, 45] );
 * // => equivalent to ...
 * new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(5,42), new GeoGlobe.LngLat(10,45));
 * (end)
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @param {Array(Float)}bbox -  边界值数组（例如[5,42,10,45]）
 * reverseAxisOrder - {Boolean} 数组是否反转顺序？
 *
 * @returns {GeoGlobe.LngLatBounds} 根据传入的数组构建的新边界对象。
 */
GeoGlobe.LngLatBounds.fromArray = function(bbox, reverseAxisOrder) {
    return reverseAxisOrder === true ?
           //new OpenLayers.Bounds(bbox[1], bbox[0], bbox[3], bbox[2]) :
           //new OpenLayers.Bounds(bbox[0], bbox[1], bbox[2], bbox[3]);
           new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(bbox[1],bbox[0]), new GeoGlobe.LngLat(bbox[3],bbox[2])) :
           new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(bbox[0],bbox[1]), new GeoGlobe.LngLat(bbox[2],bbox[3]));
};

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */
 


/**
 * @class GeoGlobe.Geometry
 * @classdesc 几何对象基类。
 */
GeoGlobe.Geometry = GeoGlobe.Class4OL({

    /**
     * A unique identifier for this geometry.
     *  @memberof GeoGlobe.Geometry.prototype
     * @type {String}
     * @private


     */
    id: null,

    /**
     * This is set when a Geometry is added as component
     * of another geometry
     * @memberof GeoGlobe.Geometry.prototype
     * @type {String}
     * @private

     */
    parent: null,

    /**
     * The bounds of this geometry
     * @memberof GeoGlobe.Geometry.prototype
     * @type {GeoGlobe.LngLatBounds}
     * @private

     */
    bounds: null,

    /**

     * 创建一个几何对象。
     * @memberof GeoGlobe.Geometry.prototype
     */
    initialize: function() {
        this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME+ "_");
    },
    
    /**

     * Destroy this geometry.
     *  @memberof GeoGlobe.Geometry.prototype
     * @private
     */
    destroy: function() {
        this.id = null;
        this.bounds = null;
    },
    
    /**

     * 创建这个几何的副本。 不设置副本几何的任何非标准属性。
     *    @memberof GeoGlobe.Geometry.prototype
     * @returns
     * {GeoGlobe.Geometry} 几何的副本。
     */
    clone: function() {
        return new GeoGlobe.Geometry();
    },
    
    /**

     * Set the bounds for this Geometry.
     * @memberof GeoGlobe.Geometry.prototype
     * @param {GeoGlobe.LngLatBounds}bounds
     * @private
     */
    setBounds: function(bounds) {
        if (bounds) {
            this.bounds = bounds.clone();
        }
    },
    
    /**

     * Nullify this components bounds and that of its parent as well.
     * @memberof GeoGlobe.Geometry.prototype
     * @private
     */
    clearBounds: function() {
        this.bounds = null;
        if (this.parent) {
            this.parent.clearBounds();
        }    
    },
    
    /**

     * Extend the existing bounds to include the new bounds. 
     * If geometry's bounds is not yet set, then set a new Bounds.
     * @memberof GeoGlobe.Geometry.prototype
     * @param {GeoGlobe.LngLatBounds}newBounds -
     * @private
     */
    extendBounds: function(newBounds){
        var bounds = this.getBounds();
        if (!bounds) {
            this.setBounds(newBounds);
        } else {
            this.bounds.extend(newBounds);
        }
    },
    
    /**
     * 获取这个几何体的界限。 如果未设置边界，则会再次进行计算，这会使查询更快。
     * @memberof GeoGlobe.Geometry.prototype
     * @returns
     * {GeoGlobe.LngLatBounds}
     */
    getBounds: function() {
        if (this.bounds == null) {
            this.calculateBounds();
        }
        return this.bounds;
    },
    
    /** 

     * 重新计算几何图形的边界。
     * @memberof GeoGlobe.Geometry.prototype
     */
    calculateBounds: function() {
        //
        // This should be overridden by subclasses.
        //
    },
    
    /**

     * 计算两个几何图形之间的最近距离（在x-y平面上）。
     * @memberof GeoGlobe.Geometry.prototype
     * @param {GeoGlobe.Geometry}geometry -  目标几何。
     *  @param {Object}options -  用于配置距离计算的可选属性。
     *
     * 有效的选项取决于特定的几何类型。
     * 
     * @returns
     * {Number | Object} 这个几何与目标之间的距离。 
     * 如果可选参数详细，则返回值将是具有距离x0，y0，x1和x2属性的对象。 
     * x0和y0属性表示此几何体上最近点的坐标。 x1和y1属性表示目标几何体上最近点的坐标。
     */
    distanceTo: function(geometry, options) {
    },
    
    /**

     * 返回此几何中所有点的列表。
     * @memberof GeoGlobe.Geometry.prototype
     * @param {Boolean}nodes -  对于线条，只返回端点的顶点。 
     * 如果为false，则对于线条，仅返回不是端点的顶点。 
     * 如果未提供，则将返回所有顶点。
     *
     * @returns
     * {Array} 几何中所有顶点的列表。
     */
    getVertices: function(nodes) {
    },

    /**

     * Note - This is only an approximation based on the bounds of the 
     * geometry.
     * @memberof GeoGlobe.Geometry.prototype
     * @param {GeoGlobe.LngLat|Object}lnglat -  GeoGlobe.LngLat or an
     *     object with a 'lng' and 'lat' properties.
     * @param {float} toleranceLon -  Optional tolerance in Geometric Coords
     *  @param {float}toleranceLat -  Optional tolerance in Geographic Coords
     * 
     * @returns
     * {Boolean} Whether or not the geometry is at the specified location
     * @private
     */
    atPoint: function(lnglat, toleranceLon, toleranceLat) {
        var atPoint = false;
        var bounds = this.getBounds();
        if ((bounds != null) && (lnglat != null)) {

            var dX = (toleranceLon != null) ? toleranceLon : 0;
            var dY = (toleranceLat != null) ? toleranceLat : 0;
    		
			var _sw = new GeoGlobe.LngLat(this.bounds._sw.lng - dX, this.bounds._sw.lat - dY);
			var _ne = new GeoGlobe.LngLat(this.bounds._ne.lng + dX, this.bounds._ne.lat + dY);
            var toleranceBounds = new GeoGlobe.LngLatBounds(_sw, _ne);
			/*
                new OpenLayers.Bounds(this.bounds.left - dX,
                                      this.bounds.bottom - dY,
                                      this.bounds.right + dX,
                                      this.bounds.top + dY);
            */

            atPoint = toleranceBounds.containsLonLat(lnglat);
        }
        return atPoint;
    },
    
    /**

     * Calculate the length of this geometry. This method is defined in
     * subclasses.
     * @memberof GeoGlobe.Geometry.prototype
     * @returns
     * {Float} The length of the collection by summing its parts
     * @private
     */
    getLength: function() {
        //to be overridden by geometries that actually have a length
        //
        return 0.0;
    },

    /**

     * Calculate the area of this geometry. This method is defined in subclasses.
     * @memberof GeoGlobe.Geometry.prototype
     * @returns
     * {Float} The area of the collection by summing its parts
     * @private
     */
    getArea: function() {
        //to be overridden by geometries that actually have an area
        //
        return 0.0;
    },
    
    /**

     * 计算这个几何的质心。 这个方法在子类中定义。
     * @memberof GeoGlobe.Geometry.prototype
     * @returns
     * {GeoGlobe.Geometry.Point} 集合的质心。
     */
    getCentroid: function() {
        return null;
    },

    /**

     * Returns a text representation of the geometry.  If the WKT format is
     *     included in a build, this will be the Well-Known Text 
     *     representation.
     * @memberof GeoGlobe.Geometry.prototype
     * @returns
     * {String} String representation of this geometry.
     * @private
     */
    toString: function() {
        var string;
        if (GeoGlobe.Format && GeoGlobe.Format.WKT) {
            string = GeoGlobe.Format.WKT.prototype.write(
                new GeoGlobe.Feature(this)
            );
        } else {
            string = Object.prototype.toString.call(this);
        }
        return string;
    },

    CLASS_NAME: "GeoGlobe.Geometry"
});

/**

 * Generate a geometry given a Well-Known Text string.  For this method to
 *     work, you must include the GeoGlobe.Format.WKT in your build 
 *     explicitly.
 * @memberof GeoGlobe.Geometry.prototype
 * @param {String}wkt -  A string representing the geometry in Well-Known Text.
 *
 * @returns
 * {GeoGlobe.Geometry} A geometry of the appropriate class.
 * @private
 */
GeoGlobe.Geometry.fromWKT = function(wkt) {
    var geom;
    if (GeoGlobe.Format && GeoGlobe.Format.WKT) {
        var format = GeoGlobe.Geometry.fromWKT.format;
        if (!format) {
            format = new GeoGlobe.Format.WKT();
            GeoGlobe.Geometry.fromWKT.format = format;
        }
        var result = format.read(wkt);
        if (result instanceof GeoGlobe.Feature) {
            geom = result.geometry;
        } else if (GeoGlobe.Util.isArray(result)) {
            var len = result.length;
            var components = new Array(len);
            for (var i=0; i<len; ++i) {
                components[i] = result[i].geometry;
            }
            geom = new GeoGlobe.Geometry.Collection(components);
        }
    }
    return geom;
};
    
/**

 * Determine whether two line segments intersect.  Optionally calculates
 *     and returns the intersection point.  This function is optimized for
 *     cases where seg1.x2 >= seg2.x1 || seg2.x2 >= seg1.x1.  In those
 *     obvious cases where there is no intersection, the function should
 *     not be called.
 * @memberof GeoGlobe.Geometry.prototype
 * @param {Object}seg1 - Object representing a segment with properties x1, y1, x2,
 *     and y2.  The start point is represented by x1 and y1.  The end point
 *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
 *  @param {Object}seg2 -  Object representing a segment with properties x1, y1, x2,
 *     and y2.  The start point is represented by x1 and y1.  The end point
 *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
 *  @param {Object}options - Optional properties for calculating the intersection.
 *
 * Valid options:
 *@param {Boolean} point -  Return the intersection point.  If false, the actual
 *     intersection point will not be calculated.  If true and the segments
 *     intersect, the intersection point will be returned.  If true and
 *     the segments do not intersect, false will be returned.  If true and
 *     the segments are coincident, true will be returned.
 *@param {Number}  tolerance - If a non-null value is provided, if the segments are
 *     within the tolerance distance, this will be considered an intersection.
 *     In addition, if the point option is true and the calculated intersection
 *     is within the tolerance distance of an end point, the endpoint will be
 *     returned instead of the calculated intersection.  Further, if the
 *     intersection is within the tolerance of endpoints on both segments, or
 *     if two segment endpoints are within the tolerance distance of eachother
 *     (but no intersection is otherwise calculated), an endpoint on the
 *     first segment provided will be returned.
 *
 * @returns
 * {Boolean | GeoGlobe.Geometry.Point}  The two segments intersect.
 *     If the point argument is true, the return will be the intersection
 *     point or false if none exists.  If point is true and the segments
 *     are coincident, return will be true (and the instersection is equal
 *     to the shorter segment).
 * @private
 */
GeoGlobe.Geometry.segmentsIntersect = function(seg1, seg2, options) {
    var point = options && options.point;
    var tolerance = options && options.tolerance;
    var intersection = false;
    var x11_21 = seg1.x1 - seg2.x1;
    var y11_21 = seg1.y1 - seg2.y1;
    var x12_11 = seg1.x2 - seg1.x1;
    var y12_11 = seg1.y2 - seg1.y1;
    var y22_21 = seg2.y2 - seg2.y1;
    var x22_21 = seg2.x2 - seg2.x1;
    var d = (y22_21 * x12_11) - (x22_21 * y12_11);
    var n1 = (x22_21 * y11_21) - (y22_21 * x11_21);
    var n2 = (x12_11 * y11_21) - (y12_11 * x11_21);
    if(d == 0) {
        // parallel
        if(n1 == 0 && n2 == 0) {
            // coincident
            intersection = true;
        }
    } else {
        var along1 = n1 / d;
        var along2 = n2 / d;
        if(along1 >= 0 && along1 <= 1 && along2 >=0 && along2 <= 1) {
            // intersect
            if(!point) {
                intersection = true;
            } else {
                // calculate the intersection point
                var x = seg1.x1 + (along1 * x12_11);
                var y = seg1.y1 + (along1 * y12_11);
                intersection = new GeoGlobe.Geometry.Point(x, y);
            }
        }
    }
    if(tolerance) {
        var dist;
        if(intersection) {
            if(point) {
                var segs = [seg1, seg2];
                var seg, x, y;
                // check segment endpoints for proximity to intersection
                // set intersection to first endpoint within the tolerance
                outer: for(var i=0; i<2; ++i) {
                    seg = segs[i];
                    for(var j=1; j<3; ++j) {
                        x = seg["x" + j];
                        y = seg["y" + j];
                        dist = Math.sqrt(
                            Math.pow(x - intersection.x, 2) +
                            Math.pow(y - intersection.y, 2)
                        );
                        if(dist < tolerance) {
                            intersection.x = x;
                            intersection.y = y;
                            break outer;
                        }
                    }
                }
                
            }
        } else {
            // no calculated intersection, but segments could be within
            // the tolerance of one another
            var segs = [seg1, seg2];
            var source, target, x, y, p, result;
            // check segment endpoints for proximity to intersection
            // set intersection to first endpoint within the tolerance
            outer: for(var i=0; i<2; ++i) {
                source = segs[i];
                target = segs[(i+1)%2];
                for(var j=1; j<3; ++j) {
                    p = {x: source["x"+j], y: source["y"+j]};
                    result = GeoGlobe.Geometry.distanceToSegment(p, target);
                    if(result.distance < tolerance) {
                        if(point) {
                            intersection = new GeoGlobe.Geometry.Point(p.x, p.y);
                        } else {
                            intersection = true;
                        }
                        break outer;
                    }
                }
            }
        }
    }
    return intersection;
};

/**

 *@memberof GeoGlobe.Geometry.prototype
 * @param {Object}point -  An object with x and y properties representing the
 *     point coordinates.
 * @param {Object} segment -  An object with x1, y1, x2, and y2 properties
 *     representing endpoint coordinates.
 *
 * @returns
 * {Object} An object with distance, along, x, and y properties.  The distance
 *     will be the shortest distance between the input point and segment.
 *     The x and y properties represent the coordinates along the segment
 *     where the shortest distance meets the segment. The along attribute
 *     describes how far between the two segment points the given point is.
 * @private
 */
GeoGlobe.Geometry.distanceToSegment = function(point, segment) {
    var result = GeoGlobe.Geometry.distanceSquaredToSegment(point, segment);
    result.distance = Math.sqrt(result.distance);
    return result;
};

/**


 * Usually the distanceToSegment function should be used. This variant however
 * can be used for comparisons where the exact distance is not important.
 * @memberof GeoGlobe.Geometry.prototype

 * @param {Object}point - An object with x and y properties representing the
 *     point coordinates.
 * @param {Object}segment -  An object with x1, y1, x2, and y2 properties
 *     representing endpoint coordinates.
 *
 * @returns
 * {Object} An object with squared distance, along, x, and y properties.
 *     The distance will be the shortest distance between the input point and
 *     segment. The x and y properties represent the coordinates along the
 *     segment where the shortest distance meets the segment. The along
 *     attribute describes how far between the two segment points the given
 *     point is.
 * @private
 */
GeoGlobe.Geometry.distanceSquaredToSegment = function(point, segment) {
    var x0 = point.x;
    var y0 = point.y;
    var x1 = segment.x1;
    var y1 = segment.y1;
    var x2 = segment.x2;
    var y2 = segment.y2;
    var dx = x2 - x1;
    var dy = y2 - y1;
    //var along = ((dx * (x0 - x1)) + (dy * (y0 - y1))) /
    //            (Math.pow(dx, 2) + Math.pow(dy, 2));
	var along = (dx == 0 && dy == 0) ? 0 : ((dx * (x0 - x1)) + (dy * (y0 - y1))) /
                (Math.pow(dx, 2) + Math.pow(dy, 2));
    var x, y;
    if(along <= 0.0) {
        x = x1;
        y = y1;
    } else if(along >= 1.0) {
        x = x2;
        y = y2;
    } else {
        x = x1 + along * dx;
        y = y1 + along * dy;
    }
    return {
        distance: Math.pow(x - x0, 2) + Math.pow(y - y0, 2),
        x: x, y: y,
        along: along
    };
};

/**
 * @static
 * 根据geojson的geometry对象，获得GeoGlobe.Geometry对象。
 * @param {Object} json_geometry geojson中的geometry对象。
 * @returns {GeoGlobe.Geometry} 一个几何对象。
 */
GeoGlobe.Geometry.fromGeoJson = function(json_geometry) {
    var geom;
    if (GeoGlobe.Format && GeoGlobe.Format.GeoJSON) {
        format = new GeoGlobe.Format.GeoJSON();
		var result = null;
		try {
	    	//result = format.read(geojson, "Geometry");
            result = format.parseGeometry(geojson);
        } catch(err) {
            console.log(err);
        }
		geom = result;
    }
    return geom;
};
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */



/**
 * @class GeoGlobe.Geometry.Collection
 * @classdesc 几何对象集合类。
 *      几何对象类类，继承GeoGlobe.Geometry
 *
 */
GeoGlobe.Geometry.Collection = GeoGlobe.Class4OL(GeoGlobe.Geometry, {

    /**

     * 这个几何的组成部分
     *  @memberof GeoGlobe.Geometry.Collection.prototype
     *  @type {Array(GeoGlobe.Geometry)}
     *
     */
    components: null,
    
    /**

     *  An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     * @memberof GeoGlobe.Geometry.Collection.prototype
     * @type {Array(GeoGlobe.Geometry)}
     * @private
     */
    componentTypes: null,

    /**

     * 创建几何集合 - 几何列表。
     *  @memberof GeoGlobe.Geometry.Collection.prototype
     * @param {Array(GeoGlobe.Geometry)} components -  可选几何数组。
     *
     */
    initialize: function (components) {
        GeoGlobe.Geometry.prototype.initialize.apply(this, arguments);
        this.components = [];
        if (components != null) {
            this.addComponents(components);
        }
    },

    /**

     * 搽除这个几何。
     *  @memberof GeoGlobe.Geometry.Collection.prototype
     */
    destroy: function () {
        this.components.length = 0;
        this.components = null;
        GeoGlobe.Geometry.prototype.destroy.apply(this, arguments);
    },

    /**

     *复制这个几何。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @returns
     * {GeoGlobe.Geometry.Collection} 这个集合的副本。
     */
    clone: function() {
        var geometry = eval("new " + this.CLASS_NAME + "()");
        for(var i=0, len=this.components.length; i<len; i++) {
            geometry.addComponent(this.components[i].clone());
        }
        
        // catch any randomly tagged-on properties
        GeoGlobe.Util.applyDefaults(geometry, this);
        
        return geometry;
    },

    /**

     * Get a string representing the components for this collection
     * @memberof GeoGlobe.Geometry.Collection.prototype
     * @returns
     * {String} A string representation of the components of this geometry
     * @private
     */
    getComponentsString: function(){
        var strings = [];
        for(var i=0, len=this.components.length; i<len; i++) {
            strings.push(this.components[i].toShortString()); 
        }
        return strings.join(",");
    },

    /**

     * 通过迭代组件和调用每个项目的extendBounds（）来重新计算边界。
     * @memberof GeoGlobe.Geometry.Collection.prototype
     */
    calculateBounds: function() {
        this.bounds = null;
        //var bounds = new OpenLayers.Bounds();
		//var sw = new GeoGlobe.LngLat(this.x, this.y);
		//var ne = new GeoGlobe.LngLat(this.x, this.y);
		//换成mapboxgl的bounds对象
        var bounds = new GeoGlobe.LngLatBounds();
        var components = this.components;
        if (components) {
            for (var i=0, len=components.length; i<len; i++) {
                bounds.extend(components[i].getBounds());
            }
        }
        // to preserve old behavior, we only set bounds if non-null
        // in the future, we could add bounds.isEmpty()
        //if (bounds.left != null && bounds.bottom != null && 
        //    bounds.right != null && bounds.top != null) {
        //    this.setBounds(bounds);
        //}
		
		if(bounds._sw != null && bounds._sw != null && 
			bounds._ne != null && bounds._ne != null){
			if(bounds._sw.lng != null && bounds._sw.lat != null && 
				bounds._ne.lng != null && bounds._ne.lat != null){
				this.setBounds(bounds);
			}
		}
    },

    /**

     *添加组件到这个几何中。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     *
     * @param {Array(GeoGlobe.Geometry)}components -  要添加的几何图形阵列。
     */
    addComponents: function(components){
        if(!(GeoGlobe.Util.isArray(components))) {
            components = [components];
        }
        for(var i=0, len=components.length; i<len; i++) {
            this.addComponent(components[i]);
        }
    },

    /**

     * Add a new component (geometry) to the collection.  If this.componentTypes
     * is set, then the component class name must be in the componentTypes array.
     *
     * The bounds cache is reset.
     * @memberof GeoGlobe.Geometry.Collection.prototype
     * @param {GeoGlobe.Geometry} component -  A geometry to add
     * @param {int} index -  Optional index into the array to insert the component
     *
     * @returns
     * {Boolean} The component geometry was successfully added
     * @private
     */    
    addComponent: function(component, index) {
        var added = false;
        if(component) {
            if(this.componentTypes == null ||
               (GeoGlobe.Util.indexOf(this.componentTypes,
                                        component.CLASS_NAME) > -1)) {

                if(index != null && (index < this.components.length)) {
                    var components1 = this.components.slice(0, index);
                    var components2 = this.components.slice(index, 
                                                           this.components.length);
                    components1.push(component);
                    this.components = components1.concat(components2);
                } else {
                    this.components.push(component);
                }
                component.parent = this;
                this.clearBounds();
                added = true;
            }
        }
        return added;
    },
    
    /**

     * 从这个几何中移除组件。
     * @memberof GeoGlobe.Geometry.Collection.prototype

     * @param {Array(GeoGlobe.Geometry)}components -  要删除的组件。
     *
     * @returns
     * {Boolean} 一个组件被删除。
     */
    removeComponents: function(components) {
        var removed = false;

        if(!(GeoGlobe.Util.isArray(components))) {
            components = [components];
        }
        for(var i=components.length-1; i>=0; --i) {
            removed = this.removeComponent(components[i]) || removed;
        }
        return removed;
    },
    
    /**

     * Remove a component from this geometry.
     * @memberof GeoGlobe.Geometry.Collection.prototype
     * @param {GeoGlobe.Geometry} component
     *
     * @returns
     * {Boolean} The component was removed.
     * @private
     */
    removeComponent: function(component) {
        
        GeoGlobe.Util.removeItem(this.components, component);
        
        // clearBounds() so that it gets recalculated on the next call
        // to this.getBounds();
        this.clearBounds();
        return true;
    },

    /**

     * 计算这个几何的长度
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @returns
     * {Float} 几何的长度
     */
    getLength: function() {
        var length = 0.0;
        for (var i=0, len=this.components.length; i<len; i++) {
            length += this.components[i].getLength();
        }
        return length;
    },
    

    getArea: function() {
        var area = 0.0;
        for (var i=0, len=this.components.length; i<len; i++) {
            area += this.components[i].getArea();
        }
        return area;
    },

    /** 

     * 计算投影面积。
     *@memberof GeoGlobe.Geometry.Collection.prototype

     * @param {GeoGlobe.Projection} projection -  几何坐标的空间参照系。 如果未提供，则假定为Geographic / WGS84。
     *
     * @returns
     * {float} 单位为平方米的投影面积。
     */
    getGeodesicArea: function(projection) {
        var area = 0.0;
        for(var i=0, len=this.components.length; i<len; i++) {
            area += this.components[i].getGeodesicArea(projection);
        }
        return area;
    },
    
    /**

     *
     * 计算几何的质心。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @param {Boolean}weighted -  递归执行getCentroid计算，返回此集合中所有几何的面积加权平均值。
     *
     * @returns
     * {GeoGlobe.Geometry.Point} 集合的质心。
     */
    getCentroid: function(weighted) {
        if (!weighted) {
            return this.components.length && this.components[0].getCentroid();
        }
        var len = this.components.length;
        if (!len) {
            return false;
        }
        
        var areas = [];
        var centroids = [];
        var areaSum = 0;
        var minArea = Number.MAX_VALUE;
        var component;
        for (var i=0; i<len; ++i) {
            component = this.components[i];
            var area = component.getArea();
            var centroid = component.getCentroid(true);
            if (isNaN(area) || isNaN(centroid.x) || isNaN(centroid.y)) {
                continue;
            }
            areas.push(area);
            areaSum += area;
            minArea = (area < minArea && area > 0) ? area : minArea;
            centroids.push(centroid);
        }
        len = areas.length;
        if (areaSum === 0) {
            // all the components in this collection have 0 area
            // probably a collection of points -- weight all the points the same
            for (var i=0; i<len; ++i) {
                areas[i] = 1;
            }
            areaSum = areas.length;
        } else {
            // normalize all the areas where the smallest area will get
            // a value of 1
            for (var i=0; i<len; ++i) {
                areas[i] /= minArea;
            }
            areaSum /= minArea;
        }
        
        var xSum = 0, ySum = 0, centroid, area;
        for (var i=0; i<len; ++i) {
            centroid = centroids[i];
            area = areas[i];
            xSum += centroid.x * area;
            ySum += centroid.y * area;
        }
        
        return new GeoGlobe.Geometry.Point(xSum/areaSum, ySum/areaSum);
    },

    /**

     * 计算几何投影到地球上的近似长度。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * 几何坐标的空间参照系。 如果未提供，则假定为Geographic / WGS84。
     * @memberof GeoGlobe.Collection.prototype
     * @returns
     * {Float} 几何近似测地线长度（以米为单位）。
     */
    getGeodesicLength: function(projection) {
        var length = 0.0;
        for(var i=0, len=this.components.length; i<len; i++) {
            length += this.components[i].getGeodesicLength(projection);
        }
        return length;
    },

    /**

     * 将给定位移的几何图形沿正x和y轴移动。这将修改几何图形的位置并清除缓存边界。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @param {Float}x - 在正x方向移动几何图形的距离。
     *@param {Float}y -  在正y方向移动几何图形的距离。
     */
    move: function(x, y) {
        for(var i=0, len=this.components.length; i<len; i++) {
            this.components[i].move(x, y);
        }
    },

    /**

     * 围绕某个原点旋转几何图形
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @param {Float}angle -  以度为单位旋转角度（从正X轴逆时针测量）。
     *  @param {GeoGlobe.Geometry.Point}origin -  旋转的中心点。
     */
    rotate: function(angle, origin) {
        for(var i=0, len=this.components.length; i<len; ++i) {
            this.components[i].rotate(angle, origin);
        }
    },

    /**

     * 调整相对于某个原点的几何尺寸。 使用此方法可以实现几何的均匀缩放。
     *@memberof GeoGlobe.Geometry.Collection.prototype

     * @param {Float}scale -  几何缩放的因素。 
     * 比例为2时，每个维度中几何体的大小加倍（例如，线条的长度是两倍，多边形的面积是四倍）。
     *@param {Float}scale -  几何缩放的因素。
      2个原点的比例 - {GeoGlobe.Geometry.Point}调整大小的原点
     * @param {Float} ratio -  x：y的可选比率。 默认比例是1。
     * 
     * @returns
     * {GeoGlobe.Geometry} - 缩放后的几何。
     */
    resize: function(scale, origin, ratio) {
        for(var i=0; i<this.components.length; ++i) {
            this.components[i].resize(scale, origin, ratio);
        }
        return this;
    },

    /**

     * 计算两个几何图形之间的最近距离（在x-y平面上）。
     *@memberof GeoGlobe.Geometry.Collection.prototype

     * @param {GeoGlobe.Geometry} geometry -  目标几何。
     *  @param {Object} options -  用于配置距离计算的可选属性。
     *
     * 有效选项：
     * details - {Boolean} 详细信息 - {Boolean}根据距离计算返回详细信息。默认为false。
     * edge - {Boolean} 计算从此几何体到目标几何体最近边的距离。 默认值是true。 
     *如果为true，则从完全包含在其中的几何体调用distanceTo目标将导致非零距离。 
     *如果为false，则每当几何图形相交时，调用distanceTo将返回0.如果为false，则无法返回详细信息。
     *
     * @returns
     * {Number | Object} 这个几何与目标之间的距离。
     * 如果有细节要求，返回将是一个距离为x0，y0，x1和y1属性的对象。 
     * x0和y0属性表示此几何体上最近点的坐标。 x1和y1属性表示目标几何体上最近点的坐标。
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var result, best, distance;
        var min = Number.POSITIVE_INFINITY;
        for(var i=0, len=this.components.length; i<len; ++i) {
            result = this.components[i].distanceTo(geometry, options);
            distance = details ? result.distance : result;
            if(distance < min) {
                min = distance;
                best = result;
                if(min == 0) {
                    break;
                }
            }
        }
        return best;
    },

    /** 

     *确定另一个几何体是否与此相同。 如果所有组件具有相同的坐标，则几何图形被认为是等同的。
     * @memberof GeoGlobe.Geometry.Collection.prototype
     * @param {GeoGlobe.Geometry} geometry - 几何测试。
     *
     * @returns
     * {Boolean} 提供的几何图形等同于此几何图形。
     */
    equals: function(geometry) {
        var equivalent = true;
        if(!geometry || !geometry.CLASS_NAME ||
           (this.CLASS_NAME != geometry.CLASS_NAME)) {
            equivalent = false;
        } else if(!(GeoGlobe.Util.isArray(geometry.components)) ||
                  (geometry.components.length != this.components.length)) {
            equivalent = false;
        } else {
            for(var i=0, len=this.components.length; i<len; ++i) {
                if(!this.components[i].equals(geometry.components[i])) {
                    equivalent = false;
                    break;
                }
            }
        }
        return equivalent;
    },

    /**

     * 将组件几何图形从源对象重新映射到目标对象。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @param  {GeoGlobe.Projection} source -源对象。
     * @param {GeoGlobe.Projection} dest - 目标对象。
     * 
     * @returns
     * {GeoGlobe.Geometry}
     */
    transform: function(source, dest) {
        if (source && dest) {
            for (var i=0, len=this.components.length; i<len; i++) {  
                var component = this.components[i];
                component.transform(source, dest);
            }
            this.bounds = null;
        }
        return this;
    },

    /**

     * 确定输入几何是否与此几何相交。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @param {GeoGlobe.Geometry}geometry -  任何类型的几何。
     *
     * @returns
     * {Boolean} 输入几何与此相交。
     */
    intersects: function(geometry) {
        var intersect = false;
        for(var i=0, len=this.components.length; i<len; ++ i) {
            intersect = geometry.intersects(this.components[i]);
            if(intersect) {
                break;
            }
        }
        return intersect;
    },

    /**

     * 返回此几何中所有点的列表。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @param {Boolean}nodes -  对于线段，只返回端点的顶点。 
     * 如果为false，则对于线段，仅返回不是端点的顶点。 
     * 如果未提供，则将返回所有顶点。
     *
     * @returns
     * {Array} 返回几何中所有顶点的列表。
     */
    getVertices: function(nodes) {
        var vertices = [];
        for(var i=0, len=this.components.length; i<len; ++i) {
            Array.prototype.push.apply(
                vertices, this.components[i].getVertices(nodes)
            );
        }
        return vertices;
    },


    CLASS_NAME: "GeoGlobe.Geometry.Collection"
});

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Geometry.Point
 * @classdesc 几何点类。
 * 
 * 继承:
 *  - <GeoGlobe.Geometry>
 *      几何点类，继承于GeoGlobe.Geometry
 */
GeoGlobe.Geometry.Point = GeoGlobe.Class4OL(GeoGlobe.Geometry, {

    /** 
     *  x
     *  @memberof GeoGlobe.Geometry.Point.prototype
     *  @type {float}

     */
    x: null,

    /** 
     * y
     * @memberof GeoGlobe.Geometry.Point.prototype
     * @type {float}

     */
    y: null,

    /**

     * 构建点几何。
     *  @memberof GeoGlobe.Geometry.Point.prototype
     * @param {float}x - x坐标。
     * @param {float}y - y坐标。
     * 
     */
    initialize: function(x, y) {
        GeoGlobe.Geometry.prototype.initialize.apply(this, arguments);
        
        this.x = parseFloat(x);
        this.y = parseFloat(y);
    },

    /**

     *  @memberof GeGeoGlobe.Geometry.Point.prototype
     * @returns
     * {GeoGlobe.Geometry.Point} 对GeoGlobe.Geometry.Point进行完全复制。
     */
    clone: function(obj) {
        if (obj == null) {
            obj = new GeoGlobe.Geometry.Point(this.x, this.y);
        }

        // catch any randomly tagged-on properties
        GeoGlobe.Util.applyDefaults(obj, this);

        return obj;
    },

    /** 

     * Create a new Bounds based on the lon/lat
     * @memberof GeGeoGlobe.Geometry.Point.prototype
     * @private
     */
    calculateBounds: function () {
        //this.bounds = new OpenLayers.Bounds(this.x, this.y, this.x, this.y);
		var sw = new GeoGlobe.LngLat(this.x, this.y);
		var ne = new GeoGlobe.LngLat(this.x, this.y);
        this.bounds = new GeoGlobe.LngLatBounds(sw, ne);
											
    },

    /**

     * 计算两个点之间的最近距离（在x-y平面上）。
     *  @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {GeoGlobe.Geometry}geometry -  目标几何。
     * @param {Object} options -  用于配置距离计算的可选属性。
     *
     * 有效选项：
     * details - {Boolean} 从距离计算中返回细节。默认为false。
     * edge - {Boolean} 计算从此点到目标点最近的距离。 默认值是true。 

     *
     * @returns
     * {Number | Object} 这个点与目标点之间的距离。
     * 如果细节是真的，返回将是一个距离为x0，y0，x1和x2属性的物体。 
     * x0和y0属性表示此几何体上最近点的坐标。 x1和y1属性表示目标几何体上最近点的坐标。
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var distance, x0, y0, x1, y1, result;
        if(geometry instanceof GeoGlobe.Geometry.Point) {
            x0 = this.x;
            y0 = this.y;
            x1 = geometry.x;
            y1 = geometry.y;
            distance = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
            result = !details ?
                distance : {x0: x0, y0: y0, x1: x1, y1: y1, distance: distance};
        } else {
            result = geometry.distanceTo(this, options);
            if(details) {
                // switch coord order since this geom is target
                result = {
                    x0: result.x1, y0: result.y1,
                    x1: result.x0, y1: result.y0,
                    distance: result.distance
                };
            }
        }
        return result;
    },
    
    /** 

     * 确定另一个点是否与此相同。 如果所有点具有相同的坐标，则这些点被认为是等同的。
     *  @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {GeoGlobe.Geometry.Point}geom -  The geometry to test.
     *
     * @returns
     * {Boolean} 提供的点等同于此点。
     */
    equals: function(geom) {
        var equals = false;
        if (geom != null) {
            equals = ((this.x == geom.x && this.y == geom.y) ||
                      (isNaN(this.x) && isNaN(this.y) && isNaN(geom.x) && isNaN(geom.y)));
        }
        return equals;
    },
    
    /**

     * @memberof GeGeoGlobe.Geometry.Point.prototype
     * @returns
     * {String} Shortened String representation of Point object. 
     *         (ex. <i>"5, 42"</i>)
     * @private
     */
    toShortString: function() {
        return (this.x + ", " + this.y);
    },
    
    /**

     * 将给定位移的点沿正x和y轴移动。这将修改点的位置并清除缓存边界。
     * @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {Float}x -  Distance to move geometry in positive x direction.
     * @param {Float}y -  Distance to move geometry in positive y direction.
     */
    move: function(x, y) {
        this.x = this.x + x;
        this.y = this.y + y;
        this.clearBounds();
    },

    /**

     * 围绕另一个点进行旋转。
     *  @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {Float}angle -  以度为单位旋转角度（从正X轴逆时针测量）
     * @param {GeoGlobe.Geometry.Point}origin -  旋转的中心点。
     */
    rotate: function(angle, origin) {
        angle *= Math.PI / 180;
        var radius = this.distanceTo(origin);
        var theta = angle + Math.atan2(this.y - origin.y, this.x - origin.x);
        this.x = origin.x + (radius * Math.cos(theta));
        this.y = origin.y + (radius * Math.sin(theta));
        this.clearBounds();
    },
    
    /**

     *@memberof GeGeoGlobe.Geometry.Point.prototype
     * @returns
     * {GeoGlobe.Geometry.Point} 集合的质心
     */
    getCentroid: function() {
        return new GeoGlobe.Geometry.Point(this.x, this.y);
    },

    /**

     * 调整相对于某个原点的点的大小。 
     * 对于点，这具有缩放矢量（从原点到点）的效果。 
     * 这个方法对几何集合子类更有用。
     * @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {Float} scale -  从原点到原点距离的新距离之比。 2的刻度将点与原点之间的距离加倍。
     * @param {GeoGlobe.Geometry.Point} origin -  调整的原点的大小。
     * @param {Float}ratio -  用于调整大小的可选x：y比率。 默认比例是1。
     * 
     * @returns
     * {GeoGlobe.Geometry} - 当前点。
     */
    resize: function(scale, origin, ratio) {
        ratio = (ratio == undefined) ? 1 : ratio;
        this.x = origin.x + (scale * ratio * (this.x - origin.x));
        this.y = origin.y + (scale * (this.y - origin.y));
        this.clearBounds();
        return this;
    },
    
    /**

     * 确定输入的点是否与此重合。
     * @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {GeoGlobe.Geometry}geometry -  任何类型的几何。
     *
     * @returns
     * {Boolean} 输入点与此是否重合。
     */
    intersects: function(geometry) {
        var intersect = false;
        if(geometry.CLASS_NAME == "GeoGlobe.Geometry.Point") {
            intersect = this.equals(geometry);
        } else {
            intersect = geometry.intersects(this);
        }
        return intersect;
    },
    
    /**

     * 将该点的x，y属性从源代码转换为目标代码。
     *  @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {GeoGlobe.SpatialReference} source
     * @param {GeoGlobe.SpatialReference} dest
     * 
     * @returns
     * {GeoGlobe.Geometry}
     */
    transform: function(source, dest) {
        if ((source && dest)) {
            GeoGlobe.SpatialReference.transform(
                this, source, dest); 
            this.bounds = null;
        }       
        return this;
    },

    /**

     * 返回此几何中所有点的列表。
     * @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {Boolean}nodes -  对于线条，只返回端点的顶点。 
     * 如果为false，则对于线条，仅返回不是端点的顶点。 
     * 如果未提供，则将返回所有顶点。
     *
     * @returns
     * {Array} 几何体中所有顶点的列表。
     */
    getVertices: function(nodes) {
        return [this];
    },

    CLASS_NAME: "GeoGlobe.Geometry.Point"
});

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Geometry.MultiPoint
 * @classdesc 点集合几何对象类。
 *
 * Inherits from:
 *  - <GeoGlobe.Geometry.Collection>
 *  - <GeoGlobe.Geometry>
 *  点集合几何对象类，继承于GeoGlobe.Geometry.Collection和GeoGlobe.Geometry
 */
GeoGlobe.Geometry.MultiPoint = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.Collection, {

    /**
     * An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     * @memberof  GeoGlobe.Geometry.MultiPoint.prototype
     * @type {Array(String)}
     * @private
     */
    componentTypes: ["GeoGlobe.Geometry.Point"],

    /**
     * 创建一个新的多点几何。
     * @memberof  GeoGlobe.Geometry.MultiPoint.prototype
     * @param {Array(GeoGlobe.Geometry.Point)}components
     *
     * @returns
     * {GeoGlobe.Geometry.MultiPoint}
     */

    /**

     * 包装为 <GeoGlobe.Geometry.Collection.addComponent>
     *  @memberof  GeoGlobe.Geometry.MultiPoint.prototype
     * @param {GeoGlobe.Geometry.Point}point -  要添加的点。
     * @param {Integer} index -  可选索引。
     */
    addPoint: function(point, index) {
        this.addComponent(point, index);
    },
    
    /**

     * 包装为<GeoGlobe.Geometry.Collection.removeComponent>
     * @memberof  GeoGlobe.Geometry.MultiPoint.prototype
     * @param {GeoGlobe.Geometry.Point}point -  要删除的点。
     */
    removePoint: function(point){
        this.removeComponent(point);
    },

    CLASS_NAME: "GeoGlobe.Geometry.MultiPoint"
});

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Geometry.Curve
 * @classdesc 曲线几何对象类，由多个几何点组成。
 * 
 * Inherits: 
 *  - <GeoGlobe.Geometry.MultiPoint>
 *      曲线对象类。继承于GeoGlobe.Geometry.MultiPoint
 */
GeoGlobe.Geometry.Curve = GeoGlobe.Class4OL(GeoGlobe.Geometry.MultiPoint, {

    /**

     *  An array of class names representing the types of
     *                 components that the collection can include.  A null 
     *                 value means the component types are not restricted.
     *@memberof GeoGlobe.Geometry.Curve.prototype
     *@type {Array(String)}
     * @private
     */
    componentTypes: ["GeoGlobe.Geometry.Point"],

    /**

     *  @memberof GeoGlobe.Geometry.Curve.prototype
     * @param {Array(GeoGlobe.Geometry.Point)}point
     */
    
    /**

     * @memberof GeoGlobe.Geometry.Curve.prototype
     * @returns
     * {Float} 曲线的长度。
     */
    getLength: function() {
        var length = 0.0;
        if ( this.components && (this.components.length > 1)) {
            for(var i=1, len=this.components.length; i<len; i++) {
                length += this.components[i-1].distanceTo(this.components[i]);
            }
        }
        return length;
    },

    /**

     * 计算几何投影长度。
     * @memberof GeoGlobe.Geometry.Curve.prototype
     * 几何坐标的空间参照系。 如果未提供，则假定为Geographic / WGS84。
     *  @memberof GeoGlobe.Geometry.Curve.prototype
     * @returns
     * {Float} 几何的投影长度（以米为单位）。
     */
    getGeodesicLength: function(projection) {
        var geom = this;  // so we can work with a clone if needed
        if(projection) {
            var gg = new GeoGlobe.SpatialReference("EPSG:4326");
            //var gg = new OpenLayers.Projection("EPSG:4326");
            if(!gg.equals(projection)) {
                geom = this.clone().transform(projection, gg);
            }
        }
        var length = 0.0;
        if(geom.components && (geom.components.length > 1)) {
            var p1, p2;
            for(var i=1, len=geom.components.length; i<len; i++) {
                p1 = geom.components[i-1];
                p2 = geom.components[i];
                // this returns km and requires lon/lat properties
                length += GeoGlobe.Util.distVincenty(
                    {lng: p1.x, lat: p1.y}, {lng: p2.x, lat: p2.y}
                );
            }
        }
        // convert to m
        return length * 1000;
    },

    CLASS_NAME: "GeoGlobe.Geometry.Curve"
});

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */



/**
 * @class GeoGlobe.Geometry.LineString
 * @classdesc 非闭合线几何对象类。
 * 
 * 继承:
 *  - <GeoGlobe.Geometry.Curve>
 *      非闭合线几何对象类，继承于GeoGlobe.Geometry.Curve
 */
GeoGlobe.Geometry.LineString = GeoGlobe.Class4OL(GeoGlobe.Geometry.Curve, {

    /**

     * 创建一个新的LineString几何
     *  @memberof GeoGlobe.Geometry.LineString.prototype
     * @param {Array(GeoGlobe.Geometry.Point)}points -  用于生成线条的点集合。
     *
     */

    /**

     * 如果线串中有三个或更多点，则只允许删除一个点。 （否则结果将只是一个点）
     *   @memberof GeoGlobe.Geometry.LineString.prototype
     * @param {GeoGlobe.Geometry.Point}point - 要删除的要点
     *
     * @returns
     * {Boolean} 该组件被删除。
     */
    removeComponent: function(point) {
        var removed = this.components && (this.components.length > 2);
        if (removed) {
            GeoGlobe.Geometry.Collection.prototype.removeComponent.apply(this, 
                                                                  arguments);
        }
        return removed;
    },
    
    /**

     *测试两个几何体之间的交叉。
     * @memberof GeoGlobe.Geometry.LineString.prototype
     * @param {GeoGlobe.Geometry}geometry - 几何参数
     *
     * @returns
     * {Boolean} 输入几何体与该几何体相交。
     */
    intersects: function(geometry) {
        var intersect = false;
        var type = geometry.CLASS_NAME;
        if(type == "GeoGlobe.Geometry.LineString" ||
           type == "GeoGlobe.Geometry.LinearRing" ||
           type == "GeoGlobe.Geometry.Point") {
            var segs1 = this.getSortedSegments();
            var segs2;
            if(type == "GeoGlobe.Geometry.Point") {
                segs2 = [{
                    x1: geometry.x, y1: geometry.y,
                    x2: geometry.x, y2: geometry.y
                }];
            } else {
                segs2 = geometry.getSortedSegments();
            }
            var seg1, seg1x1, seg1x2, seg1y1, seg1y2,
                seg2, seg2y1, seg2y2;
            // sweep right
            outer: for(var i=0, len=segs1.length; i<len; ++i) {
                seg1 = segs1[i];
                seg1x1 = seg1.x1;
                seg1x2 = seg1.x2;
                seg1y1 = seg1.y1;
                seg1y2 = seg1.y2;
                inner: for(var j=0, jlen=segs2.length; j<jlen; ++j) {
                    seg2 = segs2[j];
                    if(seg2.x1 > seg1x2) {
                        // seg1 still left of seg2
                        break;
                    }
                    if(seg2.x2 < seg1x1) {
                        // seg2 still left of seg1
                        continue;
                    }
                    seg2y1 = seg2.y1;
                    seg2y2 = seg2.y2;
                    if(Math.min(seg2y1, seg2y2) > Math.max(seg1y1, seg1y2)) {
                        // seg2 above seg1
                        continue;
                    }
                    if(Math.max(seg2y1, seg2y2) < Math.min(seg1y1, seg1y2)) {
                        // seg2 below seg1
                        continue;
                    }
                    if(GeoGlobe.Geometry.segmentsIntersect(seg1, seg2)) {
                        intersect = true;
                        break outer;
                    }
                }
            }
        } else {
            intersect = geometry.intersects(this);
        }
        return intersect;
    },
    
    /**

     *   @memberof GeoGlobe.Geometry.LineString.prototype
     * @returns
     * {Array} An array of segment objects.  Segment objects have properties
     *     x1, y1, x2, and y2.  The start point is represented by x1 and y1.
     *     The end point is represented by x2 and y2.  Start and end are
     *     ordered so that x1 < x2.
     * @private
     */
    getSortedSegments: function() {
        var numSeg = this.components.length - 1;
        var segments = new Array(numSeg), point1, point2;
        for(var i=0; i<numSeg; ++i) {
            point1 = this.components[i];
            point2 = this.components[i + 1];
            if(point1.x < point2.x) {
                segments[i] = {
                    x1: point1.x,
                    y1: point1.y,
                    x2: point2.x,
                    y2: point2.y
                };
            } else {
                segments[i] = {
                    x1: point2.x,
                    y1: point2.y,
                    x2: point1.x,
                    y2: point1.y
                };
            }
        }
        // more efficient to define this somewhere static
        function byX1(seg1, seg2) {
            return seg1.x1 - seg2.x1;
        }
        return segments.sort(byX1);
    },
    
    /**

     * Split this geometry with the given segment.
     *  @memberof GeoGlobe.Geometry.LineString.prototype
     * @param {Object}seg -An object with x1, y1, x2, and y2 properties referencing
     *     segment endpoint coordinates.
     * @param {Object}options -  Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source segment must be within the
     *     tolerance distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of one of the source segment's
     *     endpoints will be assumed to occur at the endpoint.
     *
     * @returns
     * {Object} An object with *lines* and *points* properties.  If the given
     *     segment intersects this linestring, the lines array will reference
     *     geometries that result from the split.  The points array will contain
     *     all intersection points.  Intersection points are sorted along the
     *     segment (in order from x1,y1 to x2,y2).
     * @private
     */
    splitWithSegment: function(seg, options) {
        var edge = !(options && options.edge === false);
        var tolerance = options && options.tolerance;
        var lines = [];
        var verts = this.getVertices();
        var points = [];
        var intersections = [];
        var split = false;
        var vert1, vert2, point;
        var node, vertex, target;
        var interOptions = {point: true, tolerance: tolerance};
        var result = null;
        for(var i=0, stop=verts.length-2; i<=stop; ++i) {
            vert1 = verts[i];
            points.push(vert1.clone());
            vert2 = verts[i+1];
            target = {x1: vert1.x, y1: vert1.y, x2: vert2.x, y2: vert2.y};
            point = GeoGlobe.Geometry.segmentsIntersect(
                seg, target, interOptions
            );
            if(point instanceof GeoGlobe.Geometry.Point) {
                if((point.x === seg.x1 && point.y === seg.y1) ||
                   (point.x === seg.x2 && point.y === seg.y2) ||
                   point.equals(vert1) || point.equals(vert2)) {
                    vertex = true;
                } else {
                    vertex = false;
                }
                if(vertex || edge) {
                    // push intersections different than the previous
                    if(!point.equals(intersections[intersections.length-1])) {
                        intersections.push(point.clone());
                    }
                    if(i === 0) {
                        if(point.equals(vert1)) {
                            continue;
                        }
                    }
                    if(point.equals(vert2)) {
                        continue;
                    }
                    split = true;
                    if(!point.equals(vert1)) {
                        points.push(point);
                    }
                    lines.push(new GeoGlobe.Geometry.LineString(points));
                    points = [point.clone()];
                }
            }
        }
        if(split) {
            points.push(vert2.clone());
            lines.push(new GeoGlobe.Geometry.LineString(points));
        }
        if(intersections.length > 0) {
            // sort intersections along segment
            var xDir = seg.x1 < seg.x2 ? 1 : -1;
            var yDir = seg.y1 < seg.y2 ? 1 : -1;
            result = {
                lines: lines,
                points: intersections.sort(function(p1, p2) {
                    return (xDir * p1.x - xDir * p2.x) || (yDir * p1.y - yDir * p2.y);
                })
            };
        }
        return result;
    },

    /**

     * Use this geometry (the source) to attempt to split a target geometry.
     *  @memberof GeoGlobe.Geometry.LineString.prototype
     * @param {GeoGlobe.Geometry}target -  The target geometry.
     * @param {Object} options -  Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * @returns
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     * @private
     */
    split: function(target, options) {
        var results = null;
        var mutual = options && options.mutual;
        var sourceSplit, targetSplit, sourceParts, targetParts;
        if(target instanceof GeoGlobe.Geometry.LineString) {
            var verts = this.getVertices();
            var vert1, vert2, seg, splits, lines, point;
            var points = [];
            sourceParts = [];
            for(var i=0, stop=verts.length-2; i<=stop; ++i) {
                vert1 = verts[i];
                vert2 = verts[i+1];
                seg = {
                    x1: vert1.x, y1: vert1.y,
                    x2: vert2.x, y2: vert2.y
                };
                targetParts = targetParts || [target];
                if(mutual) {
                    points.push(vert1.clone());
                }
                for(var j=0; j<targetParts.length; ++j) {
                    splits = targetParts[j].splitWithSegment(seg, options);
                    if(splits) {
                        // splice in new features
                        lines = splits.lines;
                        if(lines.length > 0) {
                            lines.unshift(j, 1);
                            Array.prototype.splice.apply(targetParts, lines);
                            j += lines.length - 2;
                        }
                        if(mutual) {
                            for(var k=0, len=splits.points.length; k<len; ++k) {
                                point = splits.points[k];
                                if(!point.equals(vert1)) {
                                    points.push(point);
                                    sourceParts.push(new GeoGlobe.Geometry.LineString(points));
                                    if(point.equals(vert2)) {
                                        points = [];
                                    } else {
                                        points = [point.clone()];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if(mutual && sourceParts.length > 0 && points.length > 0) {
                points.push(vert2.clone());
                sourceParts.push(new GeoGlobe.Geometry.LineString(points));
            }
        } else {
            results = target.splitWith(this, options);
        }
        if(targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if(sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if(targetSplit || sourceSplit) {
            if(mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },

    /**

     * Split this geometry (the target) with the given geometry (the source).
     *  @memberof GeoGlobe.Geometry.LineString.prototype
     * @param {GeoGlobe.Geometry}geometry -  A geometry used to split this
     *     geometry (the source).
     * @param {Object} options -  Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * @returns
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     * @private
     */
    splitWith: function(geometry, options) {
        return geometry.split(this, options);

    },

    /**

     *返回此几何中所有点的列表。
     * @memberof GeoGlobe.Geometry.LineString.prototype

     * @param {Boolean} nodes -  对于线条，只返回端点的顶点。 
     * 如果为false，则对于线条，仅返回不是端点的顶点。 
     * 如果未提供，则将返回所有顶点。
     *
     * @returns
     * {Array} 几何中所有顶点的列表。
     */
    getVertices: function(nodes) {
        var vertices;
        if(nodes === true) {
            vertices = [
                this.components[0],
                this.components[this.components.length-1]
            ];
        } else if (nodes === false) {
            vertices = this.components.slice(1, this.components.length-1);
        } else {
            vertices = this.components.slice();
        }
        return vertices;
    },

    /**

     * 计算两个几何图形之间的最近距离（在x-y平面上）。
     *  @memberof GeoGlobe.Geometry.LineString.prototype

     * @param {GeoGlobe.Geometry}geometry -  目标几何。
     * @param {Object}options -  用于配置距离的可选属性计算。
     *
     * 有效选项：
     * details - {Boolean} 从距离计算中返回细节。默认为false。
     * edge - {Boolean} 计算从此几何体到目标几何体最近边的距离。 
     *
     * @returns
     * {Number | Object} 这个几何与目标之间的距离。 
     * 如果细节为真，则返回值将是具有距离x0，y0，x1和x2属性的对象。 
     * x0和y0属性表示此几何体上最近点的坐标。 x1和y1属性表示目标几何体上最近点的坐标。
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var result, best = {};
        var min = Number.POSITIVE_INFINITY;
        if(geometry instanceof GeoGlobe.Geometry.Point) {
            var segs = this.getSortedSegments();
            var x = geometry.x;
            var y = geometry.y;
            var seg;
            for(var i=0, len=segs.length; i<len; ++i) {
                seg = segs[i];
                result = GeoGlobe.Geometry.distanceToSegment(geometry, seg);
                if(result.distance < min) {
                    min = result.distance;
                    best = result;
                    if(min === 0) {
                        break;
                    }
                } else {
                    // if distance increases and we cross y0 to the right of x0, no need to keep looking.
                    if(seg.x2 > x && ((y > seg.y1 && y < seg.y2) || (y < seg.y1 && y > seg.y2))) {
                        break;
                    }
                }
            }
            if(details) {
                best = {
                    distance: best.distance,
                    x0: best.x, y0: best.y,
                    x1: x, y1: y
                };
            } else {
                best = best.distance;
            }
        } else if(geometry instanceof GeoGlobe.Geometry.LineString) { 
            var segs0 = this.getSortedSegments();
            var segs1 = geometry.getSortedSegments();
            var seg0, seg1, intersection, x0, y0;
            var len1 = segs1.length;
            var interOptions = {point: true};
            outer: for(var i=0, len=segs0.length; i<len; ++i) {
                seg0 = segs0[i];
                x0 = seg0.x1;
                y0 = seg0.y1;
                for(var j=0; j<len1; ++j) {
                    seg1 = segs1[j];
                    intersection = GeoGlobe.Geometry.segmentsIntersect(seg0, seg1, interOptions);
                    if(intersection) {
                        min = 0;
                        best = {
                            distance: 0,
                            x0: intersection.x, y0: intersection.y,
                            x1: intersection.x, y1: intersection.y
                        };
                        break outer;
                    } else {
                        result = GeoGlobe.Geometry.distanceToSegment({x: x0, y: y0}, seg1);
                        if(result.distance < min) {
                            min = result.distance;
                            best = {
                                distance: min,
                                x0: x0, y0: y0,
                                x1: result.x, y1: result.y
                            };
                        }
                    }
                }
            }
            if(!details) {
                best = best.distance;
            }
            if(min !== 0) {
                // check the final vertex in this line's sorted segments
                if(seg0) {
                    result = geometry.distanceTo(
                        new GeoGlobe.Geometry.Point(seg0.x2, seg0.y2),
                        options
                    );
                    var dist = details ? result.distance : result;
                    if(dist < min) {
                        if(details) {
                            best = {
                                distance: min,
                                x0: result.x1, y0: result.y1,
                                x1: result.x0, y1: result.y0
                            };
                        } else {
                            best = dist;
                        }
                    }
                }
            }
        } else {
            best = geometry.distanceTo(this, options);
            // swap since target comes from this line
            if(details) {
                best = {
                    distance: best.distance,
                    x0: best.x1, y0: best.y1,
                    x1: best.x0, y1: best.y0
                };
            }
        }
        return best;
    },
    
    /**

     * 该函数将返回一个简化的LineString。
     * 简化基于Douglas-Peucker算法。
     * @memberof GeoGlobe.Geometry.LineString.prototype
     *
     * @param {number}tolerance -  地图单元简化的门槛。
     *
     * @returns
     * {GeoGlobe.Geometry.LineString} 简化的LineString。
     */
    simplify: function(tolerance){
        if (this && this !== null) {
            var points = this.getVertices();
            if (points.length < 3) {
                return this;
            }
    
            var compareNumbers = function(a, b){
                return (a-b);
            };
    
            /**
             * Private function doing the Douglas-Peucker reduction
             */
            var douglasPeuckerReduction = function(points, firstPoint, lastPoint, tolerance){
                var maxDistance = 0;
                var indexFarthest = 0;
    
                for (var index = firstPoint, distance; index < lastPoint; index++) {
                    distance = perpendicularDistance(points[firstPoint], points[lastPoint], points[index]);
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        indexFarthest = index;
                    }
                }
    
                if (maxDistance > tolerance && indexFarthest != firstPoint) {
                    //Add the largest point that exceeds the tolerance
                    pointIndexsToKeep.push(indexFarthest);
                    douglasPeuckerReduction(points, firstPoint, indexFarthest, tolerance);
                    douglasPeuckerReduction(points, indexFarthest, lastPoint, tolerance);
                }
            };
    
            /**
             * Private function calculating the perpendicular distance
             * TODO: check whether GeoGlobe.Geometry.LineString::distanceTo() is faster or slower
             */
            var perpendicularDistance = function(point1, point2, point){
                //Area = |(1/2)(x1y2 + x2y3 + x3y1 - x2y1 - x3y2 - x1y3)|   *Area of triangle
                //Base = v((x1-x2)²+(x1-x2)²)                               *Base of Triangle*
                //Area = .5*Base*H                                          *Solve for height
                //Height = Area/.5/Base
    
                var area = Math.abs(0.5 * (point1.x * point2.y + point2.x * point.y + point.x * point1.y - point2.x * point1.y - point.x * point2.y - point1.x * point.y));
                var bottom = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
                var height = area / bottom * 2;
    
                return height;
            };
    
            var firstPoint = 0;
            var lastPoint = points.length - 1;
            var pointIndexsToKeep = [];
    
            //Add the first and last index to the keepers
            pointIndexsToKeep.push(firstPoint);
            pointIndexsToKeep.push(lastPoint);
    
            //The first and the last point cannot be the same
            while (points[firstPoint].equals(points[lastPoint])) {
                lastPoint--;
                //Addition: the first point not equal to first point in the LineString is kept as well
                pointIndexsToKeep.push(lastPoint);
            }
    
            douglasPeuckerReduction(points, firstPoint, lastPoint, tolerance);
            var returnPoints = [];
            pointIndexsToKeep.sort(compareNumbers);
            for (var index = 0; index < pointIndexsToKeep.length; index++) {
                returnPoints.push(points[pointIndexsToKeep[index]]);
            }
            return new GeoGlobe.Geometry.LineString(returnPoints);
    
        }
        else {
            return this;
        }
    },

    CLASS_NAME: "GeoGlobe.Geometry.LineString"
});

/**

 * 创建一个弧线几何对象。
 *   @memberof GeoGlobe.Geometry.LineString.prototype
 * @param {Array(GeoGlobe.Geometry.Point)}points - 弧线的端点。
 */
GeoGlobe.Geometry.LineString.createCurveLine = function(points){
    var curvePoints = [];
	for (var i = 0; i < points.length - 1; i++) {
        var curveCoordinates = GeoGlobe.Geometry.LineString.getCurveCoordinatesByTwoPoints(points[i], points[i + 1]);
        if (curveCoordinates && curveCoordinates.length > 0) {
            curvePoints = curvePoints.concat(curveCoordinates);
        }
    }
    var lineString = new GeoGlobe.Geometry.LineString(curvePoints);
    return lineString;
};

/**

 * 根据弧线的两个端点获取曲线的坐标。
 * @memberof GeoGlobe.Geometry.LineString.prototype
 * @param {GeoGlobe.Geometry.Point}point1 -  弧线的一端点。
 * @param {GeoGlobe.Geometry.Point}point2 - 弧线的另一端点。
 * @private
 */
GeoGlobe.Geometry.LineString.getCurveCoordinatesByTwoPoints = function(point1, point2){
    if (!point1 || !point2 || !(point1 instanceof GeoGlobe.Geometry.Point) || !(point2 instanceof GeoGlobe.Geometry.Point)) {
        return null;
    }
    var o = function(h){
        return 1 - 2 * h + h * h;
    };
    var n = function(h){
        return 2 * h - 2 * h * h;
    };
    var m = function(h){
        return h * h;
    };
    curveCoordinates = [];
    var k = 30;
    var x = false;
    var r, y, l, e, A, u, p;
    var s = [];
    var v = 0;
    var q = 0;
    if (typeof(point2) == "undefined") {
        if (typeof(curveCoordinates) != "undefined") {
            curveCoordinates = [];
        }
        return;
    }
    var g = parseFloat(point1.y);
    var f = parseFloat(point2.y);
    var C = parseFloat(point1.x);
    var B = parseFloat(point2.x);
    if (B > C) {
        if (parseFloat(B - C) > 180) {
            if (C < 0) {
                C = parseFloat(180 + 180 + C);
            }
        }
    }
    if (C > B) {
        if (parseFloat(C - B) > 180) {
            if (B < 0) {
                B = parseFloat(180 + 180 + B);
            }
        }
    }
    u = 0;
    p = 0;
    if (f == g) {
        r = 0;
        y = C - B;
    }
    else {
        if (B == C) {
            r = Math.PI / 2;
            y = g - f;
        }
        else {
            r = Math.atan((f - g) / (B - C));
            y = (f - g) / Math.sin(r);
        }
    }
    if (p == 0) {
        p = (r + (Math.PI / 5));
    }
    l = y / 2;
    A = l * Math.cos(p) + C;
    e = l * Math.sin(p) + g;
    for (v = 0; v < k + 1; v++) {
        curveCoordinates.push(new GeoGlobe.Geometry.Point((C * o(q) + A * n(q)) + B * m(q), (g * o(q) + e * n(q) + f * m(q))));
        q = q + (1 / k);
    }
    return curveCoordinates;
};
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Geometry.LinearRing
 *
 * @classdesc 闭合线几何对象类(起点与终点重合的线)。
 * 
 * 继承:
 *  - <GeoGlobe.Geometry.LineString>
 *      闭合线几何对象类，继承于GeoGlobe.Geometry.LineString
 */
GeoGlobe.Geometry.LinearRing = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.LineString, {

    /**

     * An array of class names representing the types of
     *                 components that the collection can include.  A null 
     *                 value means the component types are not restricted.
     * @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @type {Array(String)}
     * @private
     */
    componentTypes: ["GeoGlobe.Geometry.Point"],

    /**

     * 线性环由一系列点构成。 这个数组可以表示一个封闭或开放的环。 
     * 如果环是开放的（最后一点不等于第一个点），构造函数将关闭环。 
     * 如果环已经关闭（最后一个点与第一个点相等），它将保持关闭。
     * @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {Array(GeoGlobe.Geometry.Point)}points -  点
     */

    /**

     * 向几何组件添加一个点。 
     * 如果要将点添加到组件数组的末尾，并且该点与该数组中已有的最后一个点相同，则不会添加重复点。 
     * 如果它尚未关闭，这将产生关闭环的效果，并且如果它已经关闭，则做正确的事情。 
     * 通过调用具有非空索引的方法作为第二个参数，可以覆盖此行为。
     * @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {GeoGlobe.Geometry.Point}point - 插入点。
     * @param {Integer}index -  插入数组中的索引以插入组件。
     * 
     * @returns
     * {Boolean} 该点是否成功添加？
     */
    addComponent: function(point, index) {
        var added = false;

        //remove last point
        var lastPoint = this.components.pop();

        // given an index, add the point
        // without an index only add non-duplicate points
        if(index != null || !point.equals(lastPoint)) {
            added = GeoGlobe.Geometry.Collection.prototype.addComponent.apply(this, 
                                                                    arguments);
        }

        //append copy of first point
        var firstPoint = this.components[0];
        GeoGlobe.Geometry.Collection.prototype.addComponent.apply(this, 
                                                                [firstPoint]);
        
        return added;
    },
    
    /**

     * 从几何组件中移除一个点。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {GeoGlobe.Geometry.Point} point - 要插入的点。
     *
     * @returns
     * {Boolean} 该组件被删除。
     */
    removeComponent: function(point) {
        var removed = this.components && (this.components.length > 3);
        if (removed) {
            //remove last point
            this.components.pop();
            
            //remove our point
            GeoGlobe.Geometry.Collection.prototype.removeComponent.apply(this, 
                                                                    arguments);
            //append copy of first point
            var firstPoint = this.components[0];
            GeoGlobe.Geometry.Collection.prototype.addComponent.apply(this, 
                                                                [firstPoint]);
        }
        return removed;
    },
    
    /**

     * 将给定位移的几何图形沿正x和y轴移动。这将修改几何图形的位置并清除缓存边界。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {Float}x -  在正x方向移动几何图形的距离。
     *  @param {Float}y - 在正y方向移动几何图形的距离。
     */
    move: function(x, y) {
        for(var i = 0, len=this.components.length; i<len - 1; i++) {
            this.components[i].move(x, y);
        }
    },

    /**

     * 围绕某个原点旋转几何图形。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {Float}angle -  以度为单位旋转角度（从正X轴逆时针测量）。
     *  @param {GeoGlobe.Geometry.Point}origin -  旋转的中心点。
     */
    rotate: function(angle, origin) {
        for(var i=0, len=this.components.length; i<len - 1; ++i) {
            this.components[i].rotate(angle, origin);
        }
    },

    /**

     * 调整相对于某个原点的几何尺寸。 使用此方法可将几何均匀缩放。
     * @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {Float}scale -  几何缩放因子。 
     * 比例尺2是每个尺寸中几何体的尺寸的两倍（例如，线的长度是两倍，多边形的面积是四倍）。
     * @param {GeoGlobe.Geometry.Point} origin -  调整原点。
     *  @param {Float}ratio -  x：y比率。 默认比例是1。
     * 
     * @returns
     * {GeoGlobe.Geometry} - 调整后的几何。
     */
    resize: function(scale, origin, ratio) {
        for(var i=0, len=this.components.length; i<len - 1; ++i) {
            this.components[i].resize(scale, origin, ratio);
        }
        return this;
    },
    
    /**

     * 将组件几何图形从源对象重新映射到目标对象。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {GeoGlobe.SpatialReference}source - 源对象。
     * @param {GeoGlobe.SpatialReference}dest - 目标对象。
     * 
     * @returns
     * {GeoGlobe.Geometry}
     */
    transform: function(source, dest) {
        if (source && dest) {
            for (var i=0, len=this.components.length; i<len - 1; i++) {
                var component = this.components[i];
                component.transform(source, dest);
            }
            this.bounds = null;
        }
        return this;
    },
    
    /**
     * @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @returns
     * {GeoGlobe.Geometry.Point} 集合的质心。
     */
    getCentroid: function() {
        if (this.components) {
            var len = this.components.length;
            if (len > 0 && len <= 2) {
                return this.components[0].clone();
            } else if (len > 2) {
                var sumX = 0.0;
                var sumY = 0.0;
                var x0 = this.components[0].x;
                var y0 = this.components[0].y;
                var area = -1 * this.getArea();
                if (area != 0) {
                    for (var i = 0; i < len - 1; i++) {
                        var b = this.components[i];
                        var c = this.components[i+1];
                        sumX += (b.x + c.x - 2 * x0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
                        sumY += (b.y + c.y - 2 * y0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
                    }
                    var x = x0 + sumX / (6 * area);
                    var y = y0 + sumY / (6 * area);
                } else {
                    for (var i = 0; i < len - 1; i++) {
                        sumX += this.components[i].x;
                        sumY += this.components[i].y;
                    }
                    var x = sumX / (len - 1);
                    var y = sumY / (len - 1);
                }
                return new GeoGlobe.Geometry.Point(x, y);
            } else {
                return null;
            }
        }
    },

    /**

     * 注 - 如果多边形是CW方向，则该区域为正值，否则为负值。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @returns
     * {Float} 环的标志区域。
     */
    getArea: function() {
        var area = 0.0;
        if ( this.components && (this.components.length > 2)) {
            var sum = 0.0;
            for (var i=0, len=this.components.length; i<len - 1; i++) {
                var b = this.components[i];
                var c = this.components[i+1];
                sum += (b.x + c.x) * (c.y - b.y);
            }
            area = - sum / 2.0;
        }
        return area;
    },
    
    /**

     * 计算投影到地球上的多边形的大致面积。 
     * 请注意，如果多边形是顺时针方向，则该区域为正值，否则为负值。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {GeoGlobe.SpatialReference} projection - 投影 - 几何坐标的空间参考系统。 如果未提供，则假定为Geographic / WGS84。
     * 
     * Reference:
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
     *
     * @returns
     * {float} 以平方米为单位的多边形的面积。
     */
    getGeodesicArea: function(projection) {
        var ring = this;  // so we can work with a clone if needed
        if(projection) {
            //var gg = new OpenLayers.Projection("EPSG:4326");
            var gg = new GeoGlobe.SpatialReference("EPSG:4326");
            if(!gg.equals(projection)) {
                ring = this.clone().transform(projection, gg);
            }
        }
        var area = 0.0;
        var len = ring.components && ring.components.length;
        if(len > 2) {
            var p1, p2;
            for(var i=0; i<len-1; i++) {
                p1 = ring.components[i];
                p2 = ring.components[i+1];
                area += GeoGlobe.Util.rad(p2.x - p1.x) *
                        (2 + Math.sin(GeoGlobe.Util.rad(p1.y)) +
                        Math.sin(GeoGlobe.Util.rad(p2.y)));
            }
            area = area * 6378137.0 * 6378137.0 / 2.0;
        }
        return area;
    },
    
    /**

     * Test if a point is inside a linear ring.  For the case where a point
     *     is coincident with a linear ring edge, returns 1.  Otherwise,
     *     returns boolean.
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {GeoGlobe.Geometry.Point}point
     *
     * @returns
     * {Boolean | Number} The point is inside the linear ring.  Returns 1 if
     *     the point is coincident with an edge.  Returns boolean otherwise.
     * @private
     */
    containsPoint: function(point) {
        var approx = GeoGlobe.Number.limitSigDigs;
        var digs = 14;
        var px = approx(point.x, digs);
        var py = approx(point.y, digs);
        function getX(y, x1, y1, x2, y2) {
            return (y - y2) * ((x2 - x1) / (y2 - y1)) + x2;
        }
        var numSeg = this.components.length - 1;
        var start, end, x1, y1, x2, y2, cx, cy;
        var crosses = 0;
        for(var i=0; i<numSeg; ++i) {
            start = this.components[i];
            x1 = approx(start.x, digs);
            y1 = approx(start.y, digs);
            end = this.components[i + 1];
            x2 = approx(end.x, digs);
            y2 = approx(end.y, digs);
            
            /**
             * The following conditions enforce five edge-crossing rules:
             *    1. points coincident with edges are considered contained;
             *    2. an upward edge includes its starting endpoint, and
             *    excludes its final endpoint;
             *    3. a downward edge excludes its starting endpoint, and
             *    includes its final endpoint;
             *    4. horizontal edges are excluded; and
             *    5. the edge-ray intersection point must be strictly right
             *    of the point P.
             */
            if(y1 == y2) {
                // horizontal edge
                if(py == y1) {
                    // point on horizontal line
                    if(x1 <= x2 && (px >= x1 && px <= x2) || // right or vert
                       x1 >= x2 && (px <= x1 && px >= x2)) { // left or vert
                        // point on edge
                        crosses = -1;
                        break;
                    }
                }
                // ignore other horizontal edges
                continue;
            }
            cx = approx(getX(py, x1, y1, x2, y2), digs);
            if(cx == px) {
                // point on line
                if(y1 < y2 && (py >= y1 && py <= y2) || // upward
                   y1 > y2 && (py <= y1 && py >= y2)) { // downward
                    // point on edge
                    crosses = -1;
                    break;
                }
            }
            if(cx <= px) {
                // no crossing to the right
                continue;
            }
            if(x1 != x2 && (cx < Math.min(x1, x2) || cx > Math.max(x1, x2))) {
                // no crossing
                continue;
            }
            if(y1 < y2 && (py >= y1 && py < y2) || // upward
               y1 > y2 && (py < y1 && py >= y2)) { // downward
                ++crosses;
            }
        }
        var contained = (crosses == -1) ?
            // on edge
            1 :
            // even (out) or odd (in)
            !!(crosses & 1);

        return contained;
    },

    /**

     * 确定输入几何体是否与此相交。
     * @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {GeoGlobe.Geometry}geometry -  任何类型的几何。
     *
     * @returns
     * {Boolean} 输入几何体与此相交。
     */
    intersects: function(geometry) {
        var intersect = false;
        if(geometry.CLASS_NAME == "GeoGlobe.Geometry.Point") {
            intersect = this.containsPoint(geometry);
        } else if(geometry.CLASS_NAME == "GeoGlobe.Geometry.LineString") {
            intersect = geometry.intersects(this);
        } else if(geometry.CLASS_NAME == "GeoGlobe.Geometry.LinearRing") {
            intersect = GeoGlobe.Geometry.LineString.prototype.intersects.apply(
                this, [geometry]
            );
        } else {
            // check for component intersections
            for(var i=0, len=geometry.components.length; i<len; ++ i) {
                intersect = geometry.components[i].intersects(this);
                if(intersect) {
                    break;
                }
            }
        }
        return intersect;
    },

    /**

     * 返回此几何中所有点的列表。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {Boolean}nodes - 对于线条，只返回端点的顶点。 
     * 如果为false，则对于线条，仅返回不是端点的顶点。 
     * 如果未提供，则将返回所有顶点。
     *
     * @returns
     * {Array}几何中所有顶点的列表。
     */
    getVertices: function(nodes) {
        return (nodes === true) ? [] : this.components.slice(0, this.components.length-1);
    },

    CLASS_NAME: "GeoGlobe.Geometry.LinearRing"
});

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */



/**
 * @class GeoGlobe.Geometry.Polygon
 * @classdesc 多边形几何对象类。
 * 
 * Inherits from:
 *  - <GeoGlobe.Geometry.Collection> 
 *  - <GeoGlobe.Geometry>
 *      多边形几何对象类,继承于GeoGlobe.Geometry.Collection和GeoGlobe.Geometry
 * @private
 *
 */
GeoGlobe.Geometry.Polygon = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.Collection, {

    /**

     *  An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     *  @memberof  GeoGlobe.Geometry.Polygon .prototype
     *  @type {Array(String)}
     *  @private
     */
    componentTypes: ["GeoGlobe.Geometry.LinearRing"],

    /**

     * 多边形几何体的构造函数。
     * @memberof  GeoGlobe.Geometry.Polygon .prototype
     *
     * @param {Array(GeoGlobe.Geometry.LinearRing)}components
     */

    /** 

     * 通过从外孔的区域减去内孔的面积来计算。
     * @memberof  GeoGlobe.Geometry.Polygon .prototype
     * @returns
     * {float} 几何体的面积
     */
    getArea: function() {
        var area = 0.0;
        if ( this.components && (this.components.length > 0)) {
            area += Math.abs(this.components[0].getArea());
            for (var i=1, len=this.components.length; i<len; i++) {
                area -= Math.abs(this.components[i].getArea());
            }
        }
        return area;
    },

    /** 

     * 计算投影到地球上的多边形的大致面积。
     * @memberof  GeoGlobe.Geometry.Polygon .prototype
     * @param {OpenLayers.Projection}
     * projection -  几何坐标的空间参照系。 如果未提供，则假定为Geographic / WGS84。
     * 
     * 参考：
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
     *
     * @returns
     * {float} 多边形的近似测地面积，单位平方米。
     */
    getGeodesicArea: function(projection) {
        var area = 0.0;
        if(this.components && (this.components.length > 0)) {
            area += Math.abs(this.components[0].getGeodesicArea(projection));
            for(var i=1, len=this.components.length; i<len; i++) {
                area -= Math.abs(this.components[i].getGeodesicArea(projection));
            }
        }
        return area;
    },

    /**

     * Test if a point is inside a polygon.  Points on a polygon edge are
     *     considered inside.
     * @memberof  GeoGlobe.Geometry.Polygon .prototype
     * @param {GeoGlobe.Geometry.Point}point
     *
     * @returns
     * {Boolean | Number} The point is inside the polygon.  Returns 1 if the
     *     point is on an edge.  Returns boolean otherwise.
     * @private
     */
    containsPoint: function(point) {
        var numRings = this.components.length;
        var contained = false;
        if(numRings > 0) {
            // check exterior ring - 1 means on edge, boolean otherwise
            contained = this.components[0].containsPoint(point);
            if(contained !== 1) {
                if(contained && numRings > 1) {
                    // check interior rings
                    var hole;
                    for(var i=1; i<numRings; ++i) {
                        hole = this.components[i].containsPoint(point);
                        if(hole) {
                            if(hole === 1) {
                                // on edge
                                contained = 1;
                            } else {
                                // in hole
                                contained = false;
                            }                            
                            break;
                        }
                    }
                }
            }
        }
        return contained;
    },

    /**

     * Determine if the input geometry intersects this one.
     * 确定输入几何是否相交。 
     * @memberof  GeoGlobe.Geometry.Polygon .prototype
     * @param {GeoGlobe.Geometry}geometry -  任何类型的几何。
     *
     * @returns
     * {Boolean} 输入几何体与此相交。
     */
    intersects: function(geometry) {
        var intersect = false;
        var i, len;
        if(geometry.CLASS_NAME == "GeoGlobe.Geometry.Point") {
            intersect = this.containsPoint(geometry);
        } else if(geometry.CLASS_NAME == "GeoGlobe.Geometry.LineString" ||
                  geometry.CLASS_NAME == "GeoGlobe.Geometry.LinearRing") {
            // check if rings/linestrings intersect
            for(i=0, len=this.components.length; i<len; ++i) {
                intersect = geometry.intersects(this.components[i]);
                if(intersect) {
                    break;
                }
            }
            if(!intersect) {
                // check if this poly contains points of the ring/linestring
                for(i=0, len=geometry.components.length; i<len; ++i) {
                    intersect = this.containsPoint(geometry.components[i]);
                    if(intersect) {
                        break;
                    }
                }
            }
        } else {
            for(i=0, len=geometry.components.length; i<len; ++ i) {
                intersect = this.intersects(geometry.components[i]);
                if(intersect) {
                    break;
                }
            }
        }
        // check case where this poly is wholly contained by another
        if(!intersect && geometry.CLASS_NAME == "GeoGlobe.Geometry.Polygon") {
            // exterior ring points will be contained in the other geometry
            var ring = this.components[0];
            for(i=0, len=ring.components.length; i<len; ++i) {
                intersect = geometry.containsPoint(ring.components[i]);
                if(intersect) {
                    break;
                }
            }
        }
        return intersect;
    },

    /**

     * 计算两个几何图形之间的最近距离（在x-y平面上）。
     * @memberof  GeoGlobe.Geometry.Polygon .prototype
     * @param {GeoGlobe.Geometry}geometry - 目标几何。
     * @param {Object} options - 用于配置距离计算的可选属性。
     *
     * 有效选项：
     * details - {Boolean} 从距离计算中返回细节。默认为false。
     * edge - {Boolean} 计算从此几何体到目标几何体最近边的距离。 默认值是true。 
     * 如果为true，则从完全包含在目标中的几何体调用distanceTo将导致非零距离。 
     * 如果为false，则每当几何图形相交时，调用distanceTo将返回0.如果为false，则无法返回详细信息。
     *
     * @returns
     * {Number | Object} 这个几何与目标之间的距离。
     * 如果细节是真的，返回将是一个距离为x0，y0，x1和y1属性的对象。 
     * x0和y0属性表示此几何体上最近点的坐标。 x1和y1属性表示目标几何体上最近点的坐标。
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var result;
        // this is the case where we might not be looking for distance to edge
        if(!edge && this.intersects(geometry)) {
            result = 0;
        } else {
            result = GeoGlobe.Geometry.Collection.prototype.distanceTo.apply(
                this, [geometry, options]
            );
        }
        return result;
    },

    CLASS_NAME: "GeoGlobe.Geometry.Polygon"
});

/**

 * 围绕半径创建正多边形。
 * @memberof  GeoGlobe.Geometry.Polygon .prototype
 * @param {GeoGlobe.Geometry.Point}origin -  多边形的中心。
 *  @param {Float}radius -  到顶点的距离，以地图为单位。
 * @param {Integer}sides -  边数。 20近似一个圆圈。
 * @param {Float} rotation -  原始旋转角度，以度为单位。
 */
GeoGlobe.Geometry.Polygon.createRegularPolygon = function(origin, radius, sides, rotation) {  
    var angle = Math.PI * ((1/sides) - (1/2));
    if(rotation) {
        angle += (rotation / 180) * Math.PI;
    }
    var rotatedAngle, x, y;
    var points = [];
    for(var i=0; i<sides; ++i) {
        rotatedAngle = angle + (i * 2 * Math.PI / sides);
        x = origin.x + (radius * Math.cos(rotatedAngle));
        y = origin.y + (radius * Math.sin(rotatedAngle));
        points.push(new GeoGlobe.Geometry.Point(x, y));
    }
    var ring = new GeoGlobe.Geometry.LinearRing(points);
    return new GeoGlobe.Geometry.Polygon([ring]);
};

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Geometry.MultiLineString
 * @classdesc 线集合几何对象类，由多个线几何对象（非闭合线）组成的。
 * 
 * Inherits from:
 *  - <GeoGlobe.Geometry.Collection>
 *  - <GeoGlobe.Geometry>
 *       线集合几何对象类,继承于GeoGlobe.Geometry.Collection和GeoGlobe.Geometry
 * @private
 */
GeoGlobe.Geometry.MultiLineString = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.Collection, {

    /**
     *  An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     * @memberof GeoGlobe.Geometry.MultiLineString.prototype
     * @type {Array(String)}
     * @private
     */
    componentTypes: ["GeoGlobe.Geometry.LineString"],

    /**

     * MultiLineString几何体的构造函数。
     * @memberof GeoGlobe.Geometry.MultiLineString.prototype
     * @param {Array(GeoGlobe.Geometry.LineString)}components
     *
     */
    
    /**

     * Use this geometry (the source) to attempt to split a target geometry.
     * @memberof GeoGlobe.Geometry.MultiLineString.prototype
     * @param {GeoGlobe.Geometry}geometry -  The target geometry.
     * @param {Object} options -  Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * Returns:
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     * @private
     */
    split: function(geometry, options) {
        var results = null;
        var mutual = options && options.mutual;
        var splits, sourceLine, sourceLines, sourceSplit, targetSplit;
        var sourceParts = [];
        var targetParts = [geometry];
        for(var i=0, len=this.components.length; i<len; ++i) {
            sourceLine = this.components[i];
            sourceSplit = false;
            for(var j=0; j < targetParts.length; ++j) { 
                splits = sourceLine.split(targetParts[j], options);
                if(splits) {
                    if(mutual) {
                        sourceLines = splits[0];
                        for(var k=0, klen=sourceLines.length; k<klen; ++k) {
                            if(k===0 && sourceParts.length) {
                                sourceParts[sourceParts.length-1].addComponent(
                                    sourceLines[k]
                                );
                            } else {
                                sourceParts.push(
                                    new GeoGlobe.Geometry.MultiLineString([
                                        sourceLines[k]
                                    ])
                                );
                            }
                        }
                        sourceSplit = true;
                        splits = splits[1];
                    }
                    if(splits.length) {
                        // splice in new target parts
                        splits.unshift(j, 1);
                        Array.prototype.splice.apply(targetParts, splits);
                        break;
                    }
                }
            }
            if(!sourceSplit) {
                // source line was not hit
                if(sourceParts.length) {
                    // add line to existing multi
                    sourceParts[sourceParts.length-1].addComponent(
                        sourceLine.clone()
                    );
                } else {
                    // create a fresh multi
                    sourceParts = [
                        new GeoGlobe.Geometry.MultiLineString(
                            sourceLine.clone()
                        )
                    ];
                }
            }
        }
        if(sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if(targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if(sourceSplit || targetSplit) {
            if(mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },
    
    /**

     * Split this geometry (the target) with the given geometry (the source).
     *  @memberof GeoGlobe.Geometry.MultiLineString.prototype
     * @param {GeoGlobe.Geometry}geometry -  A geometry used to split this
     *     geometry (the source).
     * @param {Object} options -  Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * @returns
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     * @private
     */
    splitWith: function(geometry, options) {
        var results = null;
        var mutual = options && options.mutual;
        var splits, targetLine, sourceLines, sourceSplit, targetSplit, sourceParts, targetParts;
        if(geometry instanceof GeoGlobe.Geometry.LineString) {
            targetParts = [];
            sourceParts = [geometry];
            for(var i=0, len=this.components.length; i<len; ++i) {
                targetSplit = false;
                targetLine = this.components[i];
                for(var j=0; j<sourceParts.length; ++j) {
                    splits = sourceParts[j].split(targetLine, options);
                    if(splits) {
                        if(mutual) {
                            sourceLines = splits[0];
                            if(sourceLines.length) {
                                // splice in new source parts
                                sourceLines.unshift(j, 1);
                                Array.prototype.splice.apply(sourceParts, sourceLines);
                                j += sourceLines.length - 2;
                            }
                            splits = splits[1];
                            if(splits.length === 0) {
                                splits = [targetLine.clone()];
                            }
                        }
                        for(var k=0, klen=splits.length; k<klen; ++k) {
                            if(k===0 && targetParts.length) {
                                targetParts[targetParts.length-1].addComponent(
                                    splits[k]
                                );
                            } else {
                                targetParts.push(
                                    new GeoGlobe.Geometry.MultiLineString([
                                        splits[k]
                                    ])
                                );
                            }
                        }
                        targetSplit = true;                    
                    }
                }
                if(!targetSplit) {
                    // target component was not hit
                    if(targetParts.length) {
                        // add it to any existing multi-line
                        targetParts[targetParts.length-1].addComponent(
                            targetLine.clone()
                        );
                    } else {
                        // or start with a fresh multi-line
                        targetParts = [
                            new GeoGlobe.Geometry.MultiLineString([
                                targetLine.clone()
                            ])
                        ];
                    }
                    
                }
            }
        } else {
            results = geometry.split(this);
        }
        if(sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if(targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if(sourceSplit || targetSplit) {
            if(mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },

    CLASS_NAME: "GeoGlobe.Geometry.MultiLineString"
});

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @class GeoGlobe.Geometry.MultiPolygon
 * @classdesc 多边形集合几何对象类，由多个多边形几何对象组成。
 * 
 * 继承:
 *  - <GeoGlobe.Geometry.Collection>
 *       多边形集合几何对象类，继承于GeoGlobe.Geometry.Collection
 *
 */
GeoGlobe.Geometry.MultiPolygon = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.Collection, {

    /**

     * An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     * @memberof GeoGlobe.Geometry.MultiPolygon.prototype
     * @type {Array(String)}
     * @private
     */
    componentTypes: ["GeoGlobe.Geometry.Polygon"],

    /**

     *创建一个新的多边形集合几何对象。
     *@memberof GeoGlobe.Geometry.MultiPolygon.prototype
     *@param {Array(GeoGlobe.Geometry.Polygon)}components -  用于生成MultiPolygon的多边形数组
     *
     */

    CLASS_NAME: "GeoGlobe.Geometry.MultiPolygon"
});

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

// TRASH THIS
GeoGlobe.State = {
    /** states */
    UNKNOWN: 'Unknown',
    INSERT: 'Insert',
    UPDATE: 'Update',
    DELETE: 'Delete'
};

/**
 * @memberof GeoGlobe..Feature.prototype
 * @requires View2D/tool/Util.js
 */

/**
 * @class GeoGlobe.Feature
 * 矢量要素使用GeoGlobe.Geometry类作为几何描述。
 * 他们有一个'attributes'属性，它是数据对象，'style'属性，默认值是在<GeoGlobe.Feature.style>对象中定义的。
 * 
 */
GeoGlobe.Feature = GeoGlobe.Class4OL({

	/**
     *
     * @memberof GeoGlobe.Feature.prototype
     * @type {String}
     * @private
     */
    id: null,
	
    /** 
     *  fid
     * @memberof GeoGlobe.Feature.prototype
     * @type {String}
     * @private
     */
    fid: null,
	
	/** 
     *  lonlat
     * @memberof GeoGlobe.Feature.prototype
     * @type {GeoGlobe.LngLat}
     * @private
     */
    lonlat: null,
    
    /** 
     * 几何
     * @memberof GeoGlobe.Feature.prototype
     * @type {GeoGlobe.Geometry}
     */
    geometry: null,

    /** 
     * 此对象包含描述该功能的任意可序列化属性。
     * @memberof GeoGlobe.Feature.prototype
     * @type {Object}
     */
    attributes: null,
	
	/** 
     *  data
     * @memberof GeoGlobe.Feature.prototype
     * @type {Object}
     * @private

     */
    data: null,
	
    /**
     * Property: bounds
     * {<GeoGlobe.LngLatBounds>} The box bounding that feature's geometry, that
     *     property can be set by an <GeoGlobe.Format> object when
     *     deserializing the feature, so in most cases it represents an
     *     information set by the server. 
     *  @memberof GeoGlobe.Feature.prototype
     *  @param bounds
     *  @private
     */
    bounds: null,

    /**
     * 状态
     * @memberof GeoGlobe.Feature.prototype
     *  @type {String}
     * @private
     */
    state: null,
    
    /**
     *如果此属性已设置，则在上传或删除功能时，{GeoGlobe.HTTP}会将其考虑在内。
     *  @memberof GeoGlobe.Feature.prototype
     *  @type {String}
     */
    url: null,
    
    /**
     * Intentrendering intent currently being used
     * @memberof GeoGlobe.Feature.prototype
     *  @type {String}
     */
    //renderIntent: "default",
    
    /**
     * @memberof GeoGlobe.Feature.prototype
     * @param {Object} modified
     *  An object with the originals of the geometry and attributes of
     * the feature, if they were changed. Currently this property is only read
     * by <GeoGlobe.Format.WFST.v1>, and written by
     * <OpenLayers.Control.ModifyFeature>, which sets the geometry property.
     * Applications can set the originals of modified attributes in the
     * attributes property. Note that applications have to check if this
     * object and the attributes property is already created before using it.
     * After a change made with ModifyFeature, this object could look like
     *
     * (code)
     * {
     *     geometry: >Object
     * }
     * (end)
     *
     * When an application has made changes to feature attributes, it could
     * have set the attributes to something like this:
     *
     * (code)
     * {
     *     attributes: {
     *         myAttribute: "original"
     *     }
     * }
     * (end)
     *
     * Note that <GeoGlobe.Format.WFST.v1> only checks for truthy values in
     * *modified.geometry* and the attribute names in *modified.attributes*,
     * but it is recommended to set the original values (and not just true) as
     * attribute value, so applications could use this information to undo
     * changes.
     * @private
     */
    modified: null,

    /** 
     *
     * 创建一个矢量特征. 
     * @memberof GeoGlobe.Feature.prototype

     * @param {GeoGlobe.Geometry}  geometry - 该特征所代表的几何图形。
     * @param {Object}attributes -  一个将被映射到<attributes>属性的可选对象。
     * @private  
     */
    initialize: function(geometry, attributes) {
        //OpenLayers.Feature.prototype.initialize.apply(this,[null, null, attributes]);
		this.data = (attributes != null) ? attributes : {};
        this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME + "_");
        this.lonlat = null;
        this.geometry = geometry ? geometry : null;
        this.state = null;
        this.attributes = {};
        if (attributes) {
            this.attributes = GeoGlobe.Util.extend(this.attributes,
                                                     attributes);
        }
        //this.style = style ? style : null; 
    },
    
    /** 
     * nullify references to prevent circular references and memory leaks
     * @memberof GeoGlobe.Feature.prototype
     * @private
     */
    destroy: function() {
        //if (this.layer) {
        //    this.layer.removeFeatures(this);
        //    this.layer = null;
        //}
            
        this.geometry = null;
        this.modified = null;
        //OpenLayers.Feature.prototype.destroy.apply(this, arguments);
		this.id = null;
        this.lonlat = null;
        this.data = null;
    },
    
    /**

     * Create a clone of this vector feature.  Does not set any non-standard
     *     properties.
     * @memberof GeoGlobe.Feature.prototype
     * @returns
     * {GeoGlobe.Feature} An exact clone of this vector feature.
     * @private
     */
    clone: function () {
        return new GeoGlobe.Feature(
            this.geometry ? this.geometry.clone() : null,
            this.attributes);
    },

    /**

     * Determine whether the feature is within the map viewport.  This method
     *     tests for an intersection between the geometry and the viewport
     *     bounds.  If a more effecient but less precise geometry bounds
     *     intersection is desired, call the method with the boundsOnly
     *     parameter true.
     *@memberof GeoGlobe.Feature.prototype

     * @param {Boolean} boundsOnly -  Only test whether a feature's bounds intersects
     *     the viewport bounds.  Default is false.  If false, the feature's
     *     geometry must intersect the viewport for onScreen to return true.
     * 
     * @returns
     * {Boolean} The feature is currently visible on screen (optionally
     *     based on its bounds if boundsOnly is true).
     * @private
     */
	/*
    onScreen:function(boundsOnly) {
        var onScreen = false;
        if(this.layer && this.layer.map) {
            var screenBounds = this.layer.map.getExtent();
            if(boundsOnly) {
                var featureBounds = this.geometry.getBounds();
                onScreen = screenBounds.intersectsBounds(featureBounds);
            } else {
                var screenPoly = screenBounds.toGeometry();
                onScreen = screenPoly.intersects(this.geometry);
            }
        }    
        return onScreen;
    },
    */

    /**

     * Determine whether the feature is displayed or not. It may not displayed
     *     because:
     *     - its style display property is set to 'none',
     *     - it doesn't belong to any layer,
     *     - the styleMap creates a symbolizer with display property set to 'none'
     *          for it,
     *     - the layer which it belongs to is not visible.
     * @memberof GeoGlobe.Feature.prototype
     * @returns
     * {Boolean} The feature is currently displayed.
     * @private
     */
	/*
    getVisibility: function() {
        return !(this.style && this.style.display == 'none' ||
                 !this.layer ||
                 this.layer && this.layer.styleMap &&
                 this.layer.styleMap.createSymbolizer(this, this.renderIntent).display == 'none' ||
                 this.layer && !this.layer.getVisibility());
    },
    */
    /**

     * HACK - we need to decide if all vector features should be able to
     *     create markers
     * @memberof GeoGlobe.Feature.prototype
     * @returns
     * {GeoGlobe.Marker} For now just returns null
     * @private
     */
    createMarker: function() {
        return null;
    },

    /**

     * HACK - we need to decide if all vector features should be able to
     *     delete markers
     * 
     * If user overrides the createMarker() function, s/he should be able
     *   to also specify an alternative function for destroying it
     *   @memberof GeoGlobe.Feature.prototype
     * @private
     */
    destroyMarker: function() {
        // pass
    },

    /**

     * HACK - we need to decide if all vector features should be able to
     *     create popups
     * 
     * @returns
     * {GeoGlobe.Popup} For now just returns null
     * @private
     */
    createPopup: function() {
        return null;
    },

    /**

     * Determins whether the feature intersects with the specified location.
     * @memberof GeoGlobe.Feature.prototype

     * @param {GeoGlobe.LngLat|Object}lonlat -  OpenLayers.LonLat or an
     *     object with a 'lon' and 'lat' properties.
     * toleranceLon - {float} Optional tolerance in Geometric Coords
     * toleranceLat - {float} Optional tolerance in Geographic Coords
     * 
     * @returns
     * {Boolean} Whether or not the feature is at the specified location
     * @private
     */
    atPoint: function(lonlat, toleranceLon, toleranceLat) {
        var atPoint = false;
        if(this.geometry) {
            atPoint = this.geometry.atPoint(lonlat, toleranceLon, 
                                                    toleranceLat);
        }
        return atPoint;
    },

    /**

     * HACK - we need to decide if all vector features should be able to
     * delete popups
     * @memberof GeoGlobe.Feature.prototype
     * @private
     */
    destroyPopup: function() {
        // pass
    },

    /**

     * Moves the feature and redraws it at its new location
     *@memberof GeoGlobe.Feature.prototype

     * @param {OpenLayers.LonLat | OpenLayers.Pixel}location -  the
     *         location to which to move the feature.
     * @private
     */
	/*
    move: function(location) {

        if(!this.layer || !this.geometry.move){
            //do nothing if no layer or immoveable geometry
            return undefined;
        }

        var pixel;
        if (location.CLASS_NAME == "OpenLayers.LonLat") {
            pixel = this.layer.getViewPortPxFromLonLat(location);
        } else {
            pixel = location;
        }
        
        var lastPixel = this.layer.getViewPortPxFromLonLat(this.geometry.getBounds().getCenterLonLat());
        var res = this.layer.map.getResolution();
        this.geometry.move(res * (pixel.x - lastPixel.x),
                           res * (lastPixel.y - pixel.y));
        this.layer.drawFeature(this);
        return lastPixel;
    },
    */
    
    /**

     * Sets the new state
     *@memberof GeoGlobe.Feature.prototype
     * @param {String}  state
     * @private
     */
    toState: function(state) {
        if (state == GeoGlobe.State.UPDATE) {
            switch (this.state) {
                case GeoGlobe.State.UNKNOWN:
                case GeoGlobe.State.DELETE:
                    this.state = state;
                    break;
                case GeoGlobe.State.UPDATE:
                case GeoGlobe.State.INSERT:
                    break;
            }
        } else if (state == GeoGlobe.State.INSERT) {
            switch (this.state) {
                case GeoGlobe.State.UNKNOWN:
                    break;
                default:
                    this.state = state;
                    break;
            }
        } else if (state == GeoGlobe.State.DELETE) {
            switch (this.state) {
                case GeoGlobe.State.INSERT:
                    // the feature should be destroyed
                    break;
                case GeoGlobe.State.DELETE:
                    break;
                case GeoGlobe.State.UNKNOWN:
                case GeoGlobe.State.UPDATE:
                    this.state = state;
                    break;
            }
        } else if (state == GeoGlobe.State.UNKNOWN) {
            this.state = state;
        }
    },
    
    CLASS_NAME: "GeoGlobe.Feature"
});


/**
 * @memberof GeoGlobe.Feature.prototype
 * @constant  GeoGlobe.Feature.style
 * OpenLayers features can have a number of style attributes. The 'default' 
 *     style will typically be used if no other style is specified. These
 *     styles correspond for the most part, to the styling properties defined
 *     by the SVG standard. 
 *     Information on fill properties: http://www.w3.org/TR/SVG/painting.html#FillProperties
 *     Information on stroke properties: http://www.w3.org/TR/SVG/painting.html#StrokeProperties
 *
 * Symbolizer: properties
 *  @param {Boolean} fill - Set to false if no fill is desired.
 *  @param {String}fillColor -  Hex fill color.  Default is "#ee9900".
 *  @param {Number}fillOpacity -  Fill opacity (0-1).  Default is 0.4
 *  @param {Boolean}stroke -  Set to false if no stroke is desired.
 *  @param {String}strokeColor -  Hex stroke color.  Default is "#ee9900".
 *  @param {Number}strokeOpacity -  Stroke opacity (0-1).  Default is 1.
 *  @param {Number} strokeWidth - Pixel stroke width.  Default is 1.
 * @param {String}strokeLinecap -  Stroke cap type.  Default is "round".  [butt | round | square]
 *  @param {String}strokeDashstyle - Stroke dash style.  Default is "solid". [dot | dash | dashdot | longdash | longdashdot | solid]
 * @param {Boolean} graphic - Set to false if no graphic is desired.
 *  @param {Number}pointRadius -  Pixel point radius.  Default is 6.
 *  @param {String}pointerEvents -   Default is "visiblePainted".
 *  @param {String}cursor -  Default is "".
 *  @param {String}externalGraphic -  Url to an external graphic that will be used for rendering points.
 *  @param {Number}graphicWidth -  Pixel width for sizing an external graphic.
 *  @param {Number}graphicHeight -  Pixel height for sizing an external graphic.
 *  @param {Number}graphicOpacity -  Opacity (0-1) for an external graphic.
 *  @param {Number}graphicXOffset -  Pixel offset along the positive x axis for displacing an external graphic.
 *  @param {Number}graphicYOffset -  Pixel offset along the positive y axis for displacing an external graphic.
 *  @param {Number} rotation - For point symbolizers, this is the rotation of a graphic in the clockwise direction about its center point (or any point off center as specified by graphicXOffset and graphicYOffset).
 * @param   {Number}graphicZIndex - The integer z-index value to use in rendering.
 * @param {String}graphicName -  Named graphic to use when rendering points.  Supported values include "circle" (default),
 *     "square", "star", "x", "cross", "triangle".
 * @param {String}graphicTitle -  Tooltip when hovering over a feature. *deprecated*, use title instead
 * @param {String}title -  Tooltip when hovering over a feature. Not supported by the canvas renderer.
 *  @param {String}backgroundGraphic -  Url to a graphic to be used as the background under an externalGraphic.
 *  @param {Number}backgroundGraphicZIndex -  The integer z-index value to use in rendering the background graphic.
 *  @param {Number}backgroundXOffset -  The x offset (in pixels) for the background graphic.
 *  @param {Number}backgroundYOffset -  The y offset (in pixels) for the background graphic.
 * @param {Number}backgroundHeight -  The height of the background graphic.  If not provided, the graphicHeight will be used.
 *  @param {Number} backgroundWidth - The width of the background width.  If not provided, the graphicWidth will be used.
 * @param {String}label -  The text for an optional label. For browsers that use the canvas renderer, this requires either
 *     fillText or mozDrawText to be available.
 * @param {String}labelAlign -  Label alignment. This specifies the insertion point relative to the text. It is a string
 *     composed of two characters. The first character is for the horizontal alignment, the second for the vertical
 *      alignment. Valid values for horizontal alignment: "l"=left, "c"=center, "r"=right. Valid values for vertical
 *      alignment: "t"=top, "m"=middle, "b"=bottom. Example values: "lt", "cm", "rb". Default is "cm".
 *  @param {Number} labelXOffset - {Pixel offset along the positive x axis for displacing the label. Not supported by the canvas renderer.
 *  @param {Number}labelYOffset -  Pixel offset along the positive y axis for displacing the label. Not supported by the canvas renderer.
 *  @param {Boolean}labelSelect -  If set to true, labels will be selectable using SelectFeature or similar controls.
 *     Default is false.
 *  @param {String}labelOutlineColor -  The color of the label outline. Default is 'white'. Only supported by the canvas & SVG renderers.
 * @param {Number}  labelOutlineWidth - The width of the label outline. Default is 3, set to 0 or null to disable. Only supported by the  SVG renderers.
 * @param {Number}labelOutlineOpacity -  The opacity (0-1) of the label outline. Default is fontOpacity. Only supported by the canvas & SVG renderers.
 * @param {String}fontColor -  The font color for the label, to be provided like CSS.
 *  @param {Number}fontOpacity -  Opacity (0-1) for the label
 * @param {String} fontFamily -  The font family for the label, to be provided like in CSS.
 *  @param {String} fontSize - The font size for the label, to be provided like in CSS.
 *  @param {String}fontStyle -  The font style for the label, to be provided like in CSS.
 * @param {String}fontWeight -  The font weight for the label, to be provided like in CSS.
 * @param {String}display -  Symbolizers will have no effect if display is set to "none".  All other values have no effect.
*/
/*
GeoGlobe.Feature.style = {
    'default': {
        fillColor: "#ee9900",
        fillOpacity: 0.4, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#ee9900",
        strokeOpacity: 1,
        strokeWidth: 1,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3
    },
    'select': {
        fillColor: "blue",
        fillOpacity: 0.4, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "blue",
        strokeOpacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "pointer",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3

    },
    'temporary': {
        fillColor: "#66cccc",
        fillOpacity: 0.2, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#66cccc",
        strokeOpacity: 1,
        strokeLinecap: "round",
        strokeWidth: 2,
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3

    },
    'delete': {
        display: "none"
    }
};
*/

/**

 * 获取要素数组范围
 *  @memberof GeoGlobe.Feature.prototype

 * @param {Array(GeoGlobe.Feature)} features -
 *
 * @returns
 * {GeoGlobe.LngLatBounds} 数据范围对象。
 * @private
 */
GeoGlobe.Feature.getBoundsByFeatures = function(features){
	var len = features.length;
	var geometries = new Array(len);
	for (var i=0; i<len; ++i) {
		geometries[i] = features[i].geometry;
	}
	var geom = new GeoGlobe.Geometry.Collection(geometries);
	geom.calculateBounds();
	return geom.bounds;
};

/**

 * 根据geojson对象，获得GeoGlobe.Feature对象数组
 *  * @memberof GeoGlobe.Feature.prototype

 * @returns
 * {Array(GeoGlobe.Feature)} 要素对象数组。
 * @private
 */
GeoGlobe.Feature.fromGeoJson = function(geojson) {
    var fea;
    if (GeoGlobe.Format && GeoGlobe.Format.GeoJSON) {
        format = new GeoGlobe.Format.GeoJSON();
    	var fea = format.read(geojson);
    }
    return fea;
};
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */




/**
 * @class GeoGlobe.Filter
 *@classdesc 支持OGC标准的过滤器类。 这个类代表一个OGC过滤器。
 */
GeoGlobe.Filter = GeoGlobe.Class4OL({
    
    /** 

     * 这个类表示一个通用的过滤器。
     * @memberof GeoGlobe.Filter.prototype
     * @param {Object} options - 可选对象的属性将在实例上设置。
     * 
     * @returns {GeoGlobe.Filter}
     */
    initialize: function(options) {
        GeoGlobe.Util.extend(this, options);
    },

    /** 

     * 删除对所添加内容的引用。
     * @memberof GeoGlobe.Filter.prototype
     */
    destroy: function() {
    },

    /**

     * 在特定的上下文中评估此过滤器。 
     * 实例或子类应该覆盖此方法。
     * 
     * @memberof GeoGlobe.Filter.prototype
     * @param {Object} context - 用于评估过滤器的上下文。 如果提供了矢量特征，则feature.attributes将用作上下文。
     * 
     * @returns {Boolean} 该过滤器适用。
     */
    evaluate: function(context) {
        return true;
    },
    
    /**

     * 克隆这个过滤器。 应该由子类来实现。
     * @memberof GeoGlobe.Filter.prototype
     * @returns {GeoGlobe.Filter} 克隆这个过滤器.
     */
    clone: function() {
        return null;
    },
    
    /**

     * @memberof GeoGlobe.Filter.prototype
     * @returns {String} 在您的构建中包含<GeoGlobe.Format.CQL>以获取返回的过滤器的CQL表示形式。 否则，将返回“[Object object]”。
     */
    toString: function() {
        var string;
        if (GeoGlobe.Format && GeoGlobe.Format.CQL) {
            string = GeoGlobe.Format.CQL.prototype.write(this);
        } else {
            string = Object.prototype.toString.call(this);
        }
        return string;
    },
    
    CLASS_NAME: "GeoGlobe.Filter"
});

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 *  @memberof GeoGlobe.Filter.FeatureId.prototype
 * @requires View2D/Filter/Filter.js
 */

/**
 * @class GeoGlobe.Filter.FeatureId
 * @classdesc OGC：FeatureId过滤器，用于SLD样式规则。 该类代表ogc：FeatureId Filter，用于基于规则的SLD样式.
*/
GeoGlobe.Filter.FeatureId = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /** 

     * 特征ID来评估这个规则。
     * 要在params对象内传递。
     * @memberof GeoGlobe.Filter.FeatureId.prototype
     * @type {Array(String)}
     */
    fids: null,
    
    /**
     *
     *@memberof GeoGlobe.Filter.FeatureId.prototype
     * @type {String}
     * @private

     */
    type: "FID",
    
    /** 

     * 创建一个ogc：FeatureId规则。
     *@memberof GeoGlobe.Filter.FeatureId.prototype

     * @param {Object} options -  具有可在规则上设置属性的可选对象
     * 
     * @returns
     * {GeoGlobe.Filter.FeatureId}
     */
    initialize: function(options) {
        this.fids = [];
        GeoGlobe.Filter.prototype.initialize.apply(this, [options]);
    },

    /**

     * 针对特定功能评估此规则
     *@memberof GeoGlobe.Filter.FeatureId.prototype
     * @param {GeoGlobe.Feature} feature - 功能将规则应用于。
     * 对于矢量特征，检查针对fid运行，针对id的简单特征。
     * 
     * @returns
     * {Boolean} 如果规则适用，则为true;否则为false
     */
    evaluate: function(feature) {
        for (var i=0, len=this.fids.length; i<len; i++) {
            var fid = feature.fid || feature.id;
            if (fid == this.fids[i]) {
                return true;
            }
        }
        return false;
    },
    
    /**

     * 克隆这个过滤器。
     *@memberof GeoGlobe.Filter.FeatureId.prototype
        * @returns
     * {GeoGlobe.Filter.FeatureId} 克隆这个过滤器。
     */
    clone: function() {
        var filter = new GeoGlobe.Filter.FeatureId();
        GeoGlobe.Util.extend(filter, this);
        filter.fids = this.fids.slice();
        return filter;
    },
    
    CLASS_NAME: "GeoGlobe.Filter.FeatureId"
});

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @memberof GeoGlobe.Filter.Logical.prototype
 * @requires :View2D/Filter/Filter.js
 */

/**
 * @class GeoGlobe.Filter.Logical

 * @classdesc OGC逻辑运算符规则过滤器类。
 * 

 */
GeoGlobe.Filter.Logical = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    filters: null, 
     
    /**
     *
     * 逻辑运算符的类型。 可用的类型是：
     * - GeoGlobe.Filter.Logical.AND = "&&";
     * - GeoGlobe.Filter.Logical.OR  = "||";
     * - GeoGlobe.Filter.Logical.NOT = "!";
     * @memberof GeoGlobe.Filter.Logical.prototype
     * @type {String}
     */
    type: null,

    /** 

     * 创建一个逻辑过滤器（&&，||，!）。
     *  @memberof GeoGlobe.Filter.Logical.prototype
     * @param {Object}options -  一个可选对象，可在过滤器上设置属性。 
     * @returns
     * {GeoGlobe.Filter.Logical}
     */
    initialize: function(options) {
        this.filters = [];
        GeoGlobe.Filter.prototype.initialize.apply(this, [options]);
    },
    
    /** 

     * 删除对子过滤器的引用。
     * @memberof GeoGlobe.Filter.Logical.prototype
     */
    destroy: function() {
        this.filters = null;
        GeoGlobe.Filter.prototype.destroy.apply(this);
    },

    /**

     * 在特定的上下文中评估此过滤器。
     * @memberof GeoGlobe.Filter.Logical.prototype
     * @param {Object}context -  用于评估过滤器的上下文。  还可以提供矢量特征以评估比较过滤器或空间过滤器中的几何特征的特征属性。
     * @returns
     * {Boolean} 该过滤器适用。
     */
    evaluate: function(context) {
        var i, len;
        switch(this.type) {
            case GeoGlobe.Filter.Logical.AND:
                for (i=0, len=this.filters.length; i<len; i++) {
                    if (this.filters[i].evaluate(context) == false) {
                        return false;
                    }
                }
                return true;
                
            case GeoGlobe.Filter.Logical.OR:
                for (i=0, len=this.filters.length; i<len; i++) {
                    if (this.filters[i].evaluate(context) == true) {
                        return true;
                    }
                }
                return false;
            
            case GeoGlobe.Filter.Logical.NOT:
                return (!this.filters[0].evaluate(context));
        }
        return undefined;
    },
    
    /**

     * 复制这个过滤器。
     * @memberof GeoGlobe.Filter.Logical.prototype
     * @returns
     * {GeoGlobe.Filter.Logical} 复制这个过滤器。
     */
    clone: function() {
        var filters = [];        
        for(var i=0, len=this.filters.length; i<len; ++i) {
            filters.push(this.filters[i].clone());
        }
        return new GeoGlobe.Filter.Logical({
            type: this.type,
            filters: filters
        });
    },
    
    CLASS_NAME: "GeoGlobe.Filter.Logical"
});


GeoGlobe.Filter.Logical.AND = "&&";
GeoGlobe.Filter.Logical.OR  = "||";
GeoGlobe.Filter.Logical.NOT = "!";

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 *  @memberof GeoGlobe.Filter.Comparison.prototype
 * @requires View2D/Filter/Filter.js
 */

/**
 * @class GeoGlobe.Filter.Comparison
 * @classdesc 比较操作符过滤器类。 这个类代表一个比较过滤器。
 *
 *
 */
GeoGlobe.Filter.Comparison = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /**
     * 比较类型. 
     *  @memberof GeoGlobe.Filter.Comparison.prototype
     * @type {String}
     */
    type: null,
    
    /**
     *  要比较的上下文属性的名称
     *  @memberof GeoGlobe.Filter.Comparison.prototype
     * @type {String}
     */
    property: null,
    
    /**
     * 二进制比较的比较值。 在字符串的情况下，这可以是文本和propertyNames的组合，形式为“literal $ {propertyName}”
     * @memberof GeoGlobe.Filter.Comparison.prototype
     * @type {Number | string}
     */
    value: null,
    
    /**

     *  Force case sensitive searches for EQUAL_TO and NOT_EQUAL_TO
     *     comparisons.  The Filter Encoding 1.1 specification added a matchCase
     *     attribute to ogc:PropertyIsEqualTo and ogc:PropertyIsNotEqualTo
     *     elements.  This property will be serialized with those elements only
     *     if using the v1.1.0 filter format. However, when evaluating filters
     *     here, the matchCase property will always be respected (for EQUAL_TO
     *     and NOT_EQUAL_TO).  Default is true.
     *     @memberof GeoGlobe.Filter.Comparison.prototype
     *    @type {Boolean}
     *    @private
     */
    matchCase: true,
    
    /**
    * 比较之间的下限。 在字符串的情况下，这可以是文本和propertyNames的组合，形式为“literal $ {propertyName}”
     *   @memberof GeoGlobe.Filter.Comparison.prototype
     * @type {Number | string}
     */
    lowerBoundary: null,
    
    /**
     * 比较之间的上限。 在字符串的情况下，这可以是文本和propertyNames的组合，形式为“literal $ {propertyName}”
     *   @memberof GeoGlobe.Filter.Comparison.prototype
     * @type {Number | string}
     */
    upperBoundary: null,

    /** 

     * 创建比较规则。
     * @memberof GeoGlobe.Filter.Comparison.prototype
     * @param {Object} options -  具有可在规则上设置属性的可选对象
     * 
     * @returns
     * {GeoGlobe.Filter.Comparison}
     */
    initialize: function(options) {
        GeoGlobe.Filter.prototype.initialize.apply(this, [options]);
        // since matchCase on PropertyIsLike is not schema compliant, we only
        // want to use this if explicitly asked for
        if (this.type === GeoGlobe.Filter.Comparison.LIKE 
            && options.matchCase === undefined) {
                this.matchCase = null;
        }
    },

    /**

     *  在特定的上下文中评估此过滤器。
     *  @memberof GeoGlobe.Filter.Comparison.prototype
     *  @param {Object}  context - 用于评估过滤器的上下文。 如果提供了矢量特征，则feature.attributes将用作上下文。
     * 
     * @returns
     * {Boolean} 该过滤器适用。
     */
    evaluate: function(context) {
        if (context instanceof GeoGlobe.Feature) {
            context = context.attributes;
        }
        var result = false;
        var got = context[this.property];
		if (got === undefined) {
            return false;
        }
        var exp;
        switch(this.type) {
            case GeoGlobe.Filter.Comparison.EQUAL_TO:
                exp = this.value;
                if(!this.matchCase &&
                   typeof got == "string" && typeof exp == "string") {
                    result = (got.toUpperCase() == exp.toUpperCase());
                } else {
                    result = (got == exp);
                }
                break;
            case GeoGlobe.Filter.Comparison.NOT_EQUAL_TO:
                exp = this.value;
                if(!this.matchCase &&
                   typeof got == "string" && typeof exp == "string") {
                    result = (got.toUpperCase() != exp.toUpperCase());
                } else {
                    result = (got != exp);
                }
                break;
            case GeoGlobe.Filter.Comparison.LESS_THAN:
                result = got < this.value;
                break;
            case GeoGlobe.Filter.Comparison.GREATER_THAN:
                result = got > this.value;
                break;
            case GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO:
                result = got <= this.value;
                break;
            case GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO:
                result = got >= this.value;
                break;
            case GeoGlobe.Filter.Comparison.BETWEEN:
                result = (got >= this.lowerBoundary) &&
                    (got <= this.upperBoundary);
                break;
            case GeoGlobe.Filter.Comparison.LIKE:
                var regexp = new RegExp(this.value, "gi");
                result = regexp.test(got);
                break;
            case GeoGlobe.Filter.Comparison.IS_NULL:
                result = (got === null);
                break;
        }
        return result;
    },
    
    /**

    * 根据指定的通配符将此规则的值转换为正则表达式字符串。 如果该值不是正则表达式，则必须在此类的实例化后调用此方法。
     *@memberof GeoGlobe.Filter.Comparison.prototype
     *@param {Char} wildCard   -  通配符在上面的值中，默认是“*”
     *@param {Char}singleChar -  上述值中的单字符通配符默认为“。”
     *@param {Char}escapeChar -  转义字符在上面的值中，默认是“！”
     * 
     * @returns
     * {String} 正则表达式字符串
     */
    value2regex: function(wildCard, singleChar, escapeChar) {
        if (wildCard == ".") {
            throw new Error("'.' is an unsupported wildCard character for " +
                            "GeoGlobe.Filter.Comparison");
        }
        

        // set UMN MapServer defaults for unspecified parameters
        wildCard = wildCard ? wildCard : "*";
        singleChar = singleChar ? singleChar : ".";
        escapeChar = escapeChar ? escapeChar : "!";
        
        this.value = this.value.replace(
                new RegExp("\\"+escapeChar+"(.|$)", "g"), "\\$1");
        this.value = this.value.replace(
                new RegExp("\\"+singleChar, "g"), ".");
        this.value = this.value.replace(
                new RegExp("\\"+wildCard, "g"), ".*");
        this.value = this.value.replace(
                new RegExp("\\\\.\\*", "g"), "\\"+wildCard);
        this.value = this.value.replace(
                new RegExp("\\\\\\.", "g"), "\\"+singleChar);
        
        return this.value;
    },
    
    /**

     * Convert the value of this rule from a regular expression string into an
     *     ogc literal string using a wildCard of *, a singleChar of ., and an
     *     escape of !.  Leaves the <value> property unmodified.
     * @memberof GeoGlobe.Filter.Comparison.prototype
     * @returns
     * {String} A string value.
     * @private
     */
    regex2value: function() {
        
        var value = this.value;
        
        // replace ! with !!
        value = value.replace(/!/g, "!!");

        // replace \. with !. (watching out for \\.)
        value = value.replace(/(\\)?\\\./g, function($0, $1) {
            return $1 ? $0 : "!.";
        });
        
        // replace \* with #* (watching out for \\*)
        value = value.replace(/(\\)?\\\*/g, function($0, $1) {
            return $1 ? $0 : "!*";
        });
        
        // replace \\ with \
        value = value.replace(/\\\\/g, "\\");

        // convert .* to * (the sequence #.* is not allowed)
        value = value.replace(/\.\*/g, "*");
        
        return value;
    },
    
    /**

     * 克隆这个过滤器。
     * @memberof GeoGlobe.Filter.Comparison.prototype
     * @returns
     * {GeoGlobe.Filter.Comparison} 克隆这个过滤器。
     */
    clone: function() {
        return GeoGlobe.Util.extend(new GeoGlobe.Filter.Comparison(), this);
    },
    
    CLASS_NAME: "GeoGlobe.Filter.Comparison"
});


GeoGlobe.Filter.Comparison.EQUAL_TO                 = "==";
GeoGlobe.Filter.Comparison.NOT_EQUAL_TO             = "!=";
GeoGlobe.Filter.Comparison.LESS_THAN                = "<";
GeoGlobe.Filter.Comparison.GREATER_THAN             = ">";
GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO    = "<=";
GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO = ">=";
GeoGlobe.Filter.Comparison.BETWEEN                  = "..";
GeoGlobe.Filter.Comparison.LIKE                     = "~";
GeoGlobe.Filter.Comparison.IS_NULL                  = "NULL";

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Filter.Spatial
 * @classdesc 空间关系过滤器。
 *
 */
GeoGlobe.Filter.Spatial = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /**
     * 空间过滤器的类型

     * 该类型应该是以下之一：
     * - GeoGlobe.Filter.Spatial.BBOX
     * - GeoGlobe.Filter.Spatial.INTERSECTS
     * - GeoGlobe.Filter.Spatial.DWITHIN
     * - GeoGlobe.Filter.Spatial.WITHIN
     * - GeoGlobe.Filter.Spatial.CONTAINS
     * @memberof GeoGlobe.Filter.Spatial.prototype
     * @type {String}
     * @default null

     */
    type: null,
    
    /**
     * 要比较的上下文属性的名称
     * @memberof GeoGlobe.Filter.Spatial.prototype
     * @type {String}
     */
    property: null,
    
    /**

     * 过滤器使用的边界或几何图形。
     * 对INTERSECTS或DWITHIN过滤器使用BBOX过滤器和几何图形的边界。
     * @memberof GeoGlobe.Filter.Spatial.prototype
     *
     */
    value: null,

    /**
     * 在DWithin空间过滤器中使用的距离。
     * @memberof GeoGlobe.Filter.Spatial.prototype
     * @type {Number}

     */
    distance: null,

    /**
     * 单位用于距离的单位，例如'm'。
     * @memberof GeoGlobe.Filter.Spatial.prototype
     * @type {String}
     */
    distanceUnits: null,
    
    /** 

     * 创建一个空间过滤器。
     * @memberof GeoGlobe.Filter.Spatial.prototype
     * @param {Object}options -  一个可选对象，可在过滤器上设置属性。
     * 
     * @returns
     * {GeoGlobe.Filter.Spatial}
     */

   /**
    * 针对特定功能评估此过滤器。
    * @memberof GeoGlobe.Filter.Spatial.prototype
    * @param {GeoGlobe.Feature}feature -  应用在过滤器上的功能.
    * @returns
    * {Boolean} 该功是否符合过滤条件.
    */
    evaluate: function(feature) {
        var intersect = false;
        switch(this.type) {
            case GeoGlobe.Filter.Spatial.BBOX:
            case GeoGlobe.Filter.Spatial.INTERSECTS:
                if(feature.geometry) {
                    var geom = this.value;
                    if(this.value.CLASS_NAME == "GeoGlobe.LngLatBounds") {
                        geom = this.value.toGeometry();
                    }
                    if(feature.geometry.intersects(geom)) {
                        intersect = true;
                    }
                }
                break;
            default:
                throw new Error('evaluate is not implemented for this filter type.');
        }
        return intersect;
    },

    /**

     * 复制过滤器。
     * @memberof GeoGlobe.Filter.Spatial.prototype
     * @returns
     * {GeoGlobe.Filter.Spatial} 复制过滤器。
     */
    clone: function() {
        var options = GeoGlobe.Util.applyDefaults({
            value: this.value && this.value.clone && this.value.clone()
        }, this);
        return new GeoGlobe.Filter.Spatial(options);
    },
    CLASS_NAME: "GeoGlobe.Filter.Spatial"
});

GeoGlobe.Filter.Spatial.BBOX = "BBOX";
GeoGlobe.Filter.Spatial.INTERSECTS = "INTERSECTS";
GeoGlobe.Filter.Spatial.DWITHIN = "DWITHIN";
GeoGlobe.Filter.Spatial.WITHIN = "WITHIN";
GeoGlobe.Filter.Spatial.CONTAINS = "CONTAINS";

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 *  @memberof GeoGlobe.Filter.Function.prototype
 * @requires View2D/Filter/Filter.js
 */

/**
 * @class GeoGlobe.Filter.Function
 * @classdesc 这个类表示一个过滤器函数。
 * 我们使用这个类来创建可以包含过滤器函数作为值的复杂过滤器。
 * 支持将函数作为其他函数参数来使用。
 */
GeoGlobe.Filter.Function = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /**
     *  函数名称
     * @memberof GeoGlobe.Filter.Function.prototype
     * @type {String}
     */
    name: null,
    
    /**
     * @memberof GeoGlobe.Filter.Function.prototype
     * @param {Array()}  params
     * 函数参数
     * 现在仅支持其他函数，字符串或数字
     */
    params: null,  
    
    /** 

     * 创造一个过滤器函数。
     * @memberof GeoGlobe.Filter.Function.prototype
     * @param {Object}options -  具有可在函数上设置的属性的可选对象。
     * 
     * @returns
     * {GeoGlobe.Filter.Function}
     */

    CLASS_NAME: "GeoGlobe.Filter.Function"
});


/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Protocol
 * @classdesc Abstract vector layer protocol class.  Not to be instantiated directly.  Use one of the protocol subclasses instead.
 * @private
 */
GeoGlobe.Protocol = GeoGlobe.Class4OL({
    
    /**
     * The format used by this protocol.
     * @memberof GeoGlobe.Protocol.prototype
     *  @type {GeoGlobe.Format}
     */
    format: null,
    
    /**
     *  Any options sent to the constructor.
     *  @memberof GeoGlobe.Protocol.prototype
     *   @type {Object}
     */
    options: null,

    /**
     * The creator of the protocol can set autoDestroy to false
     *      to fully control when the protocol is destroyed. Defaults to true.
     * @memberof GeoGlobe.Protocol.prototype
     * @type {Boolean}
     */
    autoDestroy: true,
   
    /**
     *  Optional default filter to read requests
     *  @memberof GeoGlobe.Protocol.prototype
     *  @type {GeoGlobe.Filter}
     */
    defaultFilter: null,
    
    /**
     * @memberof GeoGlobe.Protocol.prototype
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     */
    initialize: function(options) {
        options = options || {};
        GeoGlobe.Util.extend(this, options);
        this.options = options;
    },

    /**
     *  Merge filter passed to the read method with the default one
     * @memberof GeoGlobe.Protocol.prototype
     * @param {GeoGlobe.Filter} filter
     */
    mergeWithDefaultFilter: function(filter) {
        var merged;
        if (filter && this.defaultFilter) {
            merged = new GeoGlobe.Filter.Logical({
                type: GeoGlobe.Filter.Logical.AND,
                filters: [this.defaultFilter, filter]
            });
        } else {
            merged = filter || this.defaultFilter || undefined;
        }
        return merged;
    },

    /**
     *
     * Clean up the protocol.
     *  @memberof GeoGlobe.Protocol.prototype
     */
    destroy: function() {
        this.options = null;
        this.format = null;
    },
    
    /**
     * Construct a request for reading new features.
     * @memberof GeoGlobe.Protocol.prototype
     * @param {Object} options  - Optional object for configuring the request.
     *
     * @returns {GeoGlobe.Protocol.Response}  - An GeoGlobe.Protocol.Response object,
     * the same object will be passed to the callback function passed if one exists in the options object.
     */
    read: function(options) {
        options = options || {};
        options.filter = this.mergeWithDefaultFilter(options.filter);
    },
    
    
    /**
     * Construct a request for writing newly created features.
     * @memberof GeoGlobe.Protocol.prototype
     * @param  {Array({GeoGlobe.Feature})} or {GeoGlobe.Feature} features
     * @param {Object} options   -  Optional object for configuring the request.
     *
     * @returns {GeoGlobe.Protocol.Response}   - An GeoGlobe.Protocol.Response
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    create: function() {
    },
    
    /**
     * Construct a request updating modified features.
     * @memberof GeoGlobe.Protocol.prototype
     * @param  {Array({GeoGlobe.Feature})} or {GeoGlobe.Feature.Vector}  features
     * @param {Object} options  - Optional object for configuring the request.
     *
     * @returns {GeoGlobe.Protocol.Response}  - An GeoGlobe.Protocol.Response
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    update: function() {
    },
    
    /**
     * Construct a request deleting a removed feature.
     * @memberof GeoGlobe.Protocol.prototype
     * @param {GeoGlobe.Feature} feature
     * @param {Object} options  - Optional object for configuring the request.
     *
     * @returns {GeoGlobe.Protocol.Response}  - An GeoGlobe.Protocol.Response
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    "delete": function() {
    },

    /**
     * Go over the features and for each take action
     *       based on the feature state. Possible actions are create, update and delete.
     * @memberof GeoGlobe.Protocol.prototype
     * @param {Array({GeoGlobe.Feature})} features
     * @param {Object} options  - Object whose possible keys are "create", "update",
     *      "delete", "callback" and "scope", the values referenced by the
     *      first three are objects as passed to the "create", "update", and
     *      "delete" methods, the value referenced by the "callback" key is
     *      a function which is called when the commit operation is complete
     *      using the scope referenced by the "scope" key.
     *
     * @returns {Array({GeoGlobe.Protocol.Response})}  - An array of GeoGlobe.Protocol.Response objects.
     */
    commit: function() {
    },

    /**
     * Abort an ongoing request.
     * @memberof GeoGlobe.Protocol.prototype
     * @param {GeoGlobe.Protocol.Response} response
     */
    abort: function(response) {
    },
   
    /**
     *  Returns a function that applies the given public method with resp an options arguments.
     * @memberof GeoGlobe.Protocol.prototype
     * @param {Function} method  - The method to be applied by the callback.
     * @param {GeoGlobe.Protocol.Response} response  - The protocol response object.
     * @param {Object} options  - Options sent to the protocol method
     */
    createCallback: function(method, response, options) {
        return GeoGlobe.Function.bind(function() {
            method.apply(this, [response, options]);
        }, this);
    },
   
    CLASS_NAME: "GeoGlobe.Protocol" 
});

/**
 * @class GeoGlobe.Protocol.Response
 * @classdesc Protocols return Response objects to their users.
 * @private
 */
GeoGlobe.Protocol.Response = GeoGlobe.Class4OL({
    /**
     *  GeoGlobe.Protocol.Response.SUCCESS or GeoGlobe.Protocol.Response.FAILURE
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @type {Number}
     */
    code: null,

    /**
     * The type of request this response corresponds to.Either "create", "read", "update" or "delete".
     *  @memberof GeoGlobe.Protocol.Response.prototype
     * @type {String}
     */
    requestType: null,

    /**
     * true if this is the last response expected in a commit,false otherwise, defaults to true.
     *@memberof GeoGlobe.Protocol.Response.prototype
     *  @type {Boolaen}
     */
    last: true,

    /**
     * The features returned in the response by the server. Depending on the
     * protocol's read payload, either features or data will be populated.
     *  @memberof GeoGlobe.Protocol.Response.prototype
     * @type {{Array(GeoGlobe.Feature)} | {GeoGlobe.Feature}}
     */
    features: null,

    /**
     * The data returned in the response by the server. Depending on the
     * protocol's read payload, either features or data will be populated.
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @type {Object}
     */
    data: null,

    /**
     *  The features provided by the user and placed in the request by the protocol.
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @type {{Array(GeoGlobe.Feature)} | {GeoGlobe.Feature}}
     */
    reqFeatures: null,

    /**
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @type {Object}
     */
    priv: null,

    /**
     * The error object in case a service exception was encountered.
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @type {Object}
     */
    error: null,

    /**
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     */
    initialize: function(options) {
        GeoGlobe.Util.extend(this, options);
    },

    /**
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @returns {Boolean} - true on success, false otherwise
     */
    success: function() {
        return this.code > 0;
    },

    CLASS_NAME: "GeoGlobe.Protocol.Response"
});

GeoGlobe.Protocol.Response.SUCCESS = 1;
GeoGlobe.Protocol.Response.FAILURE = 0;

/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * if application uses the query string, for example, for BBOX parameters,
 * GeoGlobe/Format/QueryStringFilter.js should be included in the build config file
 */

/**
 * @class GeoGlobe.Protocol.HTTP
 * @classdesc  A basic HTTP protocol for vector layers.  Create a new instance with the
 *     GeoGlobe.Protocol.HTTP constructor.Inherits from GeoGlobe.Protocol
 * @private
 */
GeoGlobe.Protocol.HTTP = GeoGlobe.Class4OL(GeoGlobe.Protocol, {

    /**
     *  Service URL, read-only, set through the options passed to constructor.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     *  @type {String}
     */
    url: null,

    /**
     * HTTP request headers, read-only, set through the options passed to the constructor
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @type {Object}
     *
     * @example
     * {'Content-Type': 'plain/text'}
     */
    headers: null,

    /**
     *  Parameters of GET requests, read-only, set through the options passed to the constructor,
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     *  @type {Object}
     *
     * @example
     * {'bbox': '5,5,5,5'}
     */
    params: null,
    
    /**
     * Function to be called when the {read}, {create},
     *     {update}, {delete} or {commit} operation completes, read-only,
     *     set through the options passed to the constructor.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @type {Object}
     */
    callback: null,

    /**
     *  Callback execution scope,read-only,set through the options passed to the constructor.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @type {Object}
     *
     */
    scope: null,

    /**
     * true if read operations are done with POST requests instead of GET, defaults to false.
     *  @memberof GeoGlobe.Protocol.HTTP.prototype
     *  @type {Boolaen}
     */
    readWithPOST: false,

    /**
     * true if update operations are done with POST requests defaults to false.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @type {Boolaen}
     */
    updateWithPOST: false,
    
    /**
     * true if delete operations are done with POST requests defaults to false. if true, POST data is set to output of format.write().
     *  @memberof GeoGlobe.Protocol.HTTP.prototype
     *  @type {Boolaen}
     */
    deleteWithPOST: false,

    /**
     * If true percent signs are added around values
     *     read from LIKE filters, for example if the protocol
     *     read method is passed a LIKE filter whose property
     *     is "foo" and whose value is "bar" the string
     *     "foo__ilike=%bar%" will be sent in the query string;
     *     defaults to false.
     *  @memberof GeoGlobe.Protocol.HTTP.prototype
     *  @type {Boolaen}
     */
    wildcarded: false,

    /**
     * Include the SRS identifier in BBOX query string parameter.
     *     Default is false.  If true and the layer has a projection object set,
     *     any BBOX filter will be serialized with a fifth item identifying the
     *     projection.  E.g. bbox=-1000,-1000,1000,1000,EPSG:900913
     *  @memberof GeoGlobe.Protocol.HTTP.prototype
     *  @type {Boolaen}
     */
    srsInBBOX: false,

    /**
     *  A class for giving layers generic HTTP protocol.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     *
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     * @param {String} url
     * @param {Object} headers
     * @param {Object} params  - URL parameters for GET requests
     * @param {GeoGlobe.Format} format
     * @param {Function} callback
     * @param {Object} scope
     */
    initialize: function(options) {
        options = options || {};
        this.params = {};
        this.headers = {};
        GeoGlobe.Protocol.prototype.initialize.apply(this, arguments);

        if (!this.filterToParams && GeoGlobe.Format.QueryStringFilter) {
            var format = new GeoGlobe.Format.QueryStringFilter({
                wildcarded: this.wildcarded,
                srsInBBOX: this.srsInBBOX
            });
            this.filterToParams = function(filter, params) {
                return format.write(filter, params);
            };
        }
    },
    
    /**
     * Clean up the protocol.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     *
     */
    destroy: function() {
        this.params = null;
        this.headers = null;
        GeoGlobe.Protocol.prototype.destroy.apply(this);
    },

    /**
     * Optional method to translate an {GeoGlobe.Filter} object into an object
     *     that can be serialized as request query string provided.  If a custom
     *     method is not provided, the filter will be serialized using the 
     *     {GeoGlobe.Format.QueryStringFilter} class.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     *
     * @param {GeoGlobe.Filter} filter   - filter to convert.
     * @param  {Object} params  - The parameters object.
     *
     * @returns {Object}  - The resulting parameters object.
     */
    
    /**
     * Construct a request for reading new features.
     *  @memberof GeoGlobe.Protocol.HTTP.prototype
     *
     * @param  {Object} options  - Optional object for configuring the request.
     *     This object is modified and should not be reused.
     * @param {String} url  - Url for the request.
     * @param {Object} params  - Parameters to get serialized as a query string.
     * @param {Object} headers  - Headers to be set on the request.
     * @param {GeoGlobe.Filter} filter  -  Filter to get serialized as a query string.
     * @param {Boolean} readWithPOST  - If the request should be done with POST.
     *
     * @returns {GeoGlobe.Protocol.Response}  - A response object, whose "priv" property
     *     references the HTTP request, this object is also passed to the
     *     callback function when the request completes, its "features" property
     *     is then populated with the features received from the server.
     */
    read: function(options) {
        GeoGlobe.Protocol.prototype.read.apply(this, arguments);
        options = options || {};
        options.params = GeoGlobe.Util.applyDefaults(
            options.params, this.options.params);
        options = GeoGlobe.Util.applyDefaults(options, this.options);
        if (options.filter && this.filterToParams) {
            options.params = this.filterToParams(
                options.filter, options.params
            );
        }
        var readWithPOST = (options.readWithPOST !== undefined) ?
                           options.readWithPOST : this.readWithPOST;
        var resp = new GeoGlobe.Protocol.Response({requestType: "read"});
        if(readWithPOST) {
            var headers = options.headers || {};
            headers["Content-Type"] = "application/x-www-form-urlencoded";
            resp.priv = GeoGlobe.Request.POST({
                url: options.url,
                callback: this.createCallback(this.handleRead, resp, options),
                data: GeoGlobe.Util.getParameterString(options.params),
                headers: headers
            });
        } else {
            resp.priv = GeoGlobe.Request.GET({
                url: options.url,
                callback: this.createCallback(this.handleRead, resp, options),
                params: options.params,
                headers: options.headers
            });
        }
        return resp;
    },

    /**
     * Individual callbacks are created for read, create and update, should a subclass need to override each one separately.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} resp  - The response object to pass to the user callback.
     * @param {Object}   - The user options passed to the read call.
     */
    handleRead: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * Construct a request for writing newly created features.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {Array({GeoGlobe.Feature.Vector})} or {GeoGlobe.Feature.Vector} features
     * @param {Object} options  - Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * @returns {GeoGlobe.Protocol.Response}
     * - An {GeoGlobe.Protocol.Response}
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes, its "features" property is then populated with the
     *     the features received from the server.
     */
    create: function(features, options) {
        options = GeoGlobe.Util.applyDefaults(options, this.options);

        var resp = new GeoGlobe.Protocol.Response({
            reqFeatures: features,
            requestType: "create"
        });

        resp.priv = GeoGlobe.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleCreate, resp, options),
            headers: options.headers,
            data: this.format.write(features)
        });

        return resp;
    },

    /**
     * Called the the request issued by <create> is complete.  May be overridden by subclasses.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} resp  - The response object to pass to any user callback.
     * @param {Object} options  - The user options passed to the create call.
     */
    handleCreate: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * Construct a request updating modified feature.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Feature.Vector} feature
     * @param {Object} options  - Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * @returns {GeoGlobe.Protocol.Response}  - An GeoGlobe.Protocol.Response
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes, its "features" property is then populated with the
     *     the feature received from the server.
     */
    update: function(feature, options) {
        options = options || {};
        var url = options.url ||
                  feature.url ||
                  this.options.url + "/" + feature.fid;
        options = GeoGlobe.Util.applyDefaults(options, this.options);

        var resp = new GeoGlobe.Protocol.Response({
            reqFeatures: feature,
            requestType: "update"
        });

        var method = this.updateWithPOST ? "POST" : "PUT";
        resp.priv = GeoGlobe.Request[method]({
            url: url,
            callback: this.createCallback(this.handleUpdate, resp, options),
            headers: options.headers,
            data: this.format.write(feature)
        });

        return resp;
    },

    /**
     * Called the the request issued by update is complete.  May be overridden by subclasses.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} resp  - The response object to pass to any user callback.
     * @param {Object} options  - The user options passed to the update call.
     */
    handleUpdate: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * Construct a request deleting a removed feature.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Feature.Vector} feature
     * @param {Object} options  - Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * @returns {GeoGlobe.Protocol.Response}  - An {GeoGlobe.Protocol.Response}
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes.
     */
    "delete": function(feature, options) {
        options = options || {};
        var url = options.url ||
                  feature.url ||
                  this.options.url + "/" + feature.fid;
        options = GeoGlobe.Util.applyDefaults(options, this.options);

        var resp = new GeoGlobe.Protocol.Response({
            reqFeatures: feature,
            requestType: "delete"
        });

        var method = this.deleteWithPOST ? "POST" : "DELETE";
        var requestOptions = {
            url: url,
            callback: this.createCallback(this.handleDelete, resp, options),
            headers: options.headers
        };
        if (this.deleteWithPOST) {
            requestOptions.data = this.format.write(feature);
        }
        resp.priv = GeoGlobe.Request[method](requestOptions);

        return resp;
    },

    /**
     * Called the the request issued by delete is complete.  May be overridden by subclasses.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} resp  - The response object to pass to any user callback.
     * @param {Object} options  - The user options passed to the delete call.
     */
    handleDelete: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * Called by CRUD specific handlers.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} resp  -  The response object to pass to any user callback.
     * @param {Object} options  - The user options passed to the create, read, update, or delete call.
     */
    handleResponse: function(resp, options) {
        var request = resp.priv;
        if(options.callback) {
            if(request.status >= 200 && request.status < 300) {
                // success
                if(resp.requestType != "delete") {
                    resp.features = this.parseFeatures(request);
                }
                resp.code = GeoGlobe.Protocol.Response.SUCCESS;
            } else {
                // failure
                resp.code = GeoGlobe.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, resp);
        }
    },

    /**
     * Read HTTP response body and return features.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {XMLHttpRequest} request  - The request object
     *
     * @returns {Array({GeoGlobe.Feature.Vector})} or {GeoGlobe.Feature.Vector}
     *  - Array of features or a single feature.
     */
    parseFeatures: function(request) {
        var doc = request.responseXML;
        if (!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if (!doc || doc.length <= 0) {
            return null;
        }
        return this.format.read(doc);
    },

    /**
     *  Iterate over each feature and take action based on the feature state.
     *     Possible actions are create, update and delete.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {Array({GeoGlobe.Feature.Vector})} features
     * @param {Object} options   - Optional object for setting up intermediate commit callbacks.
     * @param {Object} create   -  Optional object to be passed to the <create> method.
     * @param {Object} update  - Optional object to be passed to the <update> method.
     * @param {Object} delete  - Optional object to be passed to the <delete> method.
     * @param {Function} callback  - Optional function to be called when the commit is complete.
     * @param  {Object} scope  -  Optional object to be set as the scope of the callback.
     *
     * @returns {Array(GeoGlobe.Protocol.Response)}  - An array of response objects,
     *     one per request made to the server, each object's "priv" property
     *     references the corresponding HTTP request.
     */
    commit: function(features, options) {
        options = GeoGlobe.Util.applyDefaults(options, this.options);
        var resp = [], nResponses = 0;
        
        // Divide up features before issuing any requests.  This properly
        // counts requests in the event that any responses come in before
        // all requests have been issued.
        var types = {};
        types[GeoGlobe.State.INSERT] = [];
        types[GeoGlobe.State.UPDATE] = [];
        types[GeoGlobe.State.DELETE] = [];
        var feature, list, requestFeatures = [];
        for(var i=0, len=features.length; i<len; ++i) {
            feature = features[i];
            list = types[feature.state];
            if(list) {
                list.push(feature);
                requestFeatures.push(feature); 
            }
        }
        // tally up number of requests
        var nRequests = (types[GeoGlobe.State.INSERT].length > 0 ? 1 : 0) +
            types[GeoGlobe.State.UPDATE].length +
            types[GeoGlobe.State.DELETE].length;
        
        // This response will be sent to the final callback after all the others
        // have been fired.
        var success = true;
        var finalResponse = new GeoGlobe.Protocol.Response({
            reqFeatures: requestFeatures        
        });
        
        function insertCallback(response) {
            var len = response.features ? response.features.length : 0;
            var fids = new Array(len);
            for(var i=0; i<len; ++i) {
                fids[i] = response.features[i].fid;
            }   
            finalResponse.insertIds = fids;
            callback.apply(this, [response]);
        }
 
        function callback(response) {
            this.callUserCallback(response, options);
            success = success && response.success();
            nResponses++;
            if (nResponses >= nRequests) {
                if (options.callback) {
                    finalResponse.code = success ?
                        GeoGlobe.Protocol.Response.SUCCESS :
                        GeoGlobe.Protocol.Response.FAILURE;
                    options.callback.apply(options.scope, [finalResponse]);
                }    
            }
        }

        // start issuing requests
        var queue = types[GeoGlobe.State.INSERT];
        if(queue.length > 0) {
            resp.push(this.create(
                queue, GeoGlobe.Util.applyDefaults(
                    {callback: insertCallback, scope: this}, options.create
                )
            ));
        }
        queue = types[GeoGlobe.State.UPDATE];
        for(var i=queue.length-1; i>=0; --i) {
            resp.push(this.update(
                queue[i], GeoGlobe.Util.applyDefaults(
                    {callback: callback, scope: this}, options.update
                ))
            );
        }
        queue = types[GeoGlobe.State.DELETE];
        for(var i=queue.length-1; i>=0; --i) {
            resp.push(this["delete"](
                queue[i], GeoGlobe.Util.applyDefaults(
                    {callback: callback, scope: this}, options["delete"]
                ))
            );
        }
        return resp;
    },

    /**
     * Abort an ongoing request, the response object passed to
     *      this method must come from this HTTP protocol (as a result
     *      of a create, read, update, delete or commit operation).
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} response
     */
    abort: function(response) {
        if (response) {
            response.priv.abort();
        }
    },

    /**
     *  This method is used from within the commit method each time an
     *     an HTTP response is received from the server, it is responsible
     *     for calling the user-supplied callbacks.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} resp
     * @param {Object} options  - The map of options passed to the commit call.
     */
    callUserCallback: function(resp, options) {
        var opt = options[resp.requestType];
        if(opt && opt.callback) {
            opt.callback.call(opt.scope, resp);
        }
    },

    CLASS_NAME: "GeoGlobe.Protocol.HTTP"
});

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Protocol.WFS
 * @classdesc Used to create a versioned WFS protocol.  Default version is 1.0.0.
 *
 * @returns {GeoGlobe.Protocol}  - A WFS protocol of the given version.
 *
 * @example
 *     var protocol = new GeoGlobe.Protocol.WFS({
 *         version: "1.1.0",
 *         url:  "http://demo.opengeo.org/geoserver/wfs",
 *         featureType: "tasmania_roads",
 *         featureNS: "http://www.openplans.org/topp",
 *         geometryName: "the_geom"
 *     });
 * (end)
 *
 * See the protocols for specific WFS versions for more detail.
 * @private
 */

GeoGlobe.Protocol.WFS = function(options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Protocol.WFS.DEFAULTS
    );
    var cls = GeoGlobe.Protocol.WFS["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported WFS version: " + options.version;
    }
    return new cls(options);
};

/**
 * GeoGlobe.Protocol.WFS.DEFAULTS
 *  @memberof GeoGlobe.Protocol.WFS.prototype
 */
GeoGlobe.Protocol.WFS.DEFAULTS = {
    "version": "1.0.0"
};

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Protocol.WFS.v1
 * @classdesc Abstract class for for v1.0.0 and v1.1.0 protocol.Inherits from: GeoGlobe.Protocol
 * @private
 */
GeoGlobe.Protocol.WFS.v1 = GeoGlobe.Class4OL(GeoGlobe.Protocol, {
    
    /**
     * WFS version number.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    version: null,
    
    /**
     * Name of spatial reference system.  Default is "EPSG:4326".
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    srsName: "EPSG:4326",
    
    /**
     *  Local feature typeName.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    featureType: null,
    
    /**
     *  Feature namespace.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    featureNS: null,
    
    /**
     * Name of the geometry attribute for features.  Default is "the_geom" for WFS version 1.0, and null for higher versions.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    geometryName: "the_geom",

    /**
     * Optional maximum number of features to retrieve.
     *  @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {Integer}
     */
    
    /**
     * Optional schema location that will be included in the
     *     schemaLocation attribute value.  Note that the feature type schema
     *     is required for a strict XML validator (on transactions with an
     *     insert for example), but is *not* required by the WFS specification
     *     (since the server is supposed to know about feature type schemas).
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    schema: null,

    /**
     * Namespace alias for feature type.  Default is "feature".
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    featurePrefix: "feature",
    
    /**
     * Optional options for the format.  If a format is not provided,this property can be used to extend the default format options.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {Object}
     */
    formatOptions: null,

    /** 
     * For WFS requests it is possible to get a
     *     different output format than GML. In that case, we cannot parse  
     *     the response with the default format (WFST) and we need a different format for reading.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {GeoGlobe.Format}
     */ 
    readFormat: null,
    
    /**
     * Optional object to pass to format's read.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {Object}
     */
    readOptions: null,
    
    /**
     * A class for giving layers WFS protocol.
     *  @memberof GeoGlobe.Protocol.WFS.v1.prototype
     *
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     *
     * @param {String} url  - URL to send requests to (required).
     * @param {String} featureType  - Local (without prefix) feature typeName (required).
     * @param {String} featureNS  - Feature namespace (required, but can be autodetected
     *     during the first query if GML is used as readFormat and
     *     featurePrefix is provided and matches the prefix used by the server
     *     for this featureType).
     * @param {String} featurePrefix  - Feature namespace alias (optional - only used
     *     for writing if featureNS is provided).  Default is 'feature'.
     * @param {String} geometryName  - Name of geometry attribute.  The default is
     *     'the_geom' for WFS version 1.0, and null for higher versions. If
     *     null, it will be set to the name of the first geometry found in the
     *     first read operation.
     * @param {Boolean} multi  - If set to true, geometries will be casted to Multi
     *     geometries before they are written in a transaction. No casting will
     *     be done when reading features.
     */
    initialize: function(options) {
        GeoGlobe.Protocol.prototype.initialize.apply(this, [options]);
        if(!options.format) {
            this.format = GeoGlobe.Format.WFST(GeoGlobe.Util.extend({
                version: this.version,
                featureType: this.featureType,
                featureNS: this.featureNS,
                featurePrefix: this.featurePrefix,
                geometryName: this.geometryName,
                srsName: this.srsName,
                schema: this.schema
            }, this.formatOptions));
        }
        if (!options.geometryName && parseFloat(this.format.version) > 1.0) {
            this.setGeometryName(null);
        }
    },
    
    /**
     *  Clean up the protocol.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     *
     */
    destroy: function() {
        if(this.options && !this.options.format) {
            this.format.destroy();
        }
        this.format = null;
        GeoGlobe.Protocol.prototype.destroy.apply(this);
    },

    /**
     * Construct a request for reading new features.  Since WFS splits the
     *     basic CRUD operations into GetFeature requests (for read) and
     *     Transactions (for all others), this method does not make use of the
     *     format's read method (that is only about reading transaction responses).
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     *
     * @param {Object} options  - Options for the read operation, in addition to the
     *     options set on the instance (options set here will take precedence).
     *
     * @example
     * To use a configured protocol to get e.g. a WFS hit count, applications
     * could do the following:
     *
     * (code)
     * protocol.read({
     *     readOptions: {output: "object"},
     *     resultType: "hits",
     *     maxFeatures: null,
     *     callback: function(resp) {
     *         // process resp.numberOfFeatures here
     *     }
     * });
     * (end)
     *
     * To use a configured protocol to use WFS paging (if supported by the
     * server), applications could do the following:
     *
     * (code)
     * protocol.read({
     *     startIndex: 0,
     *     count: 50
     * });
     * (end)
     *
     * To limit the attributes returned by the GetFeature request, applications
     * can use the propertyNames option to specify the properties to include in
     * the response:
     *
     * (code)
     * protocol.read({
     *     propertyNames: ["DURATION", "INTENSITY"]
     * });
     * (end)
     */
    read: function(options) {
        GeoGlobe.Protocol.prototype.read.apply(this, arguments);
        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options || {});
        var response = new GeoGlobe.Protocol.Response({requestType: "read"});
        
        var data = GeoGlobe.Format.XML.prototype.write.apply(
            this.format, [this.format.writeNode("wfs:GetFeature", options)]
        );

        response.priv = GeoGlobe.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleRead, response, options),
            params: options.params,
            headers: options.headers,
            data: data
        });

        return response;
    },

    /**
     * Change the feature type on the fly.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     *
     * @param {String} featureType  - Local (without prefix) feature typeName.
     */
    setFeatureType: function(featureType) {
        this.featureType = featureType;
        this.format.featureType = featureType;
    },
 
    /**
     * Sets the geometryName option after instantiation.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @param {String} geometryName  - Name of geometry attribute.
     */
    setGeometryName: function(geometryName) {
        this.geometryName = geometryName;
        this.format.geometryName = geometryName;
    },
    
    /**
     * Deal with response from the read request
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype.
     *
     * @param {GeoGlobe.Protocol.Response} response  - The response object to pass to the user callback.
     * @param {Object} options  - The user options passed to the read call.
     */
    handleRead: function(response, options) {
        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options);

        if(options.callback) {
            var request = response.priv;
            if(request.status >= 200 && request.status < 300) {
                // success
                var result = this.parseResponse(request, options.readOptions);
                if (result && result.success !== false) { 
                    if (options.readOptions && options.readOptions.output == "object") {
                        GeoGlobe.Util.extend(response, result);
                    } else {
                        response.features = result;
                    }
                    response.code = GeoGlobe.Protocol.Response.SUCCESS;
                } else {
                    // failure (service exception)
                    response.code = GeoGlobe.Protocol.Response.FAILURE;
                    response.error = result;
                }
            } else {
                // failure
                response.code = GeoGlobe.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Read HTTP response body and return features
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     *
     * @param {XMLHttpRequest} request  - The request object
     * @param  {Object} options  - Optional object to pass to format's read
     *
     * @returns {Object} or {Array({GeoGlobe.Feature})} or {GeoGlobe.Feature}
     *  - An object with a features property, an array of features or a single feature.
     */
    parseResponse: function(request, options) {
        var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc || doc.length <= 0) {
            return null;
        }
		
        //var result = (this.readFormat !== null) ? this.readFormat.read(doc) : 
        //    this.format.read(doc, options);
		var result=null;
        try{
        	result = (this.readFormat !== null) ? this.readFormat.read(doc) : 
            this.format.read(doc, options);
        }catch(e){
        	var error = "程序运行异常："+e.name + "，"+e.message;
        	alert(error);
        	//throw e;
        }
        if (!this.featureNS) {
            var format = this.readFormat || this.format;
            this.featureNS = format.featureNS;
            // no need to auto-configure again on subsequent reads
            format.autoConfig = false;
            if (!this.geometryName) {
                this.setGeometryName(format.geometryName);
            }
        }
        return result;
    },

    /**
     * Given a list of feature, assemble a batch request for update, create,
     *     and delete transactions.  A commit call on the prototype amounts
     *     to writing a WFS transaction - so the write method on the format
     *     is used.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @param {Array(GeoGlobe.Feature)} features
     * @param  {Object} options
     *
     * Array of objects with information for writing
     *      out Native elements, these objects have vendorId, safeToIgnore and
     *      value properties. The Native  element is intended to allow access to
     *      vendor specific capabilities of any particular web feature server or datastore.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {Array({Object})}
     *
     * @returns {GeoGlobe.Protocol.Response}   - A response object with a features
     *     property containing any insertIds and a property referencing the XMLHttpRequest object.
     */
    commit: function(features, options) {

        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options);
        
        var response = new GeoGlobe.Protocol.Response({
            requestType: "commit",
            reqFeatures: features
        });
        response.priv = GeoGlobe.Request.POST({
            url: options.url,
            headers: options.headers,
            data: this.format.write(features, options),
            callback: this.createCallback(this.handleCommit, response, options)
        });
        
        return response;
    },
    
    /**
     * Called when the commit request returns.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @param {GeoGlobe.Protocol.Response} response   - The response object to pass to the user callback.
     * @param {Object} options  - The user options passed to the commit call.
     */
    handleCommit: function(response, options) {
        if(options.callback) {
            var request = response.priv;

            // ensure that we have an xml doc
            var data = request.responseXML;
            if(!data || !data.documentElement) {
                data = request.responseText;
            }
            
            var obj = this.format.read(data) || {};
            
            response.insertIds = obj.insertIds || [];
            if (obj.success) {
                response.code = GeoGlobe.Protocol.Response.SUCCESS;
            } else {
                response.code = GeoGlobe.Protocol.Response.FAILURE;
                response.error = obj;
            }
            options.callback.call(options.scope, response);
        }
    },
    
    /**
     * Send a request that deletes all features by their filter.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * 
     * @param {GeoGlobe.Filter} filter  - filter
     */
    filterDelete: function(filter, options) {
        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options);    
        
        var response = new GeoGlobe.Protocol.Response({
            requestType: "commit"
        });    
        
        var root = this.format.createElementNSPlus("wfs:Transaction", {
            attributes: {
                service: "WFS",
                version: this.version
            }
        });
        
        var deleteNode = this.format.createElementNSPlus("wfs:Delete", {
            attributes: {
                typeName: (options.featureNS ? this.featurePrefix + ":" : "") +
                    options.featureType
            }
        });       
        
        if(options.featureNS) {
            deleteNode.setAttribute("xmlns:" + this.featurePrefix, options.featureNS);
        }
        var filterNode = this.format.writeNode("ogc:Filter", filter);
        
        deleteNode.appendChild(filterNode);
        
        root.appendChild(deleteNode);
        
        var data = GeoGlobe.Format.XML.prototype.write.apply(
            this.format, [root]
        );
        
        return GeoGlobe.Request.POST({
            url: this.url,
            callback : options.callback || function(){},
            data: data
        });   
        
    },

    /**
     * Abort an ongoing request, the response object passed to
     * this method must come from this protocol (as a result of a read, or commit operation).
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @param {GeoGlobe.Protocol.Response} response
     */
    abort: function(response) {
        if (response) {
            response.priv.abort();
        }
    },
  
    CLASS_NAME: "GeoGlobe.Protocol.WFS.v1" 
});

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @class GeoGlobe.Protocol.WFS.v1_0_0
 * @classdesc  A WFS v1.0.0 protocol for vector layers.  Create a new instance with the
 *     GeoGlobe.Protocol.WFS.v1_0_0 constructor.Inherits from:GeoGlobe.Protocol.WFS.v1
 * @private
 */
GeoGlobe.Protocol.WFS.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Protocol.WFS.v1, {
    
    /**
     * WFS version number.
     * @memberof GeoGlobe.Protocol.WFS.v1_0_0.prototype
     * @type {String}
     */
    version: "1.0.0",
    
    /**
     * A class for giving layers WFS v1.0.0 protocol.
     * @memberof GeoGlobe.Protocol.WFS.v1_0_0.prototype
     *
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     *
     * @param {String} featureType  - Local (without prefix) feature typeName (required).
     * @param featureNS  - Feature namespace (optional).
     * @param {String}  featurePrefix  - Feature namespace alias (optional - only used
     *     if featureNS is provided).  Default is 'feature'.
     * @param {String} geometryName  - Name of geometry attribute.  Default is 'the_geom'.
     */
   
    CLASS_NAME: "GeoGlobe.Protocol.WFS.v1_0_0" 
});

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Protocol.WFS.v1_1_0
 * @classdesc A WFS v1.1.0 protocol for vector layers.  Create a new instance with the
 *     GeoGlobe.Protocol.WFS.v1_1_0 constructor.Inherits from:GeoGlobe.Protocol.WFS.v1
 * @private
 *  Differences from the v1.0.0 protocol:
 *  - uses Filter Encoding 1.1.0 instead of 1.0.0
 *  - uses GML 3 instead of 2 if no format is provided
 */
GeoGlobe.Protocol.WFS.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Protocol.WFS.v1, {
    
    /**
     * WFS version number.
     * @memberof GeoGlobe.Protocol.WFS.v1_1_0.prototype
     * @type {String}
     */
    version: "1.1.0",
    
    /**
     * A class for giving layers WFS v1.1.0 protocol.
     * @memberof GeoGlobe.Protocol.WFS.v1_1_0.prototype
     *
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     *
     * @param {String} featureType  - Local (without prefix) feature typeName (required).
     * @param {String} featureNS  - Feature namespace (optional).
     * @param {String} featurePrefix  - Feature namespace alias (optional - only used
     *     if featureNS is provided).  Default is 'feature'.
     * @param {String} geometryName  - Name of geometry attribute.  Default is 'the_geom'.
     * @param {String} outputFormat  - Optional output format to use for WFS GetFeature
     *     requests. This can be any format advertized by the WFS's
     *     GetCapabilities response. If set, an appropriate readFormat also
     *     has to be provided, unless outputFormat is GML3, GML2 or JSON.
     * @param {GeoGlobe.Format}  readFormat  - An appropriate format parser if
     *     outputFormat is none of GML3, GML2 or JSON.
     */
    initialize: function(options) {
        GeoGlobe.Protocol.WFS.v1.prototype.initialize.apply(this, arguments);
        if (this.outputFormat && !this.readFormat) {
            if (this.outputFormat.toLowerCase() == "gml2") {
                this.readFormat = new GeoGlobe.Format.GML.v2({
                    featureType: this.featureType,
                    featureNS: this.featureNS,
                    geometryName: this.geometryName
                });
            } else if (this.outputFormat.toLowerCase() == "json") {
                this.readFormat = new GeoGlobe.Format.GeoJSON();
            }
        }
    },
   
    CLASS_NAME: "GeoGlobe.Protocol.WFS.v1_1_0"
});

/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @class GeoGlobe.Protocol.CSW
 * @classdesc Used to create a versioned CSW protocol. Default version is 2.0.2.
 * @private
 */
GeoGlobe.Protocol.CSW = function(options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Protocol.CSW.DEFAULTS
    );
    var cls = GeoGlobe.Protocol.CSW["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported CSW version: " + options.version;
    }
    return new cls(options);
};

/**
 * @memberof GeoGlobe.Popup.prototype
 */
GeoGlobe.Protocol.CSW.DEFAULTS = {
    "version": "2.0.2"
};

/**
 * @class GeoGlobe.Protocol.CSW.v2_0_2
 * @classdesc CS-W (Catalogue services for the Web) version 2.0.2 protocol.Inherits from GeoGlobe.Protocol
 * @private
 */
GeoGlobe.Protocol.CSW.v2_0_2 = GeoGlobe.Class4OL(GeoGlobe.Protocol, {

    /**
     * Optional options for the format.  If a format is not provided,this property can be used to extend the default format options.
     * @memberof GeoGlobe.Protocol.CSW.v2_0_2.prototype
     * @type {Object}
     */
    formatOptions: null,

    /**
     * A class for CSW version 2.0.2 protocol management.
     * @memberof GeoGlobe.Protocol.CSW.v2_0_2.prototype
     * @param {Object} options  -  Optional object whose properties will be set on the instance.
     */
    initialize: function(options) {
        GeoGlobe.Protocol.prototype.initialize.apply(this, [options]);
        if(!options.format) {
            this.format = new GeoGlobe.Format.CSWGetRecords.v2_0_2(GeoGlobe.Util.extend({
            }, this.formatOptions));
        }
    },

    /**
     * destroy  - Clean up the protocol.
     *  @memberof GeoGlobe.Protocol.CSW.v2_0_2.prototype
     */
    destroy: function() {
        if(this.options && !this.options.format) {
            this.format.destroy();
        }
        this.format = null;
        GeoGlobe.Protocol.prototype.destroy.apply(this);
    },

    /**
     * Construct a request for reading new records from the Catalogue.
     * @memberof GeoGlobe.Protocol.CSW.v2_0_2.prototype
     */
    read: function(options) {
        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options || {});
        var response = new GeoGlobe.Protocol.Response({requestType: "read"});

        var data = this.format.write(options.params || options);

        response.priv = GeoGlobe.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleRead, response, options),
            params: options.params,
            headers: options.headers,
            data: data
        });

        return response;
    },

    /**
     *  Deal with response from the read request.
     * @memberof GeoGlobe.Protocol.CSW.v2_0_2.prototype
     *
     * @param {GeoGlobe.Protocol.Response} response  - The response object to pass to the user callback.
     *     This response is given a code property, and optionally a data property.
     *     The latter represents the CSW records as returned by the call to
     *     the CSW format read method.
     * @param {Object} options  - The user options passed to the read call.
     */
    handleRead: function(response, options) {
        if(options.callback) {
            var request = response.priv;
            if(request.status >= 200 && request.status < 300) {
                // success
                response.data = this.parseData(request);
                response.code = GeoGlobe.Protocol.Response.SUCCESS;
            } else {
                // failure
                response.code = GeoGlobe.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Read HTTP response body and return records
     * @memberof GeoGlobe.Protocol.CSW.v2_0_2.prototype
     * @param  {XMLHttpRequest} request  -  The request object
     *
     * @returns {Object}  - The CSW records as returned by the call to the format read method.
     */
    parseData: function(request) {
        var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc || doc.length <= 0) {
            return null;
        }
        return this.format.read(doc);
    },

    CLASS_NAME: "GeoGlobe.Protocol.CSW.v2_0_2"

});

/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */


/**
 * if application uses the query string, for example, for BBOX parameters,
 * GeoGlobe/Format/QueryStringFilter.js should be included in the build config file
 */

/**
 * @class  GeoGlobe.Protocol.Script
 * @classdesc A basic Script protocol for vector layers.  Create a new instance with the
 *     GeoGlobe.Protocol.Script constructor.  A script protocol is used to
 *     get around the same origin policy.  It works with services that return
 *     JSONP - that is, JSON wrapped in a client-specified callback.  The
 *     protocol handles fetching and parsing of feature data and sends parsed
 *     features to the <callback> configured with the protocol.  The protocol
 *     expects features serialized as GeoJSON by default, but can be configured
 *     to work with other formats by setting the <format> property.Inherits from GeoGlobe.Protocol
 * @private
 */
GeoGlobe.Protocol.Script = GeoGlobe.Class4OL(GeoGlobe.Protocol, {

    /**
     * Service URL.
     *
     * The service is expected to return serialized
     *     features wrapped in a named callback (where the callback name is
     *     generated by this protocol).
     *     Read-only, set through the options passed to the constructor.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @type {String}
     */
    url: null,

    /**
     * Query string parameters to be appended to the URL.Read-only, set through the options passed to the constructor.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @type {Object}
     *
     * @example
     * {maxFeatures: 50}
     */
    params: null,
    
    /**
     * Function to be called when the <read> operation completes.
     *  @memberof GeoGlobe.Protocol.Script.prototype
     *  @type {Object}
     */
    callback: null,

    /**
     * Template for creating a unique callback function name
     *      for the registry. Should include ${id}.  The ${id} variable will be
     *      replaced with a string identifier prefixed with a "c" (e.g. c1, c2).
     *      Default is "GeoGlobe.Protocol.Script.registry.${id}".
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @type {String}
     */
    callbackTemplate: "GeoGlobe.Protocol.Script.registry.${id}",

    /**
     * The name of the query string parameter that the service
     *     recognizes as the callback identifier.  Default is "callback".
     *     This key is used to generate the URL for the script.  For example
     *     setting <callbackKey> to "myCallback" would result in a URL like 
     *     http://example.com/?myCallback=...
     * @memberof GeoGlobe.Protocol.Script.prototype
     *  @type {String}
     */
    callbackKey: "callback",

    /**
     * Where a service requires that the callback query string
     *     parameter value is prefixed by some string, this value may be set.
     *     For example, setting callbackPrefix  to "foo:" would result in a
     *     URL like http://example.com/?callback=foo:...  Default is "".
     * @memberof GeoGlobe.Protocol.Script.prototype
     *  @type {String}
     */
    callbackPrefix: "",

    /**
     * Optional ``this`` object for the callback. Read-only, set through the options passed to the constructor.
     * @memberof GeoGlobe.Protocol.Script.prototype
     *  @type {Object}
     */
    scope: null,

    /**
     * Format for parsing features.  Default is an
     *     GeoGlobe.Format.GeoJSON format.  If an alternative is provided,
     *     the format's read method must take an object and return an array
     *     of features.
     * @memberof GeoGlobe.Protocol.Script.prototype
     *  @type {GeoGlobe.Format}
     */
    format: null,

    /**
     * References all pending requests.  Property names are script
     *     identifiers and property values are script elements.
     * @memberof GeoGlobe.Protocol.Script.prototype
     *  @type {Object}
     */
    pendingRequests: null,

    /**
     * Include the SRS identifier in BBOX query string parameter.
     *     Setting this property has no effect if a custom filterToParams method
     *     is provided.   Default is false.  If true and the layer has a 
     *     projection object set, any BBOX filter will be serialized with a 
     *     fifth item identifying the projection.  
     *     E.g. bbox=-1000,-1000,1000,1000,EPSG:900913
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @type {Boolean}
     */
    srsInBBOX: false,

    /**
     * A class for giving layers generic Script protocol.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     * @param  {String}  url
     * @param {Object} params
     * @param {Function} callback
     * @param  {Object} scope
     */
    initialize: function(options) {
        options = options || {};
        this.params = {};
        this.pendingRequests = {};
        GeoGlobe.Protocol.prototype.initialize.apply(this, arguments);
        if (!this.format) {
            this.format = new GeoGlobe.Format.GeoJSON();
        }

        if (!this.filterToParams && GeoGlobe.Format.QueryStringFilter) {
            var format = new GeoGlobe.Format.QueryStringFilter({
                srsInBBOX: this.srsInBBOX
            });
            this.filterToParams = function(filter, params) {
                return format.write(filter, params);
            };
        }
    },
    
    /**
     * Construct a request for reading new features.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {Object} options  - Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * @param {String} url  - Url for the request.
     * @param {Object} params  - Parameters to get serialized as a query string.
     * @param {GeoGlobe.Filter} filter  -  Filter to get serialized as a query string.
     *
     * @returns {GeoGlobe.Protocol.Response}
     *  - A response object, whose "priv" property
     *     references the injected script.  This object is also passed to the
     *     callback function when the request completes, its "features" property
     *     is then populated with the features received from the server.
     */
    read: function(options) {
        GeoGlobe.Protocol.prototype.read.apply(this, arguments);
        options = GeoGlobe.Util.applyDefaults(options, this.options);
        options.params = GeoGlobe.Util.applyDefaults(
            options.params, this.options.params
        );
        if (options.filter && this.filterToParams) {
            options.params = this.filterToParams(
                options.filter, options.params
            );
        }
        var response = new GeoGlobe.Protocol.Response({requestType: "read"});
        var request = this.createRequest(
            options.url, 
            options.params, 
            GeoGlobe.Function.bind(function(data) {
                response.data = data;
                this.handleRead(response, options);
            }, this)
        );
        response.priv = request;
        return response;
    },

    /** 
     * Optional method to translate an <GeoGlobe.Filter> object into an object
     *     that can be serialized as request query string provided.  If a custom 
     *     method is not provided, any filter will not be serialized. 
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {GeoGlobe.Filter} filter  - filter to convert.
     * @param  params  - The parameters object.
     * 
     * @returns {Object}  - The resulting parameters object.
     */

    /** 
     * Issues a request for features by creating injecting a script in the document head.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {String} url  - Service URL.
     * @param {Object} params  - Query string parameters.
     * @param {Function} callback  - Callback to be called with resulting data.
     *
     * @returns {HTMLScriptElement}  - The script pending execution.
     */
    createRequest: function(url, params, callback) {
        var id = GeoGlobe.Protocol.Script.register(callback);
        var name = GeoGlobe.String.format(this.callbackTemplate, {id: id});
        params = GeoGlobe.Util.extend({}, params);
        params[this.callbackKey] = this.callbackPrefix + name;
        url = GeoGlobe.Util.urlAppend(
            url, GeoGlobe.Util.getParameterString(params)
        );
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        script.id = "GeoGlobe_Protocol_Script_" + id;
        this.pendingRequests[script.id] = script;
        var head = document.getElementsByTagName("head")[0];
        head.appendChild(script);
        return script;
    },
    
    /** 
     * Remove a script node associated with a response from the document.  Also
     *     unregisters the callback and removes the script from the pendingRequests object.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {HTMLScriptElement}  script
     */
    destroyRequest: function(script) {
        GeoGlobe.Protocol.Script.unregister(script.id.split("_").pop());
        delete this.pendingRequests[script.id];
        if (script.parentNode) {
            script.parentNode.removeChild(script);
        }
    },

    /**
     * Individual callbacks are created for read, create and update, should
     *     a subclass need to override each one separately.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {GeoGlobe.Protocol.Response} response  - The response object to pass to the user callback.
     * @param {Object} options  - The user options passed to the read call.
     */
    handleRead: function(response, options) {
        this.handleResponse(response, options);
    },

    /**
     * Called by CRUD specific handlers.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {GeoGlobe.Protocol.Response} response  - The response object to pass to any user callback.
     * @param {Object} options  - The user options passed to the create, read, update,or delete call.
     */
    handleResponse: function(response, options) {
        if (options.callback) {
            if (response.data) {
                response.features = this.parseFeatures(response.data);
                response.code = GeoGlobe.Protocol.Response.SUCCESS;
            } else {
                response.code = GeoGlobe.Protocol.Response.FAILURE;
            }
            this.destroyRequest(response.priv);
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Read Script response body and return features.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {Object} data  - The data sent to the callback function by the server.
     *
     * @returns {Array({GeoGlobe.Feature})} or {GeoGlobe.Feature}  - Array of features or a single feature.
     */
    parseFeatures: function(data) {
        return this.format.read(data);
    },

    /**
     * Abort an ongoing request.  If no response is provided, all pending requests will be aborted.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {GeoGlobe.Protocol.Response} response  - The response object returned from a <read> request.
     */
    abort: function(response) {
        if (response) {
            this.destroyRequest(response.priv);
        } else {
            for (var key in this.pendingRequests) {
                this.destroyRequest(this.pendingRequests[key]);
            }
        }
    },
    
    /**
     * Clean up the protocol.
     *  @memberof GeoGlobe.Protocol.Script.prototype
     */
    destroy: function() {
        this.abort();
        delete this.params;
        delete this.format;
        GeoGlobe.Protocol.prototype.destroy.apply(this);
    },

    CLASS_NAME: "GeoGlobe.Protocol.Script" 
});

(function() {
    var o = GeoGlobe.Protocol.Script;
    var counter = 0;
    o.registry = {};
    
    /**
     * Register a callback for a newly created script.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {Function} callback  - The callback to be executed when the newly added
     *     script loads.  This callback will be called with a single argument
     *     that is the JSON returned by the service.
     *
     * @returns {Number}  - An identifier for retrieving the registered callback.
     */
    o.register = function(callback) {
        var id = "c"+(++counter);
        o.registry[id] = function() {
            callback.apply(this, arguments);
        };
        return id;
    };
    
    /**
     * Unregister a callback previously registered with the register function.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {Number} id   - The identifer returned by the register function.
     */
    o.unregister = function(id) {
        delete o.registry[id];
    };
})();

/**
 * @class GeoGlobe.Format
 * @classdesc 用于格式读取/写入各种格式的基类。 GeoGlobe.Format的子类预计会有读取和写入方法。
 * 格式化基类。
 *  @returns GeoGlobe.Format的一个实例
 */


GeoGlobe.Format = GeoGlobe.Class4OL({
    /**
     *A reference to options passed to the constructor.
     * @memberof GeoGlobe.Format.prototype
     * @type {object}
     * @private
     */

    options: null,
    
    /**
     * externalProjection- 当通过externalProjection和internalProjection传递时，
     * 格式将重新投影它读取或写入的几何。 
     * externalProjection是被传入读取或写出的内容所使用的投影。 
     * 为了重投影，指定投影的投影转换函数必须可用。 
     * 这种支持可以通过proj4js或通过自定义转换函数来提供。 
     * 看到{GeoGlobe.SpatialReference.addTransform}获取更多关于自定义转换的信息。
     * @memberof GeoGlobe.Format.prototype
     * @type {GeoGlobe.SpatialReference}
     */
    externalProjection: null,

    internalProjection: null,
    /**
     * data- 当keepData为true时，这是发送来读取的解析字符串
     * @memberof  GeoGlobe.Format.prototype
     * @type {object}
     */

    data: null,
    /**
     * keepData-保持对最近读取的数据的引用（数据）。默认为false。
     * @memberof  GeoGlobe.Format.prototype
     * @type {object}
     */

    keepData: false,

    /**
     * Instances of this class are not useful.  See one of the subclasses.
     * @classdesc GeoGlobe.Format
     * @memberof GeoGlobe.Format.prototype
     * @param {Object}options - 一个可选的对象，其属性设置在格式有效选项：KeEpData -{BooLoe}中，如果是true，在读取时，数据属性将被设置为解析对象（例如JSON或XML对象）。
     *
     */
    initialize: function(options) {
        GeoGlobe.Util.extend(this, options);
        this.options = options;
    },
    
    /**
     * 清理。
     * @memberof GeoGlobe.Format.prototype
     */
    destroy: function() {
    },

    /**
    * Read data from a string, and return an object whose type depends on the
     subclass.
     * @memberof GeoGlobe.Format.prototype
     * @param {string}data - Data to read/parse.
     * @returns  Depends on the subclass
     * @private
     */
    read: function(data) {
        throw new Error('Read not implemented.');
    },
    
    /**
     *  Accept an object, and return a string.
     * @memberof GeoGlobe.Format.prototype
     * @param {Object}object - Object to be serialized
     * @returns {String} A string representation of the object.
     * @private
     */
    write: function(object) {
        throw new Error('Write not implemented.');
    },

    CLASS_NAME: "GeoGlobe.Format"
});     

/**
 * @class  GeoGlobe.Format.XML
 * @classdesc  可扩展标记语言的格式化类。
 */

GeoGlobe.Format.XML = GeoGlobe.Class4OL(GeoGlobe.Format, {
    
    /**
     *  Mapping of namespace aliases to namespace URIs.  Properties
     *     of this object should not be set individually.  Read-only.  All
     *     XML subclasses should have their own namespaces object.  Use
     *     setNamespace to add or set a namespace alias after construction.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @type {Object}
     * @private
     */
    namespaces: null,
    
    /**
     * namespaceAlias- Mapping of namespace URI to namespace alias.  This object
     *     is read-only.  Use setNamespace to add or set a namespace alias.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @type {Object}
     * @private
     */
    namespaceAlias: null,
    
    /**
     * defaultPrefix-The default namespace alias for creating element nodes.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @type {String}
     * @private
     */
    defaultPrefix: null,
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @type {null}
     * @private
     *
     */
    readers: {},
    
    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @type {null}
     * @private
     */
    writers: {},

    /**
     * xmldom-If this browser uses ActiveX, this will be set to a XMLDOM
     *     object.  It is not intended to be a browser sniffing property.
     *     Instead, the xmldom property is used instead of code document end
     *     where namespaced node creation methods are not supported. In all
     *     other browsers, this remains null.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @type {XMLDom}
     * @private
     */
    xmldom: null,

    /**
     * 构建一个XML解析器。 解析器用于读取和写入XML。
     * 从字符串读取XML返回一个DOM元素。 
     * 从DOM元素编写XML返回一个字符串。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {Object}options -可选对象，其属性将设置在对象上。
     */
    initialize: function(options) {
        if(window.ActiveXObject) {
            this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
        }
        GeoGlobe.Format.prototype.initialize.apply(this, [options]);
        // clone the namespace object and set all namespace aliases
        this.namespaces = GeoGlobe.Util.extend({}, this.namespaces);
        this.namespaceAlias = {};
        for(var alias in this.namespaces) {
            this.namespaceAlias[this.namespaces[alias]] = alias;
        }
    },
    
    /**
     * 清除。
     * @memberof  GeoGlobe.Format.XML.prototype
     */
    destroy: function() {
        this.xmldom = null;
        GeoGlobe.Format.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Set a namespace alias and URI for the format.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {String}alias - The namespace alias (prefix).
     * @param {String} uri - The namespace URI.
     * @private
     */
    setNamespace: function(alias, uri) {
        this.namespaces[alias] = uri;
        this.namespaceAlias[uri] = alias;
    },

    /**
     * 解析XML字符串并返回DOM节点。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {String} text - XML字符串
     * @returns {DOMElement} 返回值是DOM节点
     */
    read: function(text) {
        var index = text.indexOf('<');
        if(index > 0) {
            text = text.substring(index);
        }
        var node = GeoGlobe.Util.Try(
            GeoGlobe.Function.bind((
                function() {
                    var xmldom;
                    /**
                     * Since we want to be able to call this method on the prototype
                     * itself, this.xmldom may not exist even if in IE.
                     */
                    if(window.ActiveXObject && !this.xmldom) {
                        xmldom = new ActiveXObject("Microsoft.XMLDOM");
                    } else {
                        xmldom = this.xmldom;
                        
                    }
                    xmldom.loadXML(text);
                    return xmldom;
                }
            ), this),
            function() {
                return new DOMParser().parseFromString(text, 'text/xml');
            },
            function() {
                var req = new XMLHttpRequest();
                req.open("GET", "data:" + "text/xml" +
                         ";charset=utf-8," + encodeURIComponent(text), false);
                if(req.overrideMimeType) {
                    req.overrideMimeType("text/xml");
                }
                req.send(null);
                return req.responseXML;
            }
        );

        if(this.keepData) {
            this.data = node;
        }

        return node;
    },

    /**
     * 将DOM节点编译成XML字符串
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement} node -DOM节点。
     * @returns {String} 返回XML字符串。
     */
    write: function(node) {
        var data;
        //if(this.xmldom) {//20160407修改，解决不支持IE11的问题
        if(node.xml) {
            data = node.xml;
        } else {
            var serializer = new XMLSerializer();
            if (node.nodeType == 1) {
                // Add nodes to a document before serializing. Everything else
                // is serialized as is. This may need more work. See #1218 .
                var doc = document.implementation.createDocument("", "", null);
                if (doc.importNode) {
                    node = doc.importNode(node, true);
                }
                doc.appendChild(node);
                data = serializer.serializeToString(doc);
            } else {
                data = serializer.serializeToString(node);
            }
        }
        return data;
    },

    /**
     * 用命名空间创建一个新元素。 
     * 该节点可以使用标准的node.appendChild方法附加到另一个节点。 
     * 对于跨浏览器支持，必须使用此方法而不是document.createElementNS。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {String}uri - 元素命名空间URI。
     * @param {String} name - 元素的前缀（前缀：localname）。
     * @returns {Element} 具有命名空间的DOM元素。
     */
    createElementNS: function(uri, name) {
        var element;
        if(this.xmldom) {
            if(typeof uri == "string") {
                element = this.xmldom.createNode(1, name, uri);
            } else {
                element = this.xmldom.createNode(1, name, "");
            }
        } else {
            element = document.createElementNS(uri, name);
        }
        return element;
    },

    /**
     *创建一个可以附加到由createElementNS创建的另一个节点的文档片段节点。
      这将在IE外调用document.createDocumentFragment。 
     在IE中，使用ActiveX对象的createDocumentFragment方法。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @returns {Element} 文档片段。
     */
    createDocumentFragment: function() {
        var element;
        if (this.xmldom) {
            element = this.xmldom.createDocumentFragment();
        } else {
            element = document.createDocumentFragment();
        }
        return element;
    },

    /**
     * 创建一个文本节点。 
     * 该节点可以使用标准的node.appendChild方法附加到另一个节点。 
     * 对于跨浏览器支持，必须使用此方法而不是document.createTextNode。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {String} text -  文本节点。
     * @returns {DOMElement} DOM文本节点。
     */
    createTextNode: function(text) {
        var node;
        if (typeof text !== "string") {
            text = String(text);
        }
        if(this.xmldom) {
            node = this.xmldom.createTextNode(text);
        } else {
            node = document.createTextNode(text);
        }
        return node;
    },

    /**
     * 给定名称空间URI和本地名称，获取节点上的元素列表。
     * 要返回给定命名空间中的所有节点，请使用'*'作为name参数。 
     * 要返回给定（本地）名称的所有节点，而不考虑命名空间，请使用'*'作为uri参数。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param  {Element} node -搜索属性节点的节点。
     * @param {String} uri - 命名空间URI。
     * @param {String}name -  属性本地名称（不带前缀）。
     * @returns {NodeList} 节点列表或元素数组。
     */
    getElementsByTagNameNS: function(node, uri, name) {
        var elements = [];
        if(node.getElementsByTagNameNS) {
            elements = node.getElementsByTagNameNS(uri, name);
        } else {
            // brute force method
            var allNodes = node.getElementsByTagName("*");
            var potentialNode, fullName;
            for(var i=0, len=allNodes.length; i<len; ++i) {
                potentialNode = allNodes[i];
                fullName = (potentialNode.prefix) ?
                           (potentialNode.prefix + ":" + name) : name;
                if((name == "*") || (fullName == potentialNode.nodeName)) {
                    if((uri == "*") || (uri == potentialNode.namespaceURI)) {
                        elements.push(potentialNode);
                    }
                }
            }
        }
        return elements;
    },

    /**
     * 获取给定命名空间URI和本地名称的属性节点。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param  {Element} node -搜索属性节点的节点。
     * @param {String} uri - 命名空间URI。
     * @param {String}name -  属性的本地名称（不带前缀）。
     * @returns {DOMElement} 属性节点，如果没有找到，则返回null。
     */
    getAttributeNodeNS: function(node, uri, name) {
        var attributeNode = null;
        if(node.getAttributeNodeNS) {
            attributeNode = node.getAttributeNodeNS(uri, name);
        } else {
            var attributes = node.attributes;
            var potentialNode, fullName;
            for(var i=0, len=attributes.length; i<len; ++i) {
                potentialNode = attributes[i];
                if(potentialNode.namespaceURI == uri) {
                    fullName = (potentialNode.prefix) ?
                               (potentialNode.prefix + ":" + name) : name;
                    if(fullName == potentialNode.nodeName) {
                        attributeNode = potentialNode;
                        break;
                    }
                }
            }
        }
        return attributeNode;
    },

    /**
     * 获取给定命名空间URI和本地名称的属性值。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {Element} node -搜索属性的节点。
     * @param {String}uri - 命名空间URI。
     * @param {String} name - 属性的本地名称（不带前缀）。
     * @returns {String} 属性值，如果没有找到返回空字符串。
     */
    getAttributeNS: function(node, uri, name) {
        var attributeValue = "";
        if(node.getAttributeNS) {
            attributeValue = node.getAttributeNS(uri, name) || "";
        } else {
            var attributeNode = this.getAttributeNodeNS(node, uri, name);
            if(attributeNode) {
                attributeValue = attributeNode.nodeValue;
            }
        }
        return attributeValue;
    },
    
    /**
     * 获取节点的文本值（如果存在），或返回可选的默认字符串。
     * 如果不存在第一个子项并且未提供默认值，则返回空字符串。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement} node -  用于查找第一个子元素的值。
     * @param {String} def - 可选字符串在没有第一个子元素值的情况下返回。
     * @returns {String} 给定节点的第一个子元素的值。
     */
    getChildValue: function(node, def) {
        var value = def || "";
        if(node) {
            for(var child=node.firstChild; child; child=child.nextSibling) {
                switch(child.nodeType) {
                    case 3: // text node
                    case 4: // cdata section
                        value += child.nodeValue;
                }
            }
        }
        return value;
    },

    /**
     * 测试给定节点是否只有简单内容（即没有子元素节点）。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement}  node -元素节点。
     * @returns {Boolean} 该节点没有子元素节点（类型1的节点）。
     */
    isSimpleContent: function(node) {
        var simple = true;
        for(var child=node.firstChild; child; child=child.nextSibling) {
            if(child.nodeType === 1) {
                simple = false;
                break;
            }
        }
        return simple;
    },
    
    /**
     * 确定给定节点的内容类型。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement} node - 给定节点。
     * @returns {Integer} 如果节点没有内容，简单，复杂或混合内容，
     * 则为GeoGlobe.Format.XML.CONTENT_TYPE。{EMPTY，SIMPLE，COMPLEX，MIXED}之一。
     */
    contentType: function(node) {
        var simple = false,
            complex = false;
            
        var type = GeoGlobe.Format.XML.CONTENT_TYPE.EMPTY;

        for(var child=node.firstChild; child; child=child.nextSibling) {
            switch(child.nodeType) {
                case 1: // element
                    complex = true;
                    break;
                case 8: // comment
                    break;
                default:
                    simple = true;
            }
            if(complex && simple) {
                break;
            }
        }
        
        if(complex && simple) {
            type = GeoGlobe.Format.XML.CONTENT_TYPE.MIXED;
        } else if(complex) {
            return GeoGlobe.Format.XML.CONTENT_TYPE.COMPLEX;
        } else if(simple) {
            return GeoGlobe.Format.XML.CONTENT_TYPE.SIMPLE;
        }
        return type;
    },

    /**
     * 确定节点是否具有与给定名称和名称空间匹配的特定属性。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {Element}node - 需要设置属性的元素节点。
     * @param  {String}uri - 属性的命名空间URI。
     * @param {String}name -该属性的本地名称（前缀：localname）。
     * @returns {Boolean} 该节点具有与名称和命名空间匹配的属性。
     */
    hasAttributeNS: function(node, uri, name) {
        var found = false;
        if(node.hasAttributeNS) {
            found = node.hasAttributeNS(uri, name);
        } else {
            found = !!this.getAttributeNodeNS(node, uri, name);
        }
        return found;
    },
    
    /**
     * 添加新属性或使用给定命名空间和名称更改属性的值。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {Element}node - 需要设置属性的元素节点。
     * @param  {String}uri - 属性的命名空间URI。
     * @param {String}name -该属性的合法名称（前缀：localname）。
     * @param {String}value - 属性值。
     */
    setAttributeNS: function(node, uri, name, value) {
        if(node.setAttributeNS) {
            node.setAttributeNS(uri, name, value);
        } else {
            if(this.xmldom) {
                if(uri) {
                    var attribute = node.ownerDocument.createNode(
                        2, name, uri
                    );
                    attribute.nodeValue = value;
                    node.setAttributeNode(attribute);
                } else {
                    node.setAttribute(name, value);
                }
            } else {
                throw "setAttributeNS not implemented";
            }
        }
    },

    /**
     * Shorthand for creating namespaced elements with optional attributes and
     *     child text nodes.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {String}name - The qualified node name.
     * @param  {Object}options - Optional object for node configuration.
     * @param {String} uri - Optional namespace uri for the element - supply a prefix
     *     instead if the namespace uri is a property of the format's namespace
     *     object.
     * @param {object} attributes -  Optional attributes to be set using the
     *     setAttributes method.
     * @param {String} value -  Optional text to be appended as a text node.
     * @returns {Element} An element node.
     * @private
     */
    createElementNSPlus: function(name, options) {
        options = options || {};
        // order of prefix preference
        // 1. in the uri option
        // 2. in the prefix option
        // 3. in the qualified name
        // 4. from the defaultPrefix
        var uri = options.uri || this.namespaces[options.prefix];
        if(!uri) {
            var loc = name.indexOf(":");
            uri = this.namespaces[name.substring(0, loc)];
        }
        if(!uri) {
            uri = this.namespaces[this.defaultPrefix];
        }
        var node = this.createElementNS(uri, name);
        if(options.attributes) {
            this.setAttributes(node, options.attributes);
        }
        var value = options.value;
        if(value != null) {
            node.appendChild(this.createTextNode(value));
        }
        return node;
    },
    
    /**
     *  Set multiple attributes given key value pairs from an object.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {Element}  node - An element node.
     * @param {Object}obj - An object whose properties represent attribute
     *     names and values represent attribute values.  If an attribute name
     *     is a qualified name ("prefix:local"), the prefix will be looked up
     *     in the parsers {namespaces} object.  If the prefix is found,
     *     setAttributeNS will be used instead of setAttribute.
     * @private
     */
    setAttributes: function(node, obj) {
        var value, uri;
        for(var name in obj) {
            if(obj[name] != null && obj[name].toString) {
                value = obj[name].toString();
                // check for qualified attribute name ("prefix:local")
                uri = this.namespaces[name.substring(0, name.indexOf(":"))] || null;
                this.setAttributeNS(node, uri, name, value);
            }
        }
    },

    /**
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement}  node - The node to be read (required).
     * @param {Object} obj - The object to be modified (optional).
     * @returns {Object} The input object, modified (or a new one if none was provided).
     * @private
     */
    readNode: function(node, obj) {
        if(!obj) {
            obj = {};
        }
        var group = this.readers[node.namespaceURI ? this.namespaceAlias[node.namespaceURI]: this.defaultPrefix];
        if(group) {
            var local = node.localName || node.nodeName.split(":").pop();
            var reader = group[local] || group["*"];
            if(reader) {
                reader.apply(this, [node, obj]);
            }
        }
        return obj;
    },

    /**
     * Shorthand for applying the named readers to all children of a node.
     *     For each child of type 1 (element), readSelf is called.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement} node -  The node to be read (required).
     * @param {Object} obj - The object to be modified (optional).
     * @returns {Object} The input object, modified.
     * @private
     */
    readChildNodes: function(node, obj) {
        if(!obj) {
            obj = {};
        }
        var children = node.childNodes;
        var child;
        for(var i=0, len=children.length; i<len; ++i) {
            child = children[i];
            if(child.nodeType == 1) {
                this.readNode(child, obj);
            }
        }
        return obj;
    },

    /**
     * Shorthand for applying one of the named writers and appending the
     *     results to a node.  If a qualified name is not provided for the
     *     second argument (and a local name is used instead), the namespace
     *     of the parent node will be assumed.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {String} name -  The name of a node to generate.  If a qualified name
     *     (e.g. "pre:Name") is used, the namespace prefix is assumed to be
     *     in the writers group.  If a local name is used (e.g. "Name") then
     *     the namespace of the parent is assumed.  If a local name is used
     *     and no parent is supplied, then the default namespace is assumed.
     * @param {Object} obj - Structure containing data for the writer.
     * parent - {DOMElement} Result will be appended to this node.  If no parent
     *     is supplied, the node will not be appended to anything.
     * @returns {DOMElement} The child node.
     * @private
     */
    writeNode: function(name, obj, parent) {
        var prefix, local;
        var split = name.indexOf(":");
        if(split > 0) {
            prefix = name.substring(0, split);
            local = name.substring(split + 1);
        } else {
            if(parent) {
                prefix = this.namespaceAlias[parent.namespaceURI];
            } else {
                prefix = this.defaultPrefix;
            }
            local = name;
        }
        var child = this.writers[prefix][local].apply(this, [obj]);
        if(parent) {
            parent.appendChild(child);
        }
        return child;
    },

    /**
     * 获取第一个子元素。 如果它匹配给定的名称和命名空间URI只需要可选地返回第一个元素，。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement} node -节点。
     * @param {String}  name -要搜索的相邻节点的本地名称。
     * @param {String}  uri - 要搜索的相邻节点的命名空间URL。
     * @returns {DOMElement} 第一个元素。 如果找不到，
     * 或者找到除元素之外的重要元素，或者找到的元素与可选名称和uri不匹配，则返回null。
     */
    getChildEl: function(node, name, uri) {
        return node && this.getThisOrNextEl(node.firstChild, name, uri);
    },
    
    /**
     * 获取下一个兄弟元素。 只有当匹配给定的本地名称和命名空间URI时，才可以获取第一个兄弟元素。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement} node -节点。
     * @param {String}  name -要搜索的兄弟的可选本地名称。
     * @param {String}  uri - 要搜索的兄弟的可选命名空间URI。
     * @returns {DOMElement} 下一个兄弟元素。
     * 除了找到元素之外的重要元素，或找到的元素与可选的名称和uri不匹配外，
     * 如果找不到任何元素，则返回null。
     */
    getNextEl: function(node, name, uri) {
        return node && this.getThisOrNextEl(node.nextSibling, name, uri);
    },
    
    /**
     * Return this node or the next element node.  Optionally get the first
     *     sibling with the given local name or namespace URI.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement}node -  The node.
     * @param {String} name - Optional local name of the sibling to search for.
     * @param {String}uri - Optional namespace URI of the sibling to search for.
     * @returns {DOMElement} The next sibling element.  Returns null if no element is
     *     found, something significant besides an element is found, or the
     *     found element does not match the query.
     * @private
     */
    getThisOrNextEl: function(node, name, uri) {
        outer: for(var sibling=node; sibling; sibling=sibling.nextSibling) {
            switch(sibling.nodeType) {
                case 1: // Element
                    if((!name || name === (sibling.localName || sibling.nodeName.split(":").pop())) &&
                       (!uri || uri === sibling.namespaceURI)) {
                        // matches
                        break outer;
                    }
                    sibling = null;
                    break outer;
                case 3: // Text
                    if(/^\s*$/.test(sibling.nodeValue)) {
                        break;
                    }
                case 4: // CDATA
                case 6: // ENTITY_NODE
                case 12: // NOTATION_NODE
                case 10: // DOCUMENT_TYPE_NODE
                case 11: // DOCUMENT_FRAGMENT_NODE
                    sibling = null;
                    break outer;
            } // ignore comments and processing instructions
        }
        return sibling || null;
    },
    
    /**
     * 获取前缀并返回给定节点上与其关联的命名空间URI（如果未找到则返回null）。 
     * 为前缀提供null将返回默认名称空间。
     * @memberof  GeoGlobe.Format.XML.prototype
     * 对于支持它的浏览器，这会调用本地lookupNamesapceURI函数。 在其他浏览器中，
     * 这是http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3lookupNamespaceURI的实现路径。
     *
     * 对于不支持attribute.ownerElement属性的浏览器，不能在属性节点上调用此方法。
     *     

     * @param {DOMElement} node - 从哪个节点开始查找。
     * @param {String} prefix -通过要查找的前缀或null来查找默认命名空间。
     * @returns {String} 给定前缀的命名空间URI。 如果无法找到前缀或节点类型错误，则返回null。
     */
    lookupNamespaceURI: function(node, prefix) {
        var uri = null;
        if(node) {
            if(node.lookupNamespaceURI) {
                uri = node.lookupNamespaceURI(prefix);
            } else {
                outer: switch(node.nodeType) {
                    case 1: // ELEMENT_NODE
                        if(node.namespaceURI !== null && node.prefix === prefix) {
                            uri = node.namespaceURI;
                            break outer;
                        }
                        var len = node.attributes.length;
                        if(len) {
                            var attr;
                            for(var i=0; i<len; ++i) {
                                attr = node.attributes[i];
                                if(attr.prefix === "xmlns" && attr.name === "xmlns:" + prefix) {
                                    uri = attr.value || null;
                                    break outer;
                                } else if(attr.name === "xmlns" && prefix === null) {
                                    uri = attr.value || null;
                                    break outer;
                                }
                            }
                        }
                        uri = this.lookupNamespaceURI(node.parentNode, prefix);
                        break outer;
                    case 2: // ATTRIBUTE_NODE
                        uri = this.lookupNamespaceURI(node.ownerElement, prefix);
                        break outer;
                    case 9: // DOCUMENT_NODE
                        uri = this.lookupNamespaceURI(node.documentElement, prefix);
                        break outer;
                    case 6: // ENTITY_NODE
                    case 12: // NOTATION_NODE
                    case 10: // DOCUMENT_TYPE_NODE
                    case 11: // DOCUMENT_FRAGMENT_NODE
                        break outer;
                    default: 
                        // TEXT_NODE (3), CDATA_SECTION_NODE (4), ENTITY_REFERENCE_NODE (5),
                        // PROCESSING_INSTRUCTION_NODE (7), COMMENT_NODE (8)
                        uri =  this.lookupNamespaceURI(node.parentNode, prefix);
                        break outer;
                }
            }
        }
        return uri;
    },
    
    /**
     * Get an XML document for nodes that are not supported in HTML (e.g.
     * createCDATASection). On IE, this will either return an existing or
     * create a new xmldom on the instance. On other browsers, this will
     * either return an existing or create a new shared document (see
     * GeoGlobe.Format.XML.document).
     * @memberof  GeoGlobe.Format.XML.prototype
     * @returns {XMLDocument}
     * @private
     */
    getXMLDoc: function() {
        if (!GeoGlobe.Format.XML.document && !this.xmldom) {
            if (document.implementation && document.implementation.createDocument) {
                GeoGlobe.Format.XML.document =
                    document.implementation.createDocument("", "", null);
            } else if (!this.xmldom && window.ActiveXObject) {
                this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
            }
        }
        return GeoGlobe.Format.XML.document || this.xmldom;
    },

    CLASS_NAME: "GeoGlobe.Format.XML" 

});     

GeoGlobe.Format.XML.CONTENT_TYPE = {EMPTY: 0, SIMPLE: 1, COMPLEX: 2, MIXED: 3};

/**
 * @memberof  GeoGlobe.Format.XML.prototype
 * 获取前缀并返回给定节点上与其关联的命名空间URI（如果未找到则返回null）。 
 * 为前缀提供null将返回默认命名空间。
 *
 * 对于支持它的浏览器，这会调用本地lookupNamesapceURI函数。  在其他浏览器通过这个地址调用
 *     http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI.
 *
 * 对于不支持attribute.ownerElement属性的浏览器，不能在属性节点上调用此方法。
 * @param {DOMElement}node -  从哪个节点开始查找。
 * @param {String}  prefix -通过要查找的前缀或null来查找默认命名空间。
 * @returns {String} 给定前缀的名，命名空间URI。 如果无法找到前缀或节点类型错误，则返回null。
 */
GeoGlobe.Format.XML.lookupNamespaceURI = GeoGlobe.Function.bind(
    GeoGlobe.Format.XML.prototype.lookupNamespaceURI,
    GeoGlobe.Format.XML.prototype
);

/**
 * GeoGlobe.Format.XML.document- XML document to reuse for creating non-HTML compliant nodes,
 * like document.createCDATASection.
 * @memberof GeoGlobe.Format.XML.prototype
 * @type {XMLDocument}
 * @private
 */
GeoGlobe.Format.XML.document = null;

/**
 * @class GeoGlobe.Format.XML.VersionedOGC
 * @classdesc  版本格式的基类，即支持多个版本的格式。
 * @private
 */

GeoGlobe.Format.XML.VersionedOGC = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * defaultVersion - 如果没有找到，则假定版本号。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     */
    defaultVersion: null,
    
    /**
     *version-指定版本字符串（如果已知）。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     */
    version: null,

    /**
     * profile - 如果提供，使用自定义配置文件。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     */
    profile: null,

    /**
     *allowFallback-如果找不到返回版本的概要分析器，
     *则使用非概要分析器作为回退。 
     *使用它的应用程序代码应该考虑到返回对象结构可能缺少配置文件的细节。
     *默认为false。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {Boolean}
     */
    allowFallback: false,

    /**
     * name-The name of this parser, this is the part of the CLASS_NAME
     * except for "GeoGlobe.Format."
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     * @private
     */
    name: null,

    /**
     * 如果为true，写入将返回一个字符串，否则返回一个DOMElement。 默认为false。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {Boolean}
     */
    stringifyOutput: false,

    /**
     * parser- Instance of the versioned parser.  Cached for multiple read and
     *    write calls of the same version.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {Object}
     * @private
     */
    parser: null,

    /**
     * 构造函数。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {Object} options - 可选对象，其属性将设置在对象上。
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
        var className = this.CLASS_NAME;
        this.name = className.substring(className.lastIndexOf(".")+1);
    },

    /**
     * Returns the version to use. Subclasses can override this function
     * if a different version detection is needed.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {DOMElement} root -
     * @param {Object}options - Optional configuration object.
     * @returns {String} The version to use.
     * @private
     */
    getVersion: function(root, options) {
        var version;
        // read
        if (root) {
            version = this.version;
            if(!version) {
                version = root.getAttribute("version");
                if(!version) {
                    version = this.defaultVersion;
                }
            }
        } else { // write
            version = (options && options.version) || 
                this.version || this.defaultVersion;
        }
        return version;
    },

    /**
     * Get an instance of the cached parser if available, otherwise create one.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {String}version
     * @returns {GeoGlobe.Format}
     * @private
     */
    getParser: function(version) {
        version = version || this.defaultVersion;
        var profile = this.profile ? "_" + this.profile : "";
        if(!this.parser || this.parser.VERSION != version) {
            var format = GeoGlobe.Format[this.name][
                "v" + version.replace(/\./g, "_") + profile
            ];
            if(!format) {
                if (profile !== "" && this.allowFallback) {
                    // fallback to the non-profiled version of the parser
                    profile = "";
                    format = GeoGlobe.Format[this.name][
                        "v" + version.replace(/\./g, "_")
                    ];
                }
                if (!format) {
                    throw "Can't find a " + this.name + " parser for version " +
                          version + profile;
                }
            }
            this.parser = new format(this.options);
        }
        return this.parser;
    },

    /**
     * 写一个文件。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {Object} obj -代表文档的对象。
     * @param {Object}options - 可选的配置对象。
     * @returns {String} 该文件是一个字符串。
     */
    write: function(obj, options) {
        var version = this.getVersion(null, options);
        this.parser = this.getParser(version);
        var root = this.parser.write(obj, options);
        if (this.stringifyOutput === false) {
            return root;
        } else {
            return GeoGlobe.Format.XML.prototype.write.apply(this, [root]);
        }
    },

    /**
     * 阅读文档并返回代表文档的对象。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {String | DOMElement} data - 要读取的数据。
     * @param {Object}options - 读者的选择。
     * @returns {Object} 代表文档的对象。
     */
    read: function(data, options) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var root = data.documentElement;
        var version = this.getVersion(root);
        this.parser = this.getParser(version);          // Select the parser
        var obj = this.parser.read(data, options);      // Parse the data

        var errorProperty = this.parser.errorProperty || null;
        if (errorProperty !== null && obj[errorProperty] === undefined) {
            // an error must have happened, so parse it and report back
            var format = new GeoGlobe.Format.OGCExceptionReport();
            obj.error = format.read(data);
        }
        obj.version = version;
        return obj;
    },

    CLASS_NAME: "GeoGlobe.Format.XML.VersionedOGC"
});


/**
 * @class GeoGlobe.Format.GML
 * @classdesc  读/写GML。 用GeoGlobe.Format.GML构造函数创建一个新实例。 支持GML简单功能配置文件。
 * 解析GML文件类
 */

GeoGlobe.Format.GML = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * featureNS-用于特征属性的名称空间。 默认是“http://mapserver.gis.umn.edu/mapserver”。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    featureNS: "http://mapserver.gis.umn.edu/mapserver",
    
    /**
     * featurePrefix- 名称空间别名（或前缀）用于特征节点。 默认是“feature”。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    featurePrefix: "feature",
    
    /**
     * featureName-要素的元素名称。 默认是“featureMember”。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    featureName: "featureMember", 
    
    /**
     * layerName- 数据图层的名称。 默认是“features”。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    layerName: "features",
    
    /**
     * geometryName- 几何元素的名称。 默认为“geometry”。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    geometryName: "geometry",
    
    /**
     * collectionName- featureCollection元素的名称。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    collectionName: "FeatureCollection",
    
    /**
     * gmlns- GML命名空间。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    gmlns: "http://www.opengis.net/gml",

    /**
     * extractAttributes- 从GML中提取属性。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {Boolean}
     */
    extractAttributes: true,
    
    /**
     * xy- GML坐标的顺序true：（x，y）或false：（y，x）不建议更改，应该实例化新格式。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {Boolean}
     */ 
    xy: true,
    
    /**
     * 为GML创建一个新的解析器。
     * @memberof GeoGlobe.Format.GML.prototype
     * @classdesc  GeoGlobe.Format.GML
     * @param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        // compile regular expressions once instead of every time they are used
        this.regExes = {
            trimSpace: (/^\s*|\s*$/g),
            removeSpace: (/\s*/g),
            splitSpace: (/\s+/),
            trimComma: (/\s*,\s*/g)
        };
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * 读取数据解析并且返回要素数组。
     * @memberof GeoGlobe.Format.GML.prototype
     * @param {String}data - or {DOMElement} 数据读取/解析。
     *
     * @returns {Array(GeoGlobe.Feature.Vector)} 一系列要素。
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var featureNodes = this.getElementsByTagNameNS(data.documentElement,
                                                       this.gmlns,
                                                       this.featureName);
        var features = [];
        for(var i=0; i<featureNodes.length; i++) {
            var feature = this.parseFeature(featureNodes[i]);
            if(feature) {
                features.push(feature);
            }
        }
        return features;
    },
    
    /**
     * This function is the core of the GML parsing code in GeoGlobe.
     *    It creates the geometries that are then attached to the returned
     *    feature, and calls parseAttributes() to get attribute data out.
     * @memberof GeoGlobe.Format.GML.prototype
     * @param {DOMElement}node -  A GML feature node.
     * @private
     */
    parseFeature: function(node) {
        // only accept one geometry per feature - look for highest "order"
        var order = ["MultiPolygon", "Polygon",
                     "MultiLineString", "LineString",
                     "MultiPoint", "Point", "Envelope"];
        // FIXME: In case we parse a feature with no geometry, but boundedBy an Envelope,
        // this code creates a geometry derived from the Envelope. This is not correct.
        var type, nodeList, geometry, parser;
        for(var i=0; i<order.length; ++i) {
            type = order[i];
            nodeList = this.getElementsByTagNameNS(node, this.gmlns, type);
            if(nodeList.length > 0) {
                // only deal with first geometry of this type
                parser = this.parseGeometry[type.toLowerCase()];
                if(parser) {
                    geometry = parser.apply(this, [nodeList[0]]);
                    if (this.internalProjection && this.externalProjection) {
                        geometry.transform(this.externalProjection, 
                                           this.internalProjection); 
                    }                       
                } else {
                    throw new TypeError("Unsupported geometry type: " + type);
                }
                // stop looking for different geometry types
                break;
            }
        }

        var bounds;
        var boxNodes = this.getElementsByTagNameNS(node, this.gmlns, "Box");
        for(i=0; i<boxNodes.length; ++i) {
            var boxNode = boxNodes[i];
            var box = this.parseGeometry["box"].apply(this, [boxNode]);
            var parentNode = boxNode.parentNode;
            var parentName = parentNode.localName ||
                             parentNode.nodeName.split(":").pop();
            if(parentName === "boundedBy") {
                bounds = box;
            } else {
                geometry = box.toGeometry();
            }
        }
        
        // construct feature (optionally with attributes)
        var attributes;
        if(this.extractAttributes) {
            attributes = this.parseAttributes(node);
        }
        var feature = new GeoGlobe.Feature(geometry, attributes);
        feature.bounds = bounds;
        
        feature.gml = {
            featureType: node.firstChild.nodeName.split(":")[1],
            featureNS: node.firstChild.namespaceURI,
            featureNSPrefix: node.firstChild.prefix
        };
                
        // assign fid - this can come from a "fid" or "id" attribute
        var childNode = node.firstChild;
        var fid;
        while(childNode) {
            if(childNode.nodeType == 1) {
                fid = childNode.getAttribute("fid") ||
                      childNode.getAttribute("id");
                if(fid) {
                    break;
                }
            }
            childNode = childNode.nextSibling;
        }
        feature.fid = fid;
        return feature;
    },
    
    /**

     * Properties of this object are the functions that parse geometries based
         on their type.
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {null}
     * @private
     */
    parseGeometry: {
        
        /**
         * Given a GML node representing a point geometry, create an GeoGlobe
         *     point geometry.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement}node - A GML node.
         * @returns {GeoGlobe.Geometry.Point} A point geometry.
         * @private
         */
        point: function(node) {
            /**
             * Three coordinate variations to consider:
             * 1) gml:pos>x y z/gml:pos
             * 2) gml:coordinatesx, y, z/gml:coordinates
             * 3) gml:coordgml:X>x/gml:X gml:Y>y</gml:Y</gml:coord
             */
            var nodeList, coordString;
            var coords = [];

            // look for <gml:pos>
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns, "pos");
            if(nodeList.length > 0) {
                coordString = nodeList[0].firstChild.nodeValue;
                coordString = coordString.replace(this.regExes.trimSpace, "");
                coords = coordString.split(this.regExes.splitSpace);
            }

            // look for <gml:coordinates>
            if(coords.length == 0) {
                nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "coordinates");
                if(nodeList.length > 0) {
                    coordString = nodeList[0].firstChild.nodeValue;
                    coordString = coordString.replace(this.regExes.removeSpace,
                                                      "");
                    coords = coordString.split(",");
                }
            }

            // look for <gml:coord>
            if(coords.length == 0) {
                nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "coord");
                if(nodeList.length > 0) {
                    var xList = this.getElementsByTagNameNS(nodeList[0],
                                                            this.gmlns, "X");
                    var yList = this.getElementsByTagNameNS(nodeList[0],
                                                            this.gmlns, "Y");
                    if(xList.length > 0 && yList.length > 0) {
                        coords = [xList[0].firstChild.nodeValue,
                                  yList[0].firstChild.nodeValue];
                    }
                }
            }
                
            // preserve third dimension
            if(coords.length == 2) {
                coords[2] = null;
            }
            
            if (this.xy) {
                return new GeoGlobe.Geometry.Point(coords[0], coords[1],
                                                 coords[2]);
            }
            else{
                return new GeoGlobe.Geometry.Point(coords[1], coords[0],
                                                 coords[2]);
            }
        },
        
        /**
         * Given a GML node representing a multipoint geometry, create an
              GeoGlobe multipoint geometry.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement} node - A GML node.
         * @returns {GeoGlobe.Geometry.MultiPoint} A multipoint geometry.
         * @private
         */
        multipoint: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "Point");
            var components = [];
            if(nodeList.length > 0) {
                var point;
                for(var i=0; i<nodeList.length; ++i) {
                    point = this.parseGeometry.point.apply(this, [nodeList[i]]);
                    if(point) {
                        components.push(point);
                    }
                }
            }
            return new GeoGlobe.Geometry.MultiPoint(components);
        },
        
        /**
         *  Given a GML node representing a linestring geometry, create an
            GeoGlobe linestring geometry.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement}node - A GML node.
         * @returns {GeoGlobe.Geometry.LineString} A linestring geometry.
         * @private
         */
        linestring: function(node, ring) {
            /**
             * Two coordinate variations to consider:
             * 1) gml:posList dimension="d">x0 y0 z0 x1 y1 z1/gml:posList
             * 2) gml:coordinates x0, y0, z0 x1, y1, z1/gml:coordinates
             */
            var nodeList, coordString;
            var coords = [];
            var points = [];

            // look for <gml:posList>
            nodeList = this.getElementsByTagNameNS(node, this.gmlns, "posList");
            if(nodeList.length > 0) {
                coordString = this.getChildValue(nodeList[0]);
                coordString = coordString.replace(this.regExes.trimSpace, "");
                coords = coordString.split(this.regExes.splitSpace);
                var dim = parseInt(nodeList[0].getAttribute("dimension"));
                var j, x, y, z;
                for(var i=0; i<coords.length/dim; ++i) {
                    j = i * dim;
                    x = coords[j];
                    y = coords[j+1];
                    z = (dim == 2) ? null : coords[j+2];
                    if (this.xy) {
                        points.push(new GeoGlobe.Geometry.Point(x, y, z));
                    } else {
                        points.push(new GeoGlobe.Geometry.Point(y, x, z));
                    }
                }
            }

            // look for <gml:coordinates>
            if(coords.length == 0) {
                nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "coordinates");
                if(nodeList.length > 0) {
                    coordString = this.getChildValue(nodeList[0]);
                    coordString = coordString.replace(this.regExes.trimSpace,
                                                      "");
                    coordString = coordString.replace(this.regExes.trimComma,
                                                      ",");
                    var pointList = coordString.split(this.regExes.splitSpace);
                    for(var i=0; i<pointList.length; ++i) {
                        coords = pointList[i].split(",");
                        if(coords.length == 2) {
                            coords[2] = null;
                        }
                        if (this.xy) {
                            points.push(new GeoGlobe.Geometry.Point(coords[0],
                                                                  coords[1],
                                                                  coords[2]));
                        } else {
                            points.push(new GeoGlobe.Geometry.Point(coords[1],
                                                                  coords[0],
                                                                  coords[2]));
                        }
                    }
                }
            }

            var line = null;
            if(points.length != 0) {
                if(ring) {
                    line = new GeoGlobe.Geometry.LinearRing(points);
                } else {
                    line = new GeoGlobe.Geometry.LineString(points);
                }
            }
            return line;
        },
        
        /**
         *  Given a GML node representing a multilinestring geometry, create an
            GeoGlobe multilinestring geometry.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement}node - A GML node.
         * @returns {GeoGlobe.Geometry.MultiLineString} A multilinestring geometry.
         * @private
         */
        multilinestring: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "LineString");
            var components = [];
            if(nodeList.length > 0) {
                var line;
                for(var i=0; i<nodeList.length; ++i) {
                    line = this.parseGeometry.linestring.apply(this,
                                                               [nodeList[i]]);
                    if(line) {
                        components.push(line);
                    }
                }
            }
            return new GeoGlobe.Geometry.MultiLineString(components);
        },
        
        /**
         * Given a GML node representing a polygon geometry, create an
            GeoGlobe polygon geometry.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement} node -A GML node.
         * @returns {GeoGlobe.Geometry.Polygon} A polygon geometry.
         * @private
         */
        polygon: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "LinearRing");
            var components = [];
            if(nodeList.length > 0) {
                // this assumes exterior ring first, inner rings after
                var ring;
                for(var i=0; i<nodeList.length; ++i) {
                    ring = this.parseGeometry.linestring.apply(this,
                                                        [nodeList[i], true]);
                    if(ring) {
                        components.push(ring);
                    }
                }
            }
            return new GeoGlobe.Geometry.Polygon(components);
        },
        
        /**
         * Given a GML node representing a multipolygon geometry, create an
           GeoGlobe multipolygon geometry.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement} node - A GML node.
         * @returns {GeoGlobe.Geometry.MultiPolygon} A multipolygon geometry.
         * @private
         */
        multipolygon: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "Polygon");
            var components = [];
            if(nodeList.length > 0) {
                var polygon;
                for(var i=0; i<nodeList.length; ++i) {
                    polygon = this.parseGeometry.polygon.apply(this,
                                                               [nodeList[i]]);
                    if(polygon) {
                        components.push(polygon);
                    }
                }
            }
            return new GeoGlobe.Geometry.MultiPolygon(components);
        },
        
        envelope: function(node) {
            var components = [];
            var coordString;
            var envelope;
            
            var lpoint = this.getElementsByTagNameNS(node, this.gmlns, "lowerCorner");
            if (lpoint.length > 0) {
                var coords = [];
                
                if(lpoint.length > 0) {
                    coordString = lpoint[0].firstChild.nodeValue;
                    coordString = coordString.replace(this.regExes.trimSpace, "");
                    coords = coordString.split(this.regExes.splitSpace);
                }
                
                if(coords.length == 2) {
                    coords[2] = null;
                }
                if (this.xy) {
                    var lowerPoint = new GeoGlobe.Geometry.Point(coords[0], coords[1],coords[2]);
                } else {
                    var lowerPoint = new GeoGlobe.Geometry.Point(coords[1], coords[0],coords[2]);
                }
            }
            
            var upoint = this.getElementsByTagNameNS(node, this.gmlns, "upperCorner");
            if (upoint.length > 0) {
                var coords = [];
                
                if(upoint.length > 0) {
                    coordString = upoint[0].firstChild.nodeValue;
                    coordString = coordString.replace(this.regExes.trimSpace, "");
                    coords = coordString.split(this.regExes.splitSpace);
                }
                
                if(coords.length == 2) {
                    coords[2] = null;
                }
                if (this.xy) {
                    var upperPoint = new GeoGlobe.Geometry.Point(coords[0], coords[1],coords[2]);
                } else {
                    var upperPoint = new GeoGlobe.Geometry.Point(coords[1], coords[0],coords[2]);
                }
            }
            
            if (lowerPoint && upperPoint) {
                components.push(new GeoGlobe.Geometry.Point(lowerPoint.x, lowerPoint.y));
                components.push(new GeoGlobe.Geometry.Point(upperPoint.x, lowerPoint.y));
                components.push(new GeoGlobe.Geometry.Point(upperPoint.x, upperPoint.y));
                components.push(new GeoGlobe.Geometry.Point(lowerPoint.x, upperPoint.y));
                components.push(new GeoGlobe.Geometry.Point(lowerPoint.x, lowerPoint.y));
                
                var ring = new GeoGlobe.Geometry.LinearRing(components);
                envelope = new GeoGlobe.Geometry.Polygon([ring]);
            }
            return envelope; 
        },

        /**
         *  Given a GML node representing a box geometry, create an
           GeoGlobe.Bounds.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement} node -A GML node.
         * @returns {GeoGlobe.Bounds} A bounds representing the box.
         * @private
         */
        box: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                   "coordinates");
            var coordString;
            var coords, beginPoint = null, endPoint = null;
            if (nodeList.length > 0) {
                coordString = nodeList[0].firstChild.nodeValue;
                coords = coordString.split(" ");
                if (coords.length == 2) {
                    beginPoint = coords[0].split(",");
                    endPoint = coords[1].split(",");
                }
            }
            if (beginPoint !== null && endPoint !== null) {
                var sw = new GeoGlobe.LngLat(parseFloat(beginPoint[0]), parseFloat(beginPoint[1]));
				var ne = new GeoGlobe.LngLat(parseFloat(endPoint[0]), parseFloat(endPoint[1]));
				return new GeoGlobe.LngLatBounds(sw, ne);
            }
        }
        
    },
    
    /**
     * @memberof GeoGlobe.Format.GML.prototype
     * @param {DOMElement}node -
     * @returns {Object} An attributes object.
     * @private
     */
    parseAttributes: function(node) {
        var attributes = {};
        // assume attributes are children of the first type 1 child
        var childNode = node.firstChild;
        var children, i, child, grandchildren, grandchild, name, value;
        while(childNode) {
            if(childNode.nodeType == 1) {
                // attributes are type 1 children with one type 3 child
                children = childNode.childNodes;
                for(i=0; i<children.length; ++i) {
                    child = children[i];
                    if(child.nodeType == 1) {
                        grandchildren = child.childNodes;
                        if(grandchildren.length == 1) {
                            grandchild = grandchildren[0];
                            if(grandchild.nodeType == 3 ||
                               grandchild.nodeType == 4) {
                                name = (child.prefix) ?
                                        child.nodeName.split(":")[1] :
                                        child.nodeName;
                                value = grandchild.nodeValue.replace(
                                                this.regExes.trimSpace, "");
                                attributes[name] = value;
                            }
                        } else {
                            // If child has no childNodes (grandchildren),
                            // set an attribute with null value.
                            // e.g. <prefix:fieldname/> becomes
                            // {fieldname: null}
                            attributes[child.nodeName.split(":").pop()] = null;
                        }
                    }
                }
                break;
            }
            childNode = childNode.nextSibling;
        }
        return attributes;
    },
    
    /**
     * 根据要素数组生成GML格式数据。
     * Generate a GML document string given a list of features.
     * @memberof GeoGlobe.Format.GML.prototype
     * @param {Array(GeoGlobe.Feature.Vector)}features - 要序列化为字符串的要素列表。
     * @returns {String} 代表GML文档的字符串。
     */
    write: function(features) {
        if(!(GeoGlobe.Util.isArray(features))) {
            features = [features];
        }
        var gml = this.createElementNS("http://www.opengis.net/wfs",
                                       "wfs:" + this.collectionName);
        for(var i=0; i<features.length; i++) {
            gml.appendChild(this.createFeatureXML(features[i]));
        }
        return GeoGlobe.Format.XML.prototype.write.apply(this, [gml]);
    },

    /**
     *  Accept an GeoGlobe.Feature.Vector, and build a GML node for it.
     * @memberof GeoGlobe.Format.GML.prototype
     * @param {GeoGlobe.Feature.Vector}feature - The feature to be built as GML.
     * @returns {DOMElement} A node reprensting the feature in GML.
     * @private
     */
    createFeatureXML: function(feature) {
        var geometry = feature.geometry;
        var geometryNode = this.buildGeometryNode(geometry);
        var geomContainer = this.createElementNS(this.featureNS,
                                                 this.featurePrefix + ":" +
                                                 this.geometryName);
        geomContainer.appendChild(geometryNode);
        var featureNode = this.createElementNS(this.gmlns,
                                               "gml:" + this.featureName);
        var featureContainer = this.createElementNS(this.featureNS,
                                                    this.featurePrefix + ":" +
                                                    this.layerName);
        var fid = feature.fid || feature.id;
        featureContainer.setAttribute("fid", fid);
        featureContainer.appendChild(geomContainer);
        for(var attr in feature.attributes) {
            var attrText = this.createTextNode(feature.attributes[attr]); 
            var nodename = attr.substring(attr.lastIndexOf(":") + 1);
            var attrContainer = this.createElementNS(this.featureNS,
                                                     this.featurePrefix + ":" +
                                                     nodename);
            attrContainer.appendChild(attrText);
            featureContainer.appendChild(attrContainer);
        }    
        featureNode.appendChild(featureContainer);
        return featureNode;
    },
    
    /**
     * 根据geometry生成GML格式数据。
     * @memberof GeoGlobe.Format.GML.prototype
     */
    buildGeometryNode: function(geometry) {
        if (this.externalProjection && this.internalProjection) {
            geometry = geometry.clone();
            geometry.transform(this.internalProjection, 
                               this.externalProjection);
        }    
        var className = geometry.CLASS_NAME;
        var type = className.substring(className.lastIndexOf(".") + 1);
        var builder = this.buildGeometry[type.toLowerCase()];
        return builder.apply(this, [geometry]);
    },

    /**
     *  Object containing methods to do the actual geometry node building based on geometry type.
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {null}
     * @private
     *
     */
    buildGeometry: {
        // TBD retrieve the srs from layer
        // srsName is non-standard, so not including it until it's right.
        // gml.setAttribute("srsName",
        //                  "http://www.opengis.net/gml/srs/epsg.xml#4326");

        /**
         * Given an GeoGlobe point geometry, create a GML point.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.Point}geometry -  A point geometry.
         * @returns {DOMElement} A GML point node.
         * @private
         */
        point: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:Point");
            gml.appendChild(this.buildCoordinatesNode(geometry));
            return gml;
        },
        
        /**
         *  Given an GeoGlobe multipoint geometry, create a GML multipoint.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.MultiPoint}geometry - A multipoint geometry.
         * @returns {DOMElement} A GML multipoint node.
         * @private
         */
        multipoint: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:MultiPoint");
            var points = geometry.components;
            var pointMember, pointGeom;
            for(var i=0; i<points.length; i++) { 
                pointMember = this.createElementNS(this.gmlns,
                                                   "gml:pointMember");
                pointGeom = this.buildGeometry.point.apply(this,
                                                               [points[i]]);
                pointMember.appendChild(pointGeom);
                gml.appendChild(pointMember);
            }
            return gml;            
        },
        
        /**
         *  Given an GeoGlobe linestring geometry, create a GML linestring.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.LineString}  geometry -A linestring geometry.
         * @returns {DOMElement} A GML linestring node.
         * @private
         */
        linestring: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:LineString");
            gml.appendChild(this.buildCoordinatesNode(geometry));
            return gml;
        },
        
        /**
         * Given an GeoGlobe multilinestring geometry, create a GML
         *     multilinestring.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.MultiLineString}geometry -  A multilinestring
         *     geometry.
         * @returns {DOMElement} A GML multilinestring node.
         * @private
         */
        multilinestring: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:MultiLineString");
            var lines = geometry.components;
            var lineMember, lineGeom;
            for(var i=0; i<lines.length; ++i) {
                lineMember = this.createElementNS(this.gmlns,
                                                  "gml:lineStringMember");
                lineGeom = this.buildGeometry.linestring.apply(this,
                                                                   [lines[i]]);
                lineMember.appendChild(lineGeom);
                gml.appendChild(lineMember);
            }
            return gml;
        },
        
        /**
         * Given an GeoGlobe linearring geometry, create a GML linearring.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.LinearRing}geometry -  A linearring geometry.
         * @returns {DOMElement} A GML linearring node.
         * @private
         */
        linearring: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:LinearRing");
            gml.appendChild(this.buildCoordinatesNode(geometry));
            return gml;
        },
        
        /**
         * Given an GeoGlobe polygon geometry, create a GML polygon.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.Polygon} geometry - A polygon geometry.
         *
         * @returns {DOMElement} A GML polygon node.
         * @private
         */
        polygon: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:Polygon");
            var rings = geometry.components;
            var ringMember, ringGeom, type;
            for(var i=0; i<rings.length; ++i) {
                type = (i==0) ? "outerBoundaryIs" : "innerBoundaryIs";
                ringMember = this.createElementNS(this.gmlns,
                                                  "gml:" + type);
                ringGeom = this.buildGeometry.linearring.apply(this,
                                                                   [rings[i]]);
                ringMember.appendChild(ringGeom);
                gml.appendChild(ringMember);
            }
            return gml;
        },
        
        /**
         * Given an GeoGlobe multipolygon geometry, create a GML multipolygon.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.MultiPolygon}geometry -  A multipolygon
         *     geometry.
         * @returns {DOMElement} A GML multipolygon node.
         * @private
         */
        multipolygon: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:MultiPolygon");
            var polys = geometry.components;
            var polyMember, polyGeom;
            for(var i=0; i<polys.length; ++i) {
                polyMember = this.createElementNS(this.gmlns,
                                                  "gml:polygonMember");
                polyGeom = this.buildGeometry.polygon.apply(this,
                                                                [polys[i]]);
                polyMember.appendChild(polyGeom);
                gml.appendChild(polyMember);
            }
            return gml;

        },
        
        /**
         * Given an GeoGlobe bounds, create a GML box.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.Bounds}bounds - A bounds object.
         *
         * @returns {DOMElement} A GML box node.
         * @private
         */
        //bounds: function(bounds) {
            //var gml = this.createElementNS(this.gmlns, "gml:Box");
            //gml.appendChild(this.buildCoordinatesNode(bounds));
            //return gml;
        //},
 
        /**
         * Given an GeoGlobe bounds, create a GML box.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.Bounds}bounds - A bounds object.
         * @returns {DOMElement} A GML box node.
         * @private
         */
        lnglatbounds: function(bounds) {
            var gml = this.createElementNS(this.gmlns, "gml:Box");
            gml.appendChild(this.buildCoordinatesNode(bounds));
            return gml;
        }
    },

    /**
     * builds the coordinates XmlNode
     * (code)
     * gml:coordinates decimal="." cs="," ts=" ">.../gml:coordinates
     * (end)
     * @memberof GeoGlobe.Format.GML.prototype
     * @param {GeoGlobe.Geometry} geometry -
     * @returns {XmlNode} created xmlNode
     * @private
     */
    buildCoordinatesNode: function(geometry) {
        var coordinatesNode = this.createElementNS(this.gmlns,
                                                   "gml:coordinates");
        coordinatesNode.setAttribute("decimal", ".");
        coordinatesNode.setAttribute("cs", ",");
        coordinatesNode.setAttribute("ts", " ");

        var parts = [];

        if(geometry instanceof GeoGlobe.LngLatBounds){//GeoGlobe
            parts.push(geometry.getWest() + "," + geometry.getSouth());
            parts.push(geometry.getEast() + "," + geometry.getNorth());
        } else {
            var points = (geometry.components) ? geometry.components : [geometry];
            for(var i=0; i<points.length; i++) {
                parts.push(points[i].x + "," + points[i].y);                
            }            
        }

        var txtNode = this.createTextNode(parts.join(" "));
        coordinatesNode.appendChild(txtNode);
        
        return coordinatesNode;
    },

    CLASS_NAME: "GeoGlobe.Format.GML"
});

/** Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */


/**
 * 虽然在完整版本中是必需的，但如果排除GML格式，我们在这里设置命名空间。
 */
if(!GeoGlobe.Format.GML) {
    GeoGlobe.Format.GML = {};
}

/**
 * @class  GeoGlobe.Format.GML.Base
 * @classdesc GMLv2与GMLv3的基类 Superclass for GML parsers.Inherits from:GeoGlobe.Format.XML
 *
 */
GeoGlobe.Format.GML.Base = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     *  Mapping of namespace aliases to namespace URIs.
     *@memberof GeoGlobe.Format.GML.Base.prototype
     *@type {Object}
     *@private
     */
    namespaces: {
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs" // this is a convenience for reading wfs:FeatureCollection
    },
    
    /**
     *
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @private
     */
    defaultPrefix: "gml",

    /**
     *  Schema location for a particular minor version.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @type {String}
     * @private
     */
    schemaLocation: null,
    
    /**
     *本地（无前缀）功能类型名称（s）。
     * @memberof GeoGlobe.Base.prototype
     *  @type {Array(String)| String}
     */
    featureType: null,
    
    /**
     * 功能命名空间。 必须在构造选项中进行设置。
     * @memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {String}
     */
    featureNS: null,

    /**
     *几何元素的名称。 默认为“几何”。 如果为null，则在解析第一个几何图形时将设置为read。
     * @memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {String}
     */
    geometryName: "geometry",

    /**
     *从GML中提取属性。 默认值是true。
     * @memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {Boolean}
     */
    extractAttributes: true,
    
    /**
     * 空间参考系统的URI。 
     * 这对于单个部分几何体是可选的，对于集合体和多重体是必需的。 
     * 如果设置，则会为所有几何图形编写srsName属性.
     * Default为空。
     *  @memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {String}
     */
    srsName: null,

    /**
     *GML坐标的顺序true：（x，y）或false：（y，x）不建议更改，应该实例化新的Format。
     *@memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {Boolean}
     */ 
    xy: true,

    /**
     * Maps GeoGlobe geometry class names to GML element names.
     *     Use setGeometry Types before accessing this property.
     *    @memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {Object}
     */
    geometryTypes: null,

    /**

     * {Boolean} True if there is only 1 featureType, and not an array
     *     of featuretypes.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @type {Boolean}
     * @private
     */
    singleFeatureType: null,
    
    /**

     *  Indicates if the format was configured without a featureNS,
     * but auto-configured  featureNS and featureType> during read.
     * Subclasses making use of featureType auto-configuration should make
     * the first call to the readNode method (usually in the read method)
     * with true as 3rd argument, so the auto-configured featureType can be
     * reset and the format can be reused for subsequent reads with data from
     * different featureTypes. Set to false after read if you want to keep the
     * auto-configured values.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {Boolean}
     */


    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @private

     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g),
        featureMember: (/^(.*:)?featureMembers?$/)
    },

    /**

     *这个类的实例不是直接创建的。 改为使用GeoGlobe.Format.GML.v2或GeoGlobe.Format.GML.v3构造函数。
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @type {Boolean}
     * @param {Object}选项 - 一个可选对象，其属性将在此实例上设置。
     *
     * 有效的选项属性：

     * @param {Array(String) | String} featuretype - 本地（无前缀）功能typeName（s）（写入所需）。
     * @param {String} featureNS -  功能名称空间（写入所需）。
     * @param {String} geometryName - 几何元素名称（写入所需）。
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
        this.setGeometryTypes();
        if(options && options.featureNS) {
            this.setNamespace("feature", options.featureNS);
        }
        this.singleFeatureType = !options || (typeof options.featureType === "string");
    },
    
    /**

     *@memberof GeoGlobe.Format.GML.Base.prototype
     * @param {DOMElement} data - A gml:featureMember element, a gml:featureMembers
     *     element, or an element containing either of the above at any level.
     *
     * @returns {Array(GeoGlobe.Feature)} An array of features.
     * @private
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var features = [];
        this.readNode(data, {features: features}, true);
        if(features.length == 0) {
            // look for gml:featureMember elements
            var elements = this.getElementsByTagNameNS(
                data, this.namespaces.gml, "featureMember"
            );
            if(elements.length) {
                for(var i=0, len=elements.length; i<len; ++i) {
                    this.readNode(elements[i], {features: features}, true);
                }
            } else {
                // look for gml:featureMembers elements (this is v3, but does no harm here)
                var elements = this.getElementsByTagNameNS(
                    data, this.namespaces.gml, "featureMembers"
                );
                if(elements.length) {
                    // there can be only one
                    this.readNode(elements[0], {features: features}, true);
                }
            }
        }
        return features;
    },
    
    /**

     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     *@memberof GeoGlobe.Format.GML.Base.prototype

     *@param  {DOMElement} node -The node to be read (required).
     *@param {Object}  obj - The object to be modified (optional).
     *@param  {Boolean}first - Should be set to true for the first node read. This
     *     is usually the readNode call in the read method. Without this being
     *     set, auto-configured properties will stick on subsequent reads.
     *
     * @returns {Object} The input object, modified (or a new one if none was provided).
     * @private
     */
    readNode: function(node, obj, first) {
        // on subsequent calls of format.read(), we want to reset auto-
        // configured properties and auto-configure again.
        if (first === true && this.autoConfig === true) {
            this.featureType = null;
            delete this.namespaceAlias[this.featureNS];
            delete this.namespaces["feature"];
            this.featureNS = null;
        }
        // featureType auto-configuration
        if (!this.featureNS && (!(node.prefix in this.namespaces) &&
                node.parentNode.namespaceURI == this.namespaces["gml"] &&
                this.regExes.featureMember.test(node.parentNode.nodeName))) {
            this.featureType = node.nodeName.split(":").pop();
            this.setNamespace("feature", node.namespaceURI);
            this.featureNS = node.namespaceURI;
            this.autoConfig = true;
        }
        return GeoGlobe.Format.XML.prototype.readNode.apply(this, [node, obj]);
    },
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @private
     */
    readers: {
        "gml": {
            "_inherit": function(node, obj, container) {
                // To be implemented by version specific parsers
            },
            "featureMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "featureMembers": function(node, obj) {
                this.readChildNodes(node, obj);                
            },
            "name": function(node, obj) {
                obj.name = this.getChildValue(node);
            },
            "boundedBy": function(node, obj) {
                var container = {};
                this.readChildNodes(node, container);
                if(container.components && container.components.length > 0) {
                    obj.bounds = container.components[0];
                }
            },
            "Point": function(node, container) {
                var obj = {points: []};
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(obj.points[0]);
            },
            "coordinates": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, ""
                );
                str = str.replace(this.regExes.trimComma, ",");
                var pointList = str.split(this.regExes.splitSpace);
                var coords;
                var numPoints = pointList.length;
                var points = new Array(numPoints);
                for(var i=0; i<numPoints; ++i) {
                    coords = pointList[i].split(",");
                    if (this.xy) {
                        points[i] = new GeoGlobe.Geometry.Point(
                            coords[0], coords[1], coords[2]
                        );
                    } else {
                        points[i] = new GeoGlobe.Geometry.Point(
                            coords[1], coords[0], coords[2]
                        );
                    }
                }
                obj.points = points;
            },
            "coord": function(node, obj) {
                var coord = {};
                this.readChildNodes(node, coord);
                if(!obj.points) {
                    obj.points = [];
                }
                obj.points.push(new GeoGlobe.Geometry.Point(
                    coord.x, coord.y, coord.z
                ));
            },
            "X": function(node, coord) {
                coord.x = this.getChildValue(node);
            },
            "Y": function(node, coord) {
                coord.y = this.getChildValue(node);
            },
            "Z": function(node, coord) {
                coord.z = this.getChildValue(node);
            },
            "MultiPoint": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new GeoGlobe.Geometry.MultiPoint(obj.components)
                ];
            },
            "pointMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "LineString": function(node, container) {
                var obj = {};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(
                    new GeoGlobe.Geometry.LineString(obj.points)
                );
            },
            "MultiLineString": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new GeoGlobe.Geometry.MultiLineString(obj.components)
                ];
            },
            "lineStringMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Polygon": function(node, container) {
                var obj = {outer: null, inner: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                obj.inner.unshift(obj.outer);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(
                    new GeoGlobe.Geometry.Polygon(obj.inner)
                );
            },
            "LinearRing": function(node, obj) {
                var container = {};
                this.readers.gml._inherit.apply(this, [node, container]);
                this.readChildNodes(node, container);
                obj.components = [new GeoGlobe.Geometry.LinearRing(
                    container.points
                )];
            },
            "MultiPolygon": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new GeoGlobe.Geometry.MultiPolygon(obj.components)
                ];
            },
            "polygonMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "GeometryCollection": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new GeoGlobe.Geometry.Collection(obj.components)
                ];
            },
            "geometryMember": function(node, obj) {
                this.readChildNodes(node, obj);
            }
        },
        "feature": {
            "*": function(node, obj) {
                // The node can either be named like the featureType, or it
                // can be a child of the feature:featureType.  Children can be
                // geometry or attributes.
                var name;
                var local = node.localName || node.nodeName.split(":").pop();
                // Since an attribute can have the same name as the feature type
                // we only want to read the node as a feature if the parent
                // node can have feature nodes as children.  In this case, the
                // obj.features property is set.
                if (obj.features) {
                    if (!this.singleFeatureType &&
                        (GeoGlobe.Util.indexOf(this.featureType, local) !== -1)) {
                        name = "_typeName";
                    } else if(local === this.featureType) {
                        name = "_typeName";
                    }else if(GeoGlobe.Util.isArray(this.featureType_)) {
						//this.featureType_属性是补丁中新增的属性，目的是让解析器能解析多个图层的数据。
						for(var i = 0; i < this.featureType_.length;i++) {
							if(this.featureType_[i] === local) {
								name = "_typeName";
								break;
							}
						}
					}
                } else {
                    // Assume attribute elements have one child node and that the child
                    // is a text node.  Otherwise assume it is a geometry node.
                    if(node.childNodes.length == 0 ||
                       (node.childNodes.length == 1 && node.firstChild.nodeType == 3)) {
                        if(this.extractAttributes) {
                            name = "_attribute";
                        }
                    } else {
                        name = "_geometry";
                    }
                }
                if(name) {
                    this.readers.feature[name].apply(this, [node, obj]);
                }
            },
            "_typeName": function(node, obj) {
                var container = {components: [], attributes: {}};
                this.readChildNodes(node, container);
                // look for common gml namespaced elements
                if(container.name) {
                    container.attributes.name = container.name;
                }
                var feature = new GeoGlobe.Feature(
                    container.components[0], container.attributes
                );
                if (!this.singleFeatureType) {
                    feature.type = node.nodeName.split(":").pop();
                    feature.namespace = node.namespaceURI;
                }
                var fid = node.getAttribute("fid") ||
                    this.getAttributeNS(node, this.namespaces["gml"], "id");
                if(fid) {
                    feature.fid = fid;
                }
                if(this.internalProjection && this.externalProjection &&
                   feature.geometry) {
                    feature.geometry.transform(
                        this.externalProjection, this.internalProjection
                    );
                }
                if(container.bounds) {
                    feature.bounds = container.bounds;
                }
                obj.features.push(feature);
            },
            "_geometry": function(node, obj) {
                if (!this.geometryName) {
                    this.geometryName = node.nodeName.split(":").pop();
                }
                this.readChildNodes(node, obj);
            },
            "_attribute": function(node, obj) {
                var local = node.localName || node.nodeName.split(":").pop();
                var value = this.getChildValue(node);
                obj.attributes[local] = value;
            }
        },
        "wfs": {
            "FeatureCollection": function(node, obj) {
                this.readChildNodes(node, obj);
            }
        }
    },
    
    /**

     *@memberof GeoGlobe.Base.prototype
     * @param {Array(GeoGlobe.Feature) | GeoGlobe.Feature} features -
     *     An array of features or a single feature.
     *
     * @returns
     * {String} Given an array of features, a doc with a gml:featureMembers
     *     element will be returned.  Given a single feature, a doc with a
     *     gml:featureMember element will be returned.
     * @private
     */
    write: function(features) {
        var name;
        if(GeoGlobe.Util.isArray(features)) {
            name = "featureMembers";
        } else {
            name = "featureMember";
        }
        var root = this.writeNode("gml:" + name, features);
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );

        return GeoGlobe.Format.XML.prototype.write.apply(this, [root]);
    },
    
    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @private
     */
    writers: {
        "gml": {
            "featureMember": function(feature) {
                var node = this.createElementNSPlus("gml:featureMember");
                this.writeNode("feature:_typeName", feature, node);
                return node;
            },
            "MultiPoint": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiPoint");
                var components = geometry.components || [geometry];
                for(var i=0, ii=components.length; i<ii; ++i) {
                    this.writeNode("pointMember", components[i], node);
                }
                return node;
            },
            "pointMember": function(geometry) {
                var node = this.createElementNSPlus("gml:pointMember");
                this.writeNode("Point", geometry, node);
                return node;
            },
            "MultiLineString": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiLineString");
                var components = geometry.components || [geometry];
                for(var i=0, ii=components.length; i<ii; ++i) {
                    this.writeNode("lineStringMember", components[i], node);
                }
                return node;
            },
            "lineStringMember": function(geometry) {
                var node = this.createElementNSPlus("gml:lineStringMember");
                this.writeNode("LineString", geometry, node);
                return node;
            },
            "MultiPolygon": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiPolygon");
                var components = geometry.components || [geometry];
                for(var i=0, ii=components.length; i<ii; ++i) {
                    this.writeNode(
                        "polygonMember", components[i], node
                    );
                }
                return node;
            },
            "polygonMember": function(geometry) {
                var node = this.createElementNSPlus("gml:polygonMember");
                this.writeNode("Polygon", geometry, node);
                return node;
            },
            "GeometryCollection": function(geometry) {
                var node = this.createElementNSPlus("gml:GeometryCollection");
                for(var i=0, len=geometry.components.length; i<len; ++i) {
                    this.writeNode("geometryMember", geometry.components[i], node);
                }
                return node;
            },
            "geometryMember": function(geometry) {
                var node = this.createElementNSPlus("gml:geometryMember");
                var child = this.writeNode("feature:_geometry", geometry);
                node.appendChild(child.firstChild);
                return node;
            }
        },
        "feature": {
            "_typeName": function(feature) {
                var node = this.createElementNSPlus("feature:" + this.featureType, {
                    attributes: {fid: feature.fid}
                });
                if(feature.geometry) {
                    this.writeNode("feature:_geometry", feature.geometry, node);
                }
                for(var name in feature.attributes) {
                    var value = feature.attributes[name];
                    if(value != null) {
                        this.writeNode(
                            "feature:_attribute",
                            {name: name, value: value}, node
                        );
                    }
                }
                return node;
            },
            "_geometry": function(geometry) {
                if(this.externalProjection && this.internalProjection) {
                    geometry = geometry.clone().transform(
                        this.internalProjection, this.externalProjection
                    );
                }    
                var node = this.createElementNSPlus(
                    "feature:" + this.geometryName
                );
                var type = this.geometryTypes[geometry.CLASS_NAME];
                var child = this.writeNode("gml:" + type, geometry, node);
                if(this.srsName) {
                    child.setAttribute("srsName", this.srsName);
                }
                return node;
            },
            "_attribute": function(obj) {
                return this.createElementNSPlus("feature:" + obj.name, {
                    value: obj.value
                });
            }
        },
        "wfs": {
            "FeatureCollection": function(features) {
                /**
                 * This is only here because GML2 only describes abstract
                 * feature collections.  Typically, you would not be using
                 * the GML format to write wfs elements.  This just provides
                 * some way to write out lists of features.  GML3 defines the
                 * featureMembers element, so that is used by default instead.
                 */
                var node = this.createElementNSPlus("wfs:FeatureCollection");
                for(var i=0, len=features.length; i<len; ++i) {
                    this.writeNode("gml:featureMember", features[i], node);
                }
                return node;
            }
        }
    },
    
    /**

     * Sets the geometryTypes mapping.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @private
     */
    setGeometryTypes: function() {
        this.geometryTypes = {
            "GeoGlobe.Geometry.Point": "Point",
            "GeoGlobe.Geometry.MultiPoint": "MultiPoint",
            "GeoGlobe.Geometry.LineString": "LineString",
            "GeoGlobe.Geometry.MultiLineString": "MultiLineString",
            "GeoGlobe.Geometry.Polygon": "Polygon",
            "GeoGlobe.Geometry.MultiPolygon": "MultiPolygon",
            "GeoGlobe.Geometry.Collection": "GeometryCollection"
        };
    },
	
    /**

     * 增加featureType_属性，让gml解析器能解析多个图层的数据。
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @private
     */
	setFeatureType_: function(featureType) {
		this.featureType_ = featureType;
	},

    CLASS_NAME: "GeoGlobe.Format.GML.Base"

});

/** Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */


/**
 * @class  GeoGlobe.Format.GML.v2

 * @classdesc 解析GML文件类（V2版本当服务版本不是1.1.0时使用）。Parses GML version 2.
 *
 * Inherits from:
 *  - GeoGlobe.Format.GML.Base
 */
GeoGlobe.Format.GML.v2 = GeoGlobe.Class4OL(GeoGlobe.Format.GML.Base, {
    
    

    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/2.1.2/feature.xsd",

    /**
     * Constructor: GeoGlobe.Format.GML.v2
     * 为GML v2创建一个解析器。
     *@memberof GeoGlobe.Format.GML.v2.prototype
     * @param {Object}options - 一个可选对象，其属性将在此实例上设置。
     *
     * 有效的选项属性：
     * featureType - {String} 本地（无前缀）功能typeName（必需）。
     * featureNS - {String} 功能名称空间（必需）。
     * geometryName - {String} 几何元素名称。
     */
    initialize: function(options) {
        GeoGlobe.Format.GML.Base.prototype.initialize.apply(this, [options]);
    },

    /**
     * readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.GML.v2.prototype
     * @private
     */
    readers: {
        "gml": GeoGlobe.Util.applyDefaults({
            "outerBoundaryIs": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.outer = obj.components[0];
            },
            "innerBoundaryIs": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.inner.push(obj.components[0]);
            },
            "Box": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                var min = obj.points[0];
                var max = obj.points[1];
                var sw = new GeoGlobe.LngLat(min.x, min.y);
     			var ne = new GeoGlobe.LngLat(max.x, max.y);
                container.components.push(
                    new GeoGlobe.LngLatBounds(sw, ne)
                );
            }
        }, GeoGlobe.Format.GML.Base.prototype.readers["gml"]),
        "feature": GeoGlobe.Format.GML.Base.prototype.readers["feature"],
        "wfs": GeoGlobe.Format.GML.Base.prototype.readers["wfs"]
    },

    /**
     *  @memberof GeoGlobe.Format.GML.v2.prototype

     * @param features - {Array(GeoGlobe.Feature) | GeoGlobe.Feature
     *     An array of features or a single feature.
     *
     * @returns {String} Given an array of features, a doc with a gml:featureMembers
     *     element will be returned.  Given a single feature, a doc with a
     *     gml:featureMember element will be returned.
     * @private
     */
    write: function(features) {
        var name;
        if(GeoGlobe.Util.isArray(features)) {
            // GML2 only has abstract feature collections
            // wfs provides a feature collection from a well-known schema
            name = "wfs:FeatureCollection";
        } else {
            name = "gml:featureMember";
        }
        var root = this.writeNode(name, features);
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );

        return GeoGlobe.Format.XML.prototype.write.apply(this, [root]);
    },

    /**
     *  writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.GML.v2.prototype
     * @private
     */
    writers: {
        "gml": GeoGlobe.Util.applyDefaults({
            "Point": function(geometry) {
                var node = this.createElementNSPlus("gml:Point");
                this.writeNode("coordinates", [geometry], node);
                return node;
            },
            "coordinates": function(points) {
                var numPoints = points.length;
                var parts = new Array(numPoints);
                var point;
                for(var i=0; i<numPoints; ++i) {
                    point = points[i];
                    if(this.xy) {
                        parts[i] = point.x + "," + point.y;
                    } else {
                        parts[i] = point.y + "," + point.x;
                    }
                    if(point.z != undefined) { // allow null or undefined
                        parts[i] += "," + point.z;
                    }
                }
                return this.createElementNSPlus("gml:coordinates", {
                    attributes: {
                        decimal: ".", cs: ",", ts: " "
                    },
                    value: (numPoints == 1) ? parts[0] : parts.join(" ")
                });
            },
            "LineString": function(geometry) {
                var node = this.createElementNSPlus("gml:LineString");
                this.writeNode("coordinates", geometry.components, node);
                return node;
            },
            "Polygon": function(geometry) {
                var node = this.createElementNSPlus("gml:Polygon");
                this.writeNode("outerBoundaryIs", geometry.components[0], node);
                for(var i=1; i<geometry.components.length; ++i) {
                    this.writeNode(
                        "innerBoundaryIs", geometry.components[i], node
                    );
                }
                return node;
            },
            "outerBoundaryIs": function(ring) {
                var node = this.createElementNSPlus("gml:outerBoundaryIs");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "innerBoundaryIs": function(ring) {
                var node = this.createElementNSPlus("gml:innerBoundaryIs");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "LinearRing": function(ring) {
                var node = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("coordinates", ring.components, node);
                return node;
            },
            "Box": function(bounds) {
                var node = this.createElementNSPlus("gml:Box");
                this.writeNode("coordinates", [
                    {x: bounds._sw.lng, y: bounds._sw.lat},
                    {x: bounds._ne.lng, y: bounds._ne.lat}
                ], node);
                // srsName attribute is optional for gml:Box
                if(this.srsName) {
                    node.setAttribute("srsName", this.srsName);
                }
                return node;
            }
        }, GeoGlobe.Format.GML.Base.prototype.writers["gml"]),
        "feature": GeoGlobe.Format.GML.Base.prototype.writers["feature"],
        "wfs": GeoGlobe.Format.GML.Base.prototype.writers["wfs"]
    },
    
    CLASS_NAME: "GeoGlobe.Format.GML.v2"

});

/** Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */



/**
 * @class  GeoGlobe.Format.GML.v2

 * @classdesc 解析GML文件类（V3版本当服务版本是1.1.0时使用）。
 * Inherits from:
 *  - GeoGlobe.Format.GML.Base
 */
GeoGlobe.Format.GML.v3 = GeoGlobe.Class4OL(GeoGlobe.Format.GML.Base, {
    
    /**
     *Schema location for a particular minor version.  The writers
     *     conform with the Simple Features Profile for GML.
     * @memberof GeoGlobe.v3.prototype
     * @type {String}
     * @private
     */
    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd",

    /**
     *  Write gml:Curve instead of gml:LineString elements.  This also
     *     affects the elements in multi-part geometries.  Default is false.
     *     To write gml:Curve elements instead of gml:LineString, set curve
     *     to true in the options to the contstructor (cannot be changed after
     *     instantiation).
     * @memberof GeoGlobe.v3.prototype
     * @type {Boolean}
     * @private
*/
    curve: false,
    
    /**
     * Write gml:MultiCurve instead of gml:MultiLineString.  Since
     *     the latter is deprecated in GML 3, the default is true.  To write
     *     gml:MultiLineString instead of gml:MultiCurve, set multiCurve to
     *     false in the options to the constructor (cannot be changed after
     *     instantiation).
     * @memberof GeoGlobe.v3.prototype
     * @type {Boolean}
     * @private
     */

    multiCurve: true,
    
    /**
     * Write gml:Surface instead of gml:Polygon elements.  This also
     *     affects the elements in multi-part geometries.  Default is false.
     *     To write gml:Surface elements instead of gml:Polygon, set surface
     *     to true in the options to the contstructor (cannot be changed after
     *     instantiation).
     * @memberof GeoGlobe.v3.prototype
     * @type {Boolean}
     * @private
     */
    surface: false,

    /**
     * Write gml:multiSurface instead of gml:MultiPolygon.  Since
     *     the latter is deprecated in GML 3, the default is true.  To write
     *     gml:MultiPolygon instead of gml:multiSurface, set multiSurface to
     *     false in the options to the constructor (cannot be changed after
     *     instantiation).
     * @memberof GeoGlobe.v3.prototype
     * @type {Boolean}
     * @private
     */
    multiSurface: true,

    /**
     * Constructor: GeoGlobe.Format.GML.v3
     * 为GML v3创建一个解析器。
     * @memberof GeoGlobe.v3.prototype
     * @param {Object} options - 一个可选对象，其属性将在此实例上设置。
     *
     * 有效的选项属性：
     * featureType - {String} 本地（无前缀）功能typeName（必需）。
     * featureNS - {String} 功能名称空间（必需）。
     * geometryName - {String} 几何元素名称。
     */
    initialize: function(options) {
        GeoGlobe.Format.GML.Base.prototype.initialize.apply(this, [options]);
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.v3.prototype
     * @private
     */
    readers: {
        "gml": GeoGlobe.Util.applyDefaults({
            "_inherit": function(node, obj, container) {
                // SRSReferenceGroup attributes
                var dim = parseInt(node.getAttribute("srsDimension"), 10) ||
                    (container && container.srsDimension);
                if (dim) {
                    obj.srsDimension = dim;
                }
            },
            "featureMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Curve": function(node, container) {
                var obj = {points: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(
                    new GeoGlobe.Geometry.LineString(obj.points)
                );
            },
            "segments": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "LineStringSegment": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                if(obj.points) {
                    Array.prototype.push.apply(container.points, obj.points);
                }
            },
            "pos": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, ""
                );
                var coords = str.split(this.regExes.splitSpace);
                var point;
                if(this.xy) {
                    point = new GeoGlobe.Geometry.Point(
                        coords[0], coords[1], coords[2]
                    );
                } else {
                    point = new GeoGlobe.Geometry.Point(
                        coords[1], coords[0], coords[2]
                    );
                }
                obj.points = [point];
            },
            "posList": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, ""
                );
                var coords = str.split(this.regExes.splitSpace);
                // The "dimension" attribute is from the GML 3.0.1 spec.
                var dim = obj.srsDimension ||
                    parseInt(node.getAttribute("srsDimension") || node.getAttribute("dimension"), 10) || 2;
                var j, x, y, z;
                var numPoints = coords.length / dim;
                var points = new Array(numPoints);
                for(var i=0, len=coords.length; i<len; i += dim) {
                    x = coords[i];
                    y = coords[i+1];
                    z = (dim == 2) ? undefined : coords[i+2];
                    if (this.xy) {
                        points[i/dim] = new GeoGlobe.Geometry.Point(x, y, z);
                    } else {
                        points[i/dim] = new GeoGlobe.Geometry.Point(y, x, z);
                    }
                }
                obj.points = points;
            },
            "Surface": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "patches": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "PolygonPatch": function(node, obj) {
                this.readers.gml.Polygon.apply(this, [node, obj]);
            },
            "exterior": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.outer = obj.components[0];
            },
            "interior": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.inner.push(obj.components[0]);
            },
            "MultiCurve": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(obj.components.length > 0) {
                    container.components = [
                        new GeoGlobe.Geometry.MultiLineString(obj.components)
                    ];
                }
            },
            "curveMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "MultiSurface": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(obj.components.length > 0) {
                    container.components = [
                        new GeoGlobe.Geometry.MultiPolygon(obj.components)
                    ];
                }
            },
            "surfaceMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "surfaceMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "pointMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "lineStringMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "polygonMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "geometryMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Envelope": function(node, container) {
                var obj = {points: new Array(2)};
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                var min = obj.points[0];
                var max = obj.points[1];
                var sw = new GeoGlobe.LngLat(min.x, min.y);
     			var ne = new GeoGlobe.LngLat(max.x, max.y);
                container.components.push(
                    new GeoGlobe.LngLatBounds(sw, ne)
                );
            },
            "lowerCorner": function(node, container) {
                var obj = {};
                this.readers.gml.pos.apply(this, [node, obj]);
                container.points[0] = obj.points[0];
            },
            "upperCorner": function(node, container) {
                var obj = {};
                this.readers.gml.pos.apply(this, [node, obj]);
                container.points[1] = obj.points[0];
            }
        }, GeoGlobe.Format.GML.Base.prototype.readers["gml"]),            
        "feature": GeoGlobe.Format.GML.Base.prototype.readers["feature"],
        "wfs": GeoGlobe.Format.GML.Base.prototype.readers["wfs"]
    },
    
    /**

     * @memberof GeoGlobe.v3.prototype
     * @param {Array(GeoGlobe.Feature) | GeoGlobe.Feature}features -
     *     An array of features or a single feature.
     *
     * @returns {String} Given an array of features, a doc with a gml:featureMembers
     *     element will be returned.  Given a single feature, a doc with a
     *     gml:featureMember element will be returned.
     * @private
     */
    write: function(features) {
        var name;
        if(GeoGlobe.Util.isArray(features)) {
            name = "featureMembers";
        } else {
            name = "featureMember";
        }
        var root = this.writeNode("gml:" + name, features);
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );

        return GeoGlobe.Format.XML.prototype.write.apply(this, [root]);
    },

    /**
     *  writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.v3.prototype
     * @private
     */
    writers: {
        "gml": GeoGlobe.Util.applyDefaults({
            "featureMembers": function(features) {
                var node = this.createElementNSPlus("gml:featureMembers");
                for(var i=0, len=features.length; i<len; ++i) {
                    this.writeNode("feature:_typeName", features[i], node);
                }
                return node;
            },
            "Point": function(geometry) {
                var node = this.createElementNSPlus("gml:Point");
                this.writeNode("pos", geometry, node);
                return node;
            },
            "pos": function(point) {
                // only 2d for simple features profile
                var pos = (this.xy) ?
                    (point.x + " " + point.y) : (point.y + " " + point.x);
                return this.createElementNSPlus("gml:pos", {
                    value: pos
                });
            },
            "LineString": function(geometry) {
                var node = this.createElementNSPlus("gml:LineString");
                this.writeNode("posList", geometry.components, node);
                return node;
            },
            "Curve": function(geometry) {
                var node = this.createElementNSPlus("gml:Curve");
                this.writeNode("segments", geometry, node);
                return node;
            },
            "segments": function(geometry) {
                var node = this.createElementNSPlus("gml:segments");
                this.writeNode("LineStringSegment", geometry, node);
                return node;
            },
            "LineStringSegment": function(geometry) {
                var node = this.createElementNSPlus("gml:LineStringSegment");
                this.writeNode("posList", geometry.components, node);
                return node;
            },
            "posList": function(points) {
                // only 2d for simple features profile
                var len = points.length;
                var parts = new Array(len);
                var point;
                for(var i=0; i<len; ++i) {
                    point = points[i];
                    if(this.xy) {
                        parts[i] = point.x + " " + point.y;
                    } else {
                        parts[i] = point.y + " " + point.x;
                    }
                }
                return this.createElementNSPlus("gml:posList", {
                    value: parts.join(" ")
                }); 
            },
            "Surface": function(geometry) {
                var node = this.createElementNSPlus("gml:Surface");
                this.writeNode("patches", geometry, node);
                return node;
            },
            "patches": function(geometry) {
                var node = this.createElementNSPlus("gml:patches");
                this.writeNode("PolygonPatch", geometry, node);
                return node;
            },
            "PolygonPatch": function(geometry) {
                var node = this.createElementNSPlus("gml:PolygonPatch", {
                    attributes: {interpolation: "planar"}
                });
                this.writeNode("exterior", geometry.components[0], node);
                for(var i=1, len=geometry.components.length; i<len; ++i) {
                    this.writeNode(
                        "interior", geometry.components[i], node
                    );
                }
                return node;
            },
            "Polygon": function(geometry) {
                var node = this.createElementNSPlus("gml:Polygon");
                this.writeNode("exterior", geometry.components[0], node);
                for(var i=1, len=geometry.components.length; i<len; ++i) {
                    this.writeNode(
                        "interior", geometry.components[i], node
                    );
                }
                return node;
            },
            "exterior": function(ring) {
                var node = this.createElementNSPlus("gml:exterior");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "interior": function(ring) {
                var node = this.createElementNSPlus("gml:interior");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "LinearRing": function(ring) {
                var node = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("posList", ring.components, node);
                return node;
            },
            "MultiCurve": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiCurve");
                var components = geometry.components || [geometry];
                for(var i=0, len=components.length; i<len; ++i) {
                    this.writeNode("curveMember", components[i], node);
                }
                return node;
            },
            "curveMember": function(geometry) {
                var node = this.createElementNSPlus("gml:curveMember");
                if(this.curve) {
                    this.writeNode("Curve", geometry, node);
                } else {
                    this.writeNode("LineString", geometry, node);
                }
                return node;
            },
            "MultiSurface": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiSurface");
                var components = geometry.components || [geometry];
                for(var i=0, len=components.length; i<len; ++i) {
                    this.writeNode("surfaceMember", components[i], node);
                }
                return node;
            },
            "surfaceMember": function(polygon) {
                var node = this.createElementNSPlus("gml:surfaceMember");
                if(this.surface) {
                    this.writeNode("Surface", polygon, node);
                } else {
                    this.writeNode("Polygon", polygon, node);
                }
                return node;
            },
            "Envelope": function(bounds) {
                var node = this.createElementNSPlus("gml:Envelope");
                this.writeNode("lowerCorner", bounds, node);
                this.writeNode("upperCorner", bounds, node);
                // srsName attribute is required for gml:Envelope
                if(this.srsName) {
                    node.setAttribute("srsName", this.srsName);
                }
                return node;
            },
            "lowerCorner": function(bounds) {
                // only 2d for simple features profile
                var pos = (this.xy) ?
                    (bounds._sw.lng + " " + bounds._sw.lat) :
                    (bounds._sw.lat + " " + bounds._sw.lng);
                return this.createElementNSPlus("gml:lowerCorner", {
                    value: pos
                });
            },
            "upperCorner": function(bounds) {
                // only 2d for simple features profile
                var pos = (this.xy) ?
                    (bounds._ne.lng + " " + bounds._ne.lat) :
                    (bounds._ne.lat + " " + bounds._ne.lng);
                return this.createElementNSPlus("gml:upperCorner", {
                    value: pos
                });
            }
        }, GeoGlobe.Format.GML.Base.prototype.writers["gml"]),
        "feature": GeoGlobe.Format.GML.Base.prototype.writers["feature"],
        "wfs": GeoGlobe.Format.GML.Base.prototype.writers["wfs"]
    },

    /**

     * Sets the geometryTypes mapping.
     * @memberof GeoGlobe.v3.prototype
     * @private
     */
    setGeometryTypes: function() {
        this.geometryTypes = {
            "GeoGlobe.Geometry.Point": "Point",
            "GeoGlobe.Geometry.MultiPoint": "MultiPoint",
            "GeoGlobe.Geometry.LineString": (this.curve === true) ? "Curve": "LineString",
            "GeoGlobe.Geometry.MultiLineString": (this.multiCurve === false) ? "MultiLineString" : "MultiCurve",
            "GeoGlobe.Geometry.Polygon": (this.surface === true) ? "Surface" : "Polygon",
            "GeoGlobe.Geometry.MultiPolygon": (this.multiSurface === false) ? "MultiPolygon" : "MultiSurface",
            "GeoGlobe.Geometry.Collection": "GeometryCollection"
        };
    },
    
    CLASS_NAME: "GeoGlobe.Format.GML.v3"

});

/**
 * @class  GeoGlobe.Format.KML
 * @classdesc 读/写KML。 用GeoGlobe.Format.KML构造函数创建一个新实例。
 * @private
 */

GeoGlobe.Format.KML = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * namespaces-Mapping of namespace aliases to namespace URIs.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        kml: "http://www.opengis.net/kml/2.2",
        gx: "http://www.google.com/kml/ext/2.2"
    },

    /**
     * kmlns- 使用KML命名空间。 默认为2.0命名空间。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {String}
     */
    kmlns: "http://earth.google.com/kml/2.0",
    
    /**
     * placemarksDesc-地标的名称。 默认值是 "No description available"。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {String}
     */
    placemarksDesc: "No description available",
    
    /**
     * foldersName- 文件夹的名称。 默认值是“GeoGlobe导出”。如果设置为null，则不会创建名称元素。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {String}
     */
    foldersName: "GeoGlobe export",
    
    /**
     * foldersDesc- 文件夹的说明。 默认值是“在[date]上导出”。如果设置为null，则不会创建任何说明元素。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {String}
     */
    foldersDesc: "Exported on " + new Date(),
    
    /**
     * extractAttributes- 从KML中提取属性。 默认值是true。
     *抽取styleUrls要求将其设置为true请注意，目前只处理Data和SimpleData元素。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Boolean}
     */
    extractAttributes: true,
    
    /**
     * kvpAttributes- 仅在extractAttributes为true时使用。
     * 如果设置为true，则属性将是简单的键值对，与其他格式兼容。
     * 任何displayName元素都将被忽略。如果设置为false，则属性将为对象，
     * 保留任何displayName元素，但不会 与其他格式兼容。 
     * displayName中的任何CDATA都将作为字符串值读入。
     * 默认为false。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Boolean}
     */
    kvpAttributes: false,
    
    /**
     * extractStyles- Extract styles from KML.  Default is false.
     *           Extracting styleUrls also requires extractAttributes to be
     *           set to true
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Boolean}
     * @private
     */
    extractStyles: false,
    
    /**
     * extractTracks- 提取gx：跟踪地标元素的元素。
     * 默认为false。 如果为true，则会为所有gx：Track元素中的所有点生成要素。 
     * 特征将具有基于轨道中元素的when（Date）属性。 
     * 如果曲目包含角度元素，则要素将具有标题，倾斜和滚动属性。 
     * 如果轨迹点坐标具有三个值，则要素将具有第三个坐标值的高度属性。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Boolean}
     */
    extractTracks: false,
    
    /**
     * trackAttributes-如果<extractTracks>为true，
     * 那么gx：Track元素中的点将被解析为具有when，heading，tilt和roll属性的特征。 
     * 任何其他属性名称都可以在<trackAttributes>中提供。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Array}
     */
    trackAttributes: null,
    
    /**
     * internalns- KML Namespace to use -- defaults to the namespace of the
     *     Placemark node being parsed, but falls back to kmlns.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {String}
     * @private
     */
    internalns: null,

    /**
     * features-Array of features
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Array}
     * @private
     */
    features: null,

    /**
     * styles- Storage of style objects
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Object}
     * @private
     */
    styles: null,
    
    /**
     * styleBaseUrl
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {String}
     * @private
     */
    styleBaseUrl: "",

    /**
     * fetched- Storage of KML URLs that have been fetched before
     *     in order to prevent reloading them.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Object}
     * @private
     */
    fetched: null,

    /**
     * 递归加载外部KML URL的最大深度默认为0：不执行外部提取
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {int}
     */
    maxDepth: 0,

    /**
     * 为KML创建一个新的解析器。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @classdesc GeoGlobe.Format.KML
     * @param {Object} options -一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        // compile regular expressions once instead of every time they are used
        this.regExes = {
            trimSpace: (/^\s*|\s*$/g),
            removeSpace: (/\s*/g),
            splitSpace: (/\s+/),
            trimComma: (/\s*,\s*/g),
            kmlColor: (/(\w{2})(\w{2})(\w{2})(\w{2})/),
            kmlIconPalette: (/root:\/\/icons\/palette-(\d+)(\.\w+)/),
            straightBracket: (/\$\[(.*?)\]/g)
        };
        // KML coordinates are always in longlat WGS84
        this.externalProjection = new GeoGlobe.SpatialReference("EPSG:4326");

        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     *  从字符串读取数据，并返回要素列表。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array}nodes   - of {DOMElement} 数据读取/解析。
     * @returns {Array(GeoGlobe.Feature)} 要素列表。
     */
    read: function(data) {
        this.features = [];
        this.styles   = {};
        this.fetched  = {};

        // Set default options 
        var options = {
            depth: 0,
            styleBaseUrl: this.styleBaseUrl
        };

        return this.parseData(data, options);
    },

    /**
     * Read data from a string, and return a list of features.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array}nodes   - of {DOMElement} data to read/parse.
     * @param {Object}options -  Hash of options
     * @returns {Array(GeoGlobe.Feature)} List of features.
     * @private
     */
    parseData: function(data, options) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }

        // Loop throught the following node types in this order and
        // process the nodes found 
        var types = ["Link", "NetworkLink", "Style", "StyleMap", "Placemark"];
        for(var i=0, len=types.length; i<len; ++i) {
            var type = types[i];

            var nodes = this.getElementsByTagNameNS(data, "*", type);

            // skip to next type if no nodes are found
            if(nodes.length == 0) { 
                continue;
            }

            switch (type.toLowerCase()) {

                // Fetch external links 
                case "link":
                case "networklink":
                    this.parseLinks(nodes, options);
                    break;

                // parse style information
                case "style":
                    if (this.extractStyles) {
                        this.parseStyles(nodes, options);
                    }
                    break;
                case "stylemap":
                    if (this.extractStyles) {
                        this.parseStyleMaps(nodes, options);
                    }
                    break;

                // parse features
                case "placemark":
                    this.parseFeatures(nodes, options);
                    break;
            }
        }
        
        return this.features;
    },

    /**
     * Finds URLs of linked KML documents and fetches them
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array}nodes   - of {DOMElement} data to read/parse.
     * @param {Object}options -  Hash of options
     * @private
     */
    parseLinks: function(nodes, options) {
        
        // Fetch external links <NetworkLink> and <Link>
        // Don't do anything if we have reached our maximum depth for recursion
        if (options.depth >= this.maxDepth) {
            return false;
        }

        // increase depth
        var newOptions = GeoGlobe.Util.extend({}, options);
        newOptions.depth++;

        for(var i=0, len=nodes.length; i<len; i++) {
            var href = this.parseProperty(nodes[i], "*", "href");
            if(href && !this.fetched[href]) {
                this.fetched[href] = true; // prevent reloading the same urls
                var data = this.fetchLink(href);
                if (data) {
                    this.parseData(data, newOptions);
                }
            } 
        }

    },

    /**
     * Fetches a URL and returns the result
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @private
     */
    fetchLink: function(href) {
        var request = GeoGlobe.Request.GET({url: href, async: false});
        if (request) {
            return request.responseText;
        }
    },

    /**
     * Parses Style nodes
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array} of {DOMElement}nodes    -  data to read/parse.
     * @param {Object}options  - Hash of options
     * @private
     * 
     */
    parseStyles: function(nodes, options) {
        for(var i=0, len=nodes.length; i<len; i++) {
            var style = this.parseStyle(nodes[i]);
            if(style) {
                var styleName = (options.styleBaseUrl || "") + "#" + style.id;
                
                this.styles[styleName] = style;
            }
        }
    },

    /**
     * Parses a kml color (in 'aabbggrr' format) and returns the corresponding
     * color and opacity or null if the color is invalid.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {String}kmlColor - a kml formated color
     * @returns {Object}
     * @private
     */
    parseKmlColor: function(kmlColor) {
        var color = null;
        if (kmlColor) {
            var matches = kmlColor.match(this.regExes.kmlColor);
            if (matches) {
                color = {
                    color: '#' + matches[4] + matches[3] + matches[2],
                    opacity: parseInt(matches[1], 16) / 255
                };
            }
        }
        return color;
    },

    /**
     * Parses the children of a Style node and builds the style hash
     * accordingly
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {DOMElement} node -Style node
     * @private
     * 
     */
    parseStyle: function(node) {
        var style = {};
        
        var types = ["LineStyle", "PolyStyle", "IconStyle", "BalloonStyle", 
                     "LabelStyle"];
        var type, styleTypeNode, nodeList, geometry, parser;
        for(var i=0, len=types.length; i<len; ++i) {
            type = types[i];
            styleTypeNode = this.getElementsByTagNameNS(node, "*", type)[0];
            if(!styleTypeNode) { 
                continue;
            }

            // only deal with first geometry of this type
            switch (type.toLowerCase()) {
                case "linestyle":
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
                    var color = this.parseKmlColor(kmlColor);
                    if (color) {
                        style["strokeColor"] = color.color;
                        style["strokeOpacity"] = color.opacity;
                    }
                    
                    var width = this.parseProperty(styleTypeNode, "*", "width");
                    if (width) {
                        style["strokeWidth"] = width;
                    }
                    break;

                case "polystyle":
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
                    var color = this.parseKmlColor(kmlColor);
                    if (color) {
                        style["fillOpacity"] = color.opacity;
                        style["fillColor"] = color.color;
                    }
                    // Check if fill is disabled
                    var fill = this.parseProperty(styleTypeNode, "*", "fill");
                    if (fill == "0") {
                        style["fillColor"] = "none";
                    }
                    // Check if outline is disabled
                    var outline = this.parseProperty(styleTypeNode, "*", "outline");
                    if (outline == "0") {
                        style["strokeWidth"] = "0";
                    }
                   
                    break;

                case "iconstyle":
                    // set scale
                    var scale = parseFloat(this.parseProperty(styleTypeNode, 
                                                          "*", "scale") || 1);
  
                    // set default width and height of icon
                    var width = 32 * scale;
                    var height = 32 * scale;

                    var iconNode = this.getElementsByTagNameNS(styleTypeNode, 
                                               "*", 
                                               "Icon")[0];
                    if (iconNode) {
                        var href = this.parseProperty(iconNode, "*", "href");
                        if (href) {                                                   

                            var w = this.parseProperty(iconNode, "*", "w");
                            var h = this.parseProperty(iconNode, "*", "h");

                            // Settings for Google specific icons that are 64x64
                            // We set the width and height to 64 and halve the
                            // scale to prevent icons from being too big
                            var google = "http://maps.google.com/mapfiles/kml";
                            if (GeoGlobe.String.startsWith(
                                                 href, google) && !w && !h) {
                                w = 64;
                                h = 64;
                                scale = scale / 2;
                            }
                                
                            // if only dimension is defined, make sure the
                            // other one has the same value
                            w = w || h;
                            h = h || w;

                            if (w) {
                                width = parseInt(w) * scale;
                            }

                            if (h) {
                                height = parseInt(h) * scale;
                            }

                            // support for internal icons 
                            //    (/root://icons/palette-x.png)
                            // x and y tell the position on the palette:
                            // - in pixels
                            // - starting from the left bottom
                            // We translate that to a position in the list 
                            // and request the appropriate icon from the 
                            // google maps website
                            var matches = href.match(this.regExes.kmlIconPalette);
                            if (matches)  {
                                var palette = matches[1];
                                var file_extension = matches[2];

                                var x = this.parseProperty(iconNode, "*", "x");
                                var y = this.parseProperty(iconNode, "*", "y");

                                var posX = x ? x/32 : 0;
                                var posY = y ? (7 - y/32) : 7;

                                var pos = posY * 8 + posX;
                                href = "http://maps.google.com/mapfiles/kml/pal" 
                                     + palette + "/icon" + pos + file_extension;
                            }

                            style["graphicOpacity"] = 1; // fully opaque
                            style["externalGraphic"] = href;
                        }

                    }


                    // hotSpots define the offset for an Icon
                    var hotSpotNode = this.getElementsByTagNameNS(styleTypeNode, 
                                               "*", 
                                               "hotSpot")[0];
                    if (hotSpotNode) {
                        var x = parseFloat(hotSpotNode.getAttribute("x"));
                        var y = parseFloat(hotSpotNode.getAttribute("y"));

                        var xUnits = hotSpotNode.getAttribute("xunits");
                        if (xUnits == "pixels") {
                            style["graphicXOffset"] = -x * scale;
                        }
                        else if (xUnits == "insetPixels") {
                            style["graphicXOffset"] = -width + (x * scale);
                        }
                        else if (xUnits == "fraction") {
                            style["graphicXOffset"] = -width * x;
                        }

                        var yUnits = hotSpotNode.getAttribute("yunits");
                        if (yUnits == "pixels") {
                            style["graphicYOffset"] = -height + (y * scale) + 1;
                        }
                        else if (yUnits == "insetPixels") {
                            style["graphicYOffset"] = -(y * scale) + 1;
                        }
                        else if (yUnits == "fraction") {
                            style["graphicYOffset"] =  -height * (1 - y) + 1;
                        }
                    }

                    style["graphicWidth"] = width;
                    style["graphicHeight"] = height;
                    break;

                case "balloonstyle":
                    var balloonStyle = GeoGlobe.Util.getXmlNodeValue(
                                            styleTypeNode);
                    if (balloonStyle) {
                        style["balloonStyle"] = balloonStyle.replace(
                                       this.regExes.straightBracket, "${$1}");
                    }
                    break;
                case "labelstyle":
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
                    var color = this.parseKmlColor(kmlColor);
                    if (color) {
                        style["fontColor"] = color.color;
                        style["fontOpacity"] = color.opacity;
                    }
                    break;

                default:
            }
        }

        // Some polygons have no line color, so we use the fillColor for that
        if (!style["strokeColor"] && style["fillColor"]) {
            style["strokeColor"] = style["fillColor"];
        }

        var id = node.getAttribute("id");
        if (id && style) {
            style.id = id;
        }

        return style;
    },

    /**
     * Parses StyleMap nodes, but only uses the 'normal' key
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array} of {DOMElement}nodes    - data to read/parse.
     * @private
     */
    parseStyleMaps: function(nodes, options) {
        // Only the default or "normal" part of the StyleMap is processed now
        // To do the select or "highlight" bit, we'd need to change lots more

        for(var i=0, len=nodes.length; i<len; i++) {
            var node = nodes[i];
            var pairs = this.getElementsByTagNameNS(node, "*", 
                            "Pair");

            var id = node.getAttribute("id");
            for (var j=0, jlen=pairs.length; j<jlen; j++) {
                var pair = pairs[j];
                // Use the shortcut in the SLD format to quickly retrieve the 
                // value of a node. Maybe it's good to have a method in 
                // Format.XML to do this
                var key = this.parseProperty(pair, "*", "key");
                var styleUrl = this.parseProperty(pair, "*", "styleUrl");

                if (styleUrl && key == "normal") {
                    this.styles[(options.styleBaseUrl || "") + "#" + id] =
                        this.styles[(options.styleBaseUrl || "") + styleUrl];
                }

                // TODO: implement the "select" part
                //if (styleUrl && key == "highlight") {
                //}

            }
        }

    },


    /**
     * Loop through all Placemark nodes and parse them.
     * Will create a list of features
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array} of {DOMElement}nodes    - data to read/parse.
     * @param {Object} Hash of options
     * @private
     * 
     */
    parseFeatures: function(nodes, options) {
        var features = [];
        for(var i=0, len=nodes.length; i<len; i++) {
            var featureNode = nodes[i];
            var feature = this.parseFeature.apply(this,[featureNode]) ;
            if(feature) {

                // Create reference to styleUrl 
                if (this.extractStyles && feature.attributes &&
                    feature.attributes.styleUrl) {
                    feature.style = this.getStyle(feature.attributes.styleUrl, options);
                }

                if (this.extractStyles) {
                    // Make sure that <Style> nodes within a placemark are 
                    // processed as well
                    var inlineStyleNode = this.getElementsByTagNameNS(featureNode,
                                                        "*",
                                                        "Style")[0];
                    if (inlineStyleNode) {
                        var inlineStyle= this.parseStyle(inlineStyleNode);
                        if (inlineStyle) {
                            feature.style = GeoGlobe.Util.extend(
                                feature.style, inlineStyle
                            );
                        }
                    }
                }

                // check if gx:Track elements should be parsed
                if (this.extractTracks) {
                    var tracks = this.getElementsByTagNameNS(
                        featureNode, this.namespaces.gx, "Track"
                    );
                    if (tracks && tracks.length > 0) {
                        var track = tracks[0];
                        var container = {
                            features: [],
                            feature: feature
                        };
                        this.readNode(track, container);
                        if (container.features.length > 0) {
                            features.push.apply(features, container.features);
                        }
                    }
                } else {
                    // add feature to list of features
                    features.push(feature);                    
                }
            } else {
                throw "Bad Placemark: " + i;
            }
        }

        // add new features to existing feature list
        this.features = this.features.concat(features);
    },
    
    /**
     *  Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @private
     */
    readers: {
        "kml": {
            "when": function(node, container) {
                container.whens.push(GeoGlobe.Date.parse(
                    this.getChildValue(node)
                ));
            },
            "_trackPointAttribute": function(node, container) {
                var name = node.nodeName.split(":").pop();
                container.attributes[name].push(this.getChildValue(node));
            }
        },
        "gx": {
            "Track": function(node, container) {
                var obj = {
                    whens: [],
                    points: [],
                    angles: []
                };
                if (this.trackAttributes) {
                    var name;
                    obj.attributes = {};
                    for (var i=0, ii=this.trackAttributes.length; i<ii; ++i) {
                        name = this.trackAttributes[i];
                        obj.attributes[name] = [];
                        if (!(name in this.readers.kml)) {
                            this.readers.kml[name] = this.readers.kml._trackPointAttribute;
                        }
                    }
                }
                this.readChildNodes(node, obj);
                if (obj.whens.length !== obj.points.length) {
                    throw new Error("gx:Track with unequal number of when (" +
                                    obj.whens.length + ") and gx:coord (" +
                                    obj.points.length + ") elements.");
                }
                var hasAngles = obj.angles.length > 0;
                if (hasAngles && obj.whens.length !== obj.angles.length) {
                    throw new Error("gx:Track with unequal number of when (" +
                                    obj.whens.length + ") and gx:angles (" +
                                    obj.angles.length + ") elements.");
                }
                var feature, point, angles;
                for (var i=0, ii=obj.whens.length; i<ii; ++i) {
                    feature = container.feature.clone();
                    feature.fid = container.feature.fid || container.feature.id;
                    point = obj.points[i];
                    feature.geometry = point;
                    if ("z" in point) {
                        feature.attributes.altitude = point.z;
                    }
                    if (this.internalProjection && this.externalProjection) {
                        feature.geometry.transform(
                            this.externalProjection, this.internalProjection
                        ); 
                    }
                    if (this.trackAttributes) {
                        for (var j=0, jj=this.trackAttributes.length; j<jj; ++j) {
                            var name = this.trackAttributes[j];
                            feature.attributes[name] = obj.attributes[name][i];
                        }
                    }
                    feature.attributes.when = obj.whens[i];
                    feature.attributes.trackId = container.feature.id;
                    if (hasAngles) {
                        angles = obj.angles[i];
                        feature.attributes.heading = parseFloat(angles[0]);
                        feature.attributes.tilt = parseFloat(angles[1]);
                        feature.attributes.roll = parseFloat(angles[2]);
                    }
                    container.features.push(feature);
                }
            },
            "coord": function(node, container) {
                var str = this.getChildValue(node);
                var coords = str.replace(this.regExes.trimSpace, "").split(/\s+/);
                var point = new GeoGlobe.Geometry.Point(coords[0], coords[1]);
                if (coords.length > 2) {
                    point.z = parseFloat(coords[2]);
                }
                container.points.push(point);
            },
            "angles": function(node, container) {
                var str = this.getChildValue(node);
                var parts = str.replace(this.regExes.trimSpace, "").split(/\s+/);
                container.angles.push(parts);
            }
        }
    },
    
    /**、
     * This function is the core of the KML parsing code in GeoGlobe.
     *     It creates the geometries that are then attached to the returned
     *     feature, and calls parseAttributes() to get attribute data out.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {DOMElement}node
     * @returns {GeoGlobe.Feature} A vector feature.
     * @private
     */
    parseFeature: function(node) {
        // only accept one geometry per feature - look for highest "order"
        var order = ["MultiGeometry", "Polygon", "LineString", "Point"];
        var type, nodeList, geometry, parser;
        for(var i=0, len=order.length; i<len; ++i) {
            type = order[i];
            this.internalns = node.namespaceURI ? 
                    node.namespaceURI : this.kmlns;
            nodeList = this.getElementsByTagNameNS(node, 
                                                   this.internalns, type);
            if(nodeList.length > 0) {
                // only deal with first geometry of this type
                var parser = this.parseGeometry[type.toLowerCase()];
                if(parser) {
                    geometry = parser.apply(this, [nodeList[0]]);
                    if (this.internalProjection && this.externalProjection) {
                        geometry.transform(this.externalProjection, 
                                           this.internalProjection); 
                    }                       
                } else {
                    throw new TypeError("Unsupported geometry type: " + type);
                }
                // stop looking for different geometry types
                break;
            }
        }

        // construct feature (optionally with attributes)
        var attributes;
        if(this.extractAttributes) {
            attributes = this.parseAttributes(node);
        }
        var feature = new GeoGlobe.Feature(geometry, attributes);

        var fid = node.getAttribute("id") || node.getAttribute("name");
        if(fid != null) {
            feature.fid = fid;
        }

        return feature;
    },        
    
    /**
     * Retrieves a style from a style hash using styleUrl as the key
     * If the styleUrl doesn't exist yet, we try to fetch it
     * Internet
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @returns {Object}  - (reference to) Style hash
     * @private
     */
    getStyle: function(styleUrl, options) {

        var styleBaseUrl = GeoGlobe.Util.removeTail(styleUrl);

        var newOptions = GeoGlobe.Util.extend({}, options);
        newOptions.depth++;
        newOptions.styleBaseUrl = styleBaseUrl;

        // Fetch remote Style URLs (if not fetched before) 
        if (!this.styles[styleUrl] 
                && !GeoGlobe.String.startsWith(styleUrl, "#") 
                && newOptions.depth <= this.maxDepth
                && !this.fetched[styleBaseUrl] ) {

            var data = this.fetchLink(styleBaseUrl);
            if (data) {
                this.parseData(data, newOptions);
            }

        }

        // return requested style
        var style = GeoGlobe.Util.extend({}, this.styles[styleUrl]);
        return style;
    },
    
    /**
     *  Properties of this object are the functions that parse geometries based
     *     on their type.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @private
     */
    parseGeometry: {
        
        /**
         * Given a KML node representing a point geometry, create an GeoGlobe
         *     point geometry.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {DOMElement} node - A KML Polygon node.
         * @returns {GeoGlobe.Geometry.Point} A point geometry.
         * @private
         */
        point: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
                                                       "coordinates");
            var coords = [];
            if(nodeList.length > 0) {
                var coordString = nodeList[0].firstChild.nodeValue;
                coordString = coordString.replace(this.regExes.removeSpace, "");
                coords = coordString.split(",");
            }

            var point = null;
            if(coords.length > 1) {
                // preserve third dimension
                if(coords.length == 2) {
                    coords[2] = null;
                }
                point = new GeoGlobe.Geometry.Point(coords[0], coords[1],
                                                      coords[2]);
            } else {
                throw "Bad coordinate string: " + coordString;
            }
            return point;
        },
        
        /**
         * Given a KML node representing a linestring geometry, create an
         *     GeoGlobe linestring geometry.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {DOMElement}node - A KML Polygon node.
         * @returns {GeoGlobe.Geometry.LineString} A linestring geometry.
         * @private
         */
        linestring: function(node, ring) {
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
                                                       "coordinates");
            var line = null;
            if(nodeList.length > 0) {
                var coordString = this.getChildValue(nodeList[0]);

                coordString = coordString.replace(this.regExes.trimSpace,
                                                  "");
                coordString = coordString.replace(this.regExes.trimComma,
                                                  ",");
                var pointList = coordString.split(this.regExes.splitSpace);
                var numPoints = pointList.length;
                var points = new Array(numPoints);
                var coords, numCoords;
                for(var i=0; i<numPoints; ++i) {
                    coords = pointList[i].split(",");
                    numCoords = coords.length;
                    if(numCoords > 1) {
                        if(coords.length == 2) {
                            coords[2] = null;
                        }
                        points[i] = new GeoGlobe.Geometry.Point(coords[0],
                                                                  coords[1],
                                                                  coords[2]);
                    } else {
                        throw "Bad LineString point coordinates: " +
                              pointList[i];
                    }
                }
                if(numPoints) {
                    if(ring) {
                        line = new GeoGlobe.Geometry.LinearRing(points);
                    } else {
                        line = new GeoGlobe.Geometry.LineString(points);
                    }
                } else {
                    throw "Bad LineString coordinates: " + coordString;
                }
            }

            return line;
        },
        
        /**
         *  Given a KML node representing a polygon geometry, create an
         *     GeoGlobe polygon geometry.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {DOMElement}node - A KML Polygon node.
         *
         * @returns {GeoGlobe.Geometry.Polygon} A polygon geometry.
         * @private
         */
        polygon: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
                                                       "LinearRing");
            var numRings = nodeList.length;
            var components = new Array(numRings);
            if(numRings > 0) {
                // this assumes exterior ring first, inner rings after
                var ring;
                for(var i=0, len=nodeList.length; i<len; ++i) {
                    ring = this.parseGeometry.linestring.apply(this,
                                                        [nodeList[i], true]);
                    if(ring) {
                        components[i] = ring;
                    } else {
                        throw "Bad LinearRing geometry: " + i;
                    }
                }
            }
            return new GeoGlobe.Geometry.Polygon(components);
        },
        
        /**
         *  Given a KML node representing a multigeometry, create an
         *     GeoGlobe geometry collection.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * Parameters:
         * @param {DOMElement}node - A KML MultiGeometry node.
         *
         * @returns {GeoGlobe.Geometry.Collection} A geometry collection.
         * @private
         */
        multigeometry: function(node) {
            var child, parser;
            var parts = [];
            var children = node.childNodes;
            for(var i=0, len=children.length; i<len; ++i ) {
                child = children[i];
                if(child.nodeType == 1) {
                    var type = (child.prefix) ?
                            child.nodeName.split(":")[1] :
                            child.nodeName;
                    var parser = this.parseGeometry[type.toLowerCase()];
                    if(parser) {
                        parts.push(parser.apply(this, [child]));
                    }
                }
            }
            return new GeoGlobe.Geometry.Collection(parts);
        }
        
    },

    /**
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @returns {Object} An attributes object.
     * @private
     */
    parseAttributes: function(node) {
        var attributes = {};
       
        // Extended Data is parsed first.
        var edNodes = node.getElementsByTagName("ExtendedData");
        if (edNodes.length) {
            attributes = this.parseExtendedData(edNodes[0]);
        }
        
        // assume attribute nodes are type 1 children with a type 3 or 4 child
        var child, grandchildren, grandchild;
        var children = node.childNodes;

        for(var i=0, len=children.length; i<len; ++i) {
            child = children[i];
            if(child.nodeType == 1) {
                grandchildren = child.childNodes;
                if(grandchildren.length >= 1 && grandchildren.length <= 3) {
                    var grandchild;
                    switch (grandchildren.length) {
                        case 1:
                            grandchild = grandchildren[0];
                            break;
                        case 2:
                            var c1 = grandchildren[0];
                            var c2 = grandchildren[1];
                            grandchild = (c1.nodeType == 3 || c1.nodeType == 4) ?
                                c1 : c2;
                            break;
                        case 3:
                        default:
                            grandchild = grandchildren[1];
                            break;
                    }
                    if(grandchild.nodeType == 3 || grandchild.nodeType == 4) {
                        var name = (child.prefix) ?
                                child.nodeName.split(":")[1] :
                                child.nodeName;
                        var value = GeoGlobe.Util.getXmlNodeValue(grandchild);
                        if (value) {
                            value = value.replace(this.regExes.trimSpace, "");
                            attributes[name] = value;
                        }
                    }
                } 
            }
        }
        return attributes;
    },

    /**
     * Parse ExtendedData from KML. Limited support for schemas/datatypes.
     *     See http://code.google.com/apis/kml/documentation/kmlreference.html#extendeddata
     *     for more information on extendeddata.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @private
     */
    parseExtendedData: function(node) {
        var attributes = {};
        var i, len, data, key;
        var dataNodes = node.getElementsByTagName("Data");
        for (i = 0, len = dataNodes.length; i < len; i++) {
            data = dataNodes[i];
            key = data.getAttribute("name");
            var ed = {};
            var valueNode = data.getElementsByTagName("value");
            if (valueNode.length) {
                ed['value'] = this.getChildValue(valueNode[0]);
            }
            if (this.kvpAttributes) {
                attributes[key] = ed['value'];
            } else {
                var nameNode = data.getElementsByTagName("displayName");
                if (nameNode.length) {
                    ed['displayName'] = this.getChildValue(nameNode[0]);
                }
                attributes[key] = ed;
            } 
        }
        var simpleDataNodes = node.getElementsByTagName("SimpleData");
        for (i = 0, len = simpleDataNodes.length; i < len; i++) {
            var ed = {};
            data = simpleDataNodes[i];
            key = data.getAttribute("name");
            ed['value'] = this.getChildValue(data);
            if (this.kvpAttributes) {
                attributes[key] = ed['value'];
            } else {
                ed['displayName'] = key;
                attributes[key] = ed;
            }
        }
        
        return attributes;    
    },
    
    /**
     * Convenience method to find a node and return its value
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {DOMElement} xmlNode
     * @param {String} namespace  - namespace of the node to find
     * @param {String} tagName  -name of the property to parse
     * @returns {String} The value for the requested property (defaults to null)
     * @private
     */    
    parseProperty: function(xmlNode, namespace, tagName) {
        var value;
        var nodeList = this.getElementsByTagNameNS(xmlNode, namespace, tagName);
        try {
            value = GeoGlobe.Util.getXmlNodeValue(nodeList[0]);
        } catch(e) {
            value = null;
        }
     
        return value;
    },                                                              

    /**
     *  接受Feature Collection，并返回一个字符串。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array(GeoGlobe.Feature)} features - 要素数组。
     * @returns {String} 一个KML字符串。
     */
    write: function(features) {
        if(!(GeoGlobe.Util.isArray(features))) {
            features = [features];
        }
        var kml = this.createElementNS(this.kmlns, "kml");
        var folder = this.createFolderXML();
        for(var i=0, len=features.length; i<len; ++i) {
            folder.appendChild(this.createPlacemarkXML(features[i]));
        }
        kml.appendChild(folder);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [kml]);
    },

    /**
     * Creates and returns a KML folder node
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @returns {DOMElement}
     * @private
     */
    createFolderXML: function() {
        // Folder
        var folder = this.createElementNS(this.kmlns, "Folder");

        // Folder name
        if (this.foldersName) {
            var folderName = this.createElementNS(this.kmlns, "name");
            var folderNameText = this.createTextNode(this.foldersName); 
            folderName.appendChild(folderNameText);
            folder.appendChild(folderName);
        }

        // Folder description
        if (this.foldersDesc) {
            var folderDesc = this.createElementNS(this.kmlns, "description");        
            var folderDescText = this.createTextNode(this.foldersDesc); 
            folderDesc.appendChild(folderDescText);
            folder.appendChild(folderDesc);
        }

        return folder;
    },

    /**
     * Creates and returns a KML placemark node representing the given feature.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {GeoGlobe.Feature}feature -
     * @returns {DOMElement}
     * @private
     */
    createPlacemarkXML: function(feature) {        
        // Placemark name
        var placemarkName = this.createElementNS(this.kmlns, "name");
        var label = (feature.style && feature.style.label) ? feature.style.label : feature.id;
        var name = feature.attributes.name || label;
        placemarkName.appendChild(this.createTextNode(name));

        // Placemark description
        var placemarkDesc = this.createElementNS(this.kmlns, "description");
        var desc = feature.attributes.description || this.placemarksDesc;
        placemarkDesc.appendChild(this.createTextNode(desc));
        
        // Placemark
        var placemarkNode = this.createElementNS(this.kmlns, "Placemark");
        if(feature.fid != null) {
            placemarkNode.setAttribute("id", feature.fid);
        }
        placemarkNode.appendChild(placemarkName);
        placemarkNode.appendChild(placemarkDesc);

        // Geometry node (Point, LineString, etc. nodes)
        var geometryNode = this.buildGeometryNode(feature.geometry);
        placemarkNode.appendChild(geometryNode);        
        
        // output attributes as extendedData
        if (feature.attributes) {
            var edNode = this.buildExtendedData(feature.attributes);
            if (edNode) {
                placemarkNode.appendChild(edNode);
            }
        }
        
        return placemarkNode;
    },    

    /**
     * Builds and returns a KML geometry node with the given geometry.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {GeoGlobe.Geometry}geometry -
     * @returns {DOMElement}
     * @private
     */
    buildGeometryNode: function(geometry) {
        var className = geometry.CLASS_NAME;
        var type = className.substring(className.lastIndexOf(".") + 1);
        var builder = this.buildGeometry[type.toLowerCase()];
        var node = null;
        if(builder) {
            node = builder.apply(this, [geometry]);
        }
        return node;
    },

    /**
     * Object containing methods to do the actual geometry node building
     *     based on geometry type.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {null}
     * @private
     */
    buildGeometry: {
        // TBD: Anybody care about namespace aliases here (these nodes have
        //    no prefixes)?

        /**
         * Given an GeoGlobe point geometry, create a KML point.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.LineString}geometry -  A linestring geometry.
         * @returns {DOMElement} A KML linestring node.
         * @private
         */
        point: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "Point");
            kml.appendChild(this.buildCoordinatesNode(geometry));
            return kml;
        },
        
        /**
         * Given an GeoGlobe multipoint geometry, create a KML
         *     GeometryCollection.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.LineString}geometry -  A linestring geometry.
         * @returns {DOMElement} A KML linestring node.
         * @private
         */
        multipoint: function(geometry) {
            return this.buildGeometry.collection.apply(this, [geometry]);
        },

        /**
         * Given an GeoGlobe linestring geometry, create a KML linestring.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.LineString}geometry -  A linestring geometry.
         * @returns {DOMElement} A KML linestring node.
         * @private
         */
        linestring: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "LineString");
            kml.appendChild(this.buildCoordinatesNode(geometry));
            return kml;
        },
        
        /**
         * Given an GeoGlobe multilinestring geometry, create a KML
         *     GeometryCollection.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.Point}geometry - A multilinestring geometry.
         * @returns {DOMElement} A KML GeometryCollection node.
         * @private
         */
        multilinestring: function(geometry) {
            return this.buildGeometry.collection.apply(this, [geometry]);
        },

        /**
         * Given an GeoGlobe linearring geometry, create a KML linearring.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.LinearRing}geometry - A linearring geometry.
         * @returns {DOMElement} A KML linearring node.
         * @private
         */
        linearring: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "LinearRing");
            kml.appendChild(this.buildCoordinatesNode(geometry));
            return kml;
        },
        
        /**
         * Given an GeoGlobe polygon geometry, create a KML polygon.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.Polygon} geometry -A polygon geometry.
         * @returns {DOMElement} A KML polygon node.
         * @private
         */
        polygon: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "Polygon");
            var rings = geometry.components;
            var ringMember, ringGeom, type;
            for(var i=0, len=rings.length; i<len; ++i) {
                type = (i==0) ? "outerBoundaryIs" : "innerBoundaryIs";
                ringMember = this.createElementNS(this.kmlns, type);
                ringGeom = this.buildGeometry.linearring.apply(this,
                                                               [rings[i]]);
                ringMember.appendChild(ringGeom);
                kml.appendChild(ringMember);
            }
            return kml;
        },
        
        /**
         * Given an GeoGlobe multipolygon geometry, create a KML
         *     GeometryCollection.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.Point}geometry - A multipolygon geometry.
         * @returns {DOMElement} A KML GeometryCollection node.
         * @private
         */
        multipolygon: function(geometry) {
            return this.buildGeometry.collection.apply(this, [geometry]);
        },

        /**
         *  Given an GeoGlobe geometry collection, create a KML MultiGeometry.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.Collection}geometry - A geometry collection.
         * @returns {DOMElement} A KML MultiGeometry node.
         * @private
         */
        collection: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "MultiGeometry");
            var child;
            for(var i=0, len=geometry.components.length; i<len; ++i) {
                child = this.buildGeometryNode.apply(this,
                                                     [geometry.components[i]]);
                if(child) {
                    kml.appendChild(child);
                }
            }
            return kml;
        }
    },

    /**
     * Builds and returns the KML coordinates node with the given geometry
     * coordinates.../coordinates
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {GeoGlobe.Geometry}geometry -
     * @returns {DOMElement}
     * @private
     */     
    buildCoordinatesNode: function(geometry) {
        var coordinatesNode = this.createElementNS(this.kmlns, "coordinates");
        
        var path;
        var points = geometry.components;
        if(points) {
            // LineString or LinearRing
            var point;
            var numPoints = points.length;
            var parts = new Array(numPoints);
            for(var i=0; i<numPoints; ++i) {
                point = points[i];
                parts[i] = this.buildCoordinates(point);
            }
            path = parts.join(" ");
        } else {
            // Point
            path = this.buildCoordinates(geometry);
        }
        
        var txtNode = this.createTextNode(path);
        coordinatesNode.appendChild(txtNode);
        
        return coordinatesNode;
    },    
    
    /**
     *  buildCoordinates
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {GeoGlobe.Geometry.Point}point -
     * @returns {String} a coordinate pair
     * @private
     */
    buildCoordinates: function(point) {
        if (this.internalProjection && this.externalProjection) {
            point = point.clone();
            point.transform(this.internalProjection, 
                               this.externalProjection);
        }
        return point.x + "," + point.y;                     
    },

    /**
     * buildExtendedData
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Object}attributes -
     * @returns {DOMElement} A KML ExtendedData node or {null} if no attributes.‘
     * @private
     */
    buildExtendedData: function(attributes) {
        var extendedData = this.createElementNS(this.kmlns, "ExtendedData");
        for (var attributeName in attributes) {
            // empty, name, description, styleUrl attributes ignored
            if (attributes[attributeName] && attributeName != "name" && attributeName != "description" && attributeName != "styleUrl") {
                var data = this.createElementNS(this.kmlns, "Data");
                data.setAttribute("name", attributeName);
                var value = this.createElementNS(this.kmlns, "value");
                if (typeof attributes[attributeName] == "object") {
                    // cater for object attributes with 'value' properties
                    // other object properties will output an empty node
                    if (attributes[attributeName].value) {
                        value.appendChild(this.createTextNode(attributes[attributeName].value));
                    }
                    if (attributes[attributeName].displayName) {
                        var displayName = this.createElementNS(this.kmlns, "displayName");
                        // displayName always written as CDATA
                        displayName.appendChild(this.getXMLDoc().createCDATASection(attributes[attributeName].displayName));
                        data.appendChild(displayName);
                    }
                } else {
                    value.appendChild(this.createTextNode(attributes[attributeName]));
                }
                data.appendChild(value);
                extendedData.appendChild(data);
            }
        }
        if (this.isSimpleContent(extendedData)) {
            return null;
        } else {
            return extendedData;
        }
    },
    
    CLASS_NAME: "GeoGlobe.Format.KML" 
});

/**
 * @class GeoGlobe.Format.OWSCommon
 * @classdesc  阅读OWSCommon。 使用GeoGlobe.Format.OWSCommon构造函数创建一个新实例。
 * @private
 */
GeoGlobe.Format.OWSCommon = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     *defaultVersion-如果没有找到版本号， 默认值是“1.0.0”。
     * @memberof GeoGlobe.Format.OWSCommon.prototype
     * @type {String}
     */
    defaultVersion: "1.0.0",
    
    /**
     *  为OWSCommon创建一个新的解析器。
     * @classdesc OpenLayers.Format.OWSCommon
     * @param {Object}options -  An optional object whose properties will be set on
     *     this instance.
     */

    /**
     *  Returns the version to use. Subclasses can override this function
     * if a different version detection is needed.
     * @memberof GeoGlobe.Format.OWSCommon.prototype
     * @param {String | DOMElement} data -Data to read.
     * @param {Object}options -  Options for the reader.
     * @returns {String} The version to use.
     * @private
     */
    getVersion: function(root, options) {
        var version = this.version;
        if(!version) {
            // remember version does not correspond to the OWS version
            // it corresponds to the WMS/WFS/WCS etc. request version
            var uri = root.getAttribute("xmlns:ows");
            // the above will fail if the namespace prefix is different than
            // ows and if the namespace is declared on a different element
            if (uri && uri.substring(uri.lastIndexOf("/")+1) === "1.1") {
                version ="1.1.0";
            } 
            if(!version) {
                version = this.defaultVersion;
            }
        }
        return version;
    },

    /**
     * 阅读OWSCommon文档并返回一个对象。
     * @memberof GeoGlobe.Format.OWSCommon.prototype
     * @param {String | DOMElement} data -可读取的数据。
     * @param {Object}options -  可选项。
     * @returns {Object} 代表文档结构的对象。
     */

    CLASS_NAME: "GeoGlobe.Format.OWSCommon" 
});

/** Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @class GeoGlobe.Format.OWSCommon.v1
 * @classdesc Common readers and writers for OWSCommon v1.X formats,Inherits from GeoGlobe.Format.XML
 * @private
 */
GeoGlobe.Format.OWSCommon.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
   
    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof GeoGlobe.Format.OWSCommon.v1.prototype
     * @private
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * @memberof GeoGlobe.Format.OWSCommon.v1.prototype
     *
     * @param  {DOMElement}data - An OWSCommon document element.
     * @param {Object}  options -Options for the reader.
     *
     * @returns {Object}  - An object representing the OWSCommon document.
     * @private
     */
    read: function(data, options) {
        options = GeoGlobe.Util.applyDefaults(options, this.options);
        var ows = {};
        this.readChildNodes(data, ows);
        return ows;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.OWSCommon.v1.prototype
     * @private
     */
    readers: {
        "ows": {
            "Exception": function(node, exceptionReport) {
                var exception = {
                    code: node.getAttribute('exceptionCode'),
                    locator: node.getAttribute('locator'),
                    texts: []
                };
                exceptionReport.exceptions.push(exception);
                this.readChildNodes(node, exception);
            },
            "ExceptionText": function(node, exception) {
                var text = this.getChildValue(node);
                exception.texts.push(text);
            },
            "ServiceIdentification": function(node, obj) {
                obj.serviceIdentification = {};
                this.readChildNodes(node, obj.serviceIdentification);
            },
            "Title": function(node, obj) {
                obj.title = this.getChildValue(node);
            },
            "Abstract": function(node, serviceIdentification) {
                serviceIdentification["abstract"] = this.getChildValue(node);
            },
            "Keywords": function(node, serviceIdentification) {
                serviceIdentification.keywords = {};
                this.readChildNodes(node, serviceIdentification.keywords);
            },
            "Keyword": function(node, keywords) {
                keywords[this.getChildValue(node)] = true;
            },
            "ServiceType": function(node, serviceIdentification) {
                serviceIdentification.serviceType = {
                    codeSpace: node.getAttribute('codeSpace'), 
                    value: this.getChildValue(node)};
            },
            "ServiceTypeVersion": function(node, serviceIdentification) {
                serviceIdentification.serviceTypeVersion = this.getChildValue(node);
            },
            "Fees": function(node, serviceIdentification) {
                serviceIdentification.fees = this.getChildValue(node);
            },
            "AccessConstraints": function(node, serviceIdentification) {
                serviceIdentification.accessConstraints = 
                    this.getChildValue(node);
            },
            "ServiceProvider": function(node, obj) {
                obj.serviceProvider = {};
                this.readChildNodes(node, obj.serviceProvider);
            },
            "ProviderName": function(node, serviceProvider) {
                serviceProvider.providerName = this.getChildValue(node);
            },
            "ProviderSite": function(node, serviceProvider) {
                serviceProvider.providerSite = this.getAttributeNS(node, 
                    this.namespaces.xlink, "href");
            },
            "ServiceContact": function(node, serviceProvider) {
                serviceProvider.serviceContact = {};
                this.readChildNodes(node, serviceProvider.serviceContact);
            },
            "IndividualName": function(node, serviceContact) {
                serviceContact.individualName = this.getChildValue(node);
            },
            "PositionName": function(node, serviceContact) {
                serviceContact.positionName = this.getChildValue(node);
            },
            "ContactInfo": function(node, serviceContact) {
                serviceContact.contactInfo = {};
                this.readChildNodes(node, serviceContact.contactInfo);
            },
            "Phone": function(node, contactInfo) {
                contactInfo.phone = {};
                this.readChildNodes(node, contactInfo.phone);
            },
            "Voice": function(node, phone) {
                phone.voice = this.getChildValue(node);
            },
            "Address": function(node, contactInfo) {
                contactInfo.address = {};
                this.readChildNodes(node, contactInfo.address);
            },
            "DeliveryPoint": function(node, address) {
                address.deliveryPoint = this.getChildValue(node);
            },
            "City": function(node, address) {
                address.city = this.getChildValue(node);
            },
            "AdministrativeArea": function(node, address) {
                address.administrativeArea = this.getChildValue(node);
            },
            "PostalCode": function(node, address) {
                address.postalCode = this.getChildValue(node);
            },
            "Country": function(node, address) {
                address.country = this.getChildValue(node);
            },
            "ElectronicMailAddress": function(node, address) {
                address.electronicMailAddress = this.getChildValue(node);
            },
            "Role": function(node, serviceContact) {
                serviceContact.role = this.getChildValue(node);
            },
            "OperationsMetadata": function(node, obj) {
                obj.operationsMetadata = {};
                this.readChildNodes(node, obj.operationsMetadata);
            },
            "Operation": function(node, operationsMetadata) {
                var name = node.getAttribute("name");
                operationsMetadata[name] = {};
                this.readChildNodes(node, operationsMetadata[name]);
            },
            "DCP": function(node, operation) {
                operation.dcp = {};
                this.readChildNodes(node, operation.dcp);
            },
            "HTTP": function(node, dcp) {
                dcp.http = {};
                this.readChildNodes(node, dcp.http);
            },
            "Get": function(node, http) {
                if (!http.get) {
                    http.get = [];
                }
                var obj = {
                    url: this.getAttributeNS(node, this.namespaces.xlink, "href")
                };
                this.readChildNodes(node, obj);
                http.get.push(obj);
            },
            "Post": function(node, http) {
                if (!http.post) {
                    http.post = [];
                }
                var obj = {
                    url: this.getAttributeNS(node, this.namespaces.xlink, "href")
                };
                this.readChildNodes(node, obj);
                http.post.push(obj);
            },
            "Parameter": function(node, operation) {
                if (!operation.parameters) {
                    operation.parameters = {};
                }
                var name = node.getAttribute("name");
                operation.parameters[name] = {};
                this.readChildNodes(node, operation.parameters[name]);
            },
            "Constraint": function(node, obj) {
                if (!obj.constraints) {
                    obj.constraints = {};
                }
                var name = node.getAttribute("name");
                obj.constraints[name] = {};
                this.readChildNodes(node, obj.constraints[name]);
            },
            "Value": function(node, allowedValues) {
                allowedValues[this.getChildValue(node)] = true;
            },
            "OutputFormat": function(node, obj) {
                obj.formats.push({value: this.getChildValue(node)});
                this.readChildNodes(node, obj);
            },
            "WGS84BoundingBox": function(node, obj) {
                var boundingBox = {};
                boundingBox.crs = node.getAttribute("crs");
                if (obj.BoundingBox) {
                    obj.BoundingBox.push(boundingBox);
                } else {
                    obj.projection = boundingBox.crs;
                    boundingBox = obj;
               }
               this.readChildNodes(node, boundingBox);
            },
            "BoundingBox": function(node, obj) {
                // FIXME: We consider that BoundingBox is the same as WGS84BoundingBox
                // LowerCorner = "min_x min_y"
                // UpperCorner = "max_x max_y"
                // It should normally depend on the projection
                this.readers['ows']['WGS84BoundingBox'].apply(this, [node, obj]);
            },
            "LowerCorner": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, "");
                str = str.replace(this.regExes.trimComma, ",");
                var pointList = str.split(this.regExes.splitSpace);
                obj.left = pointList[0];
                obj.bottom = pointList[1];
            },
            "UpperCorner": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, "");
                str = str.replace(this.regExes.trimComma, ",");
                var pointList = str.split(this.regExes.splitSpace);
                obj.right = pointList[0];
                obj.top = pointList[1];
                //obj.bounds = new GeoGlobe.Bounds(obj.left, obj.bottom,obj.right, obj.top);
                obj.bounds = new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(obj.left, obj.bottom),new GeoGlobe.LngLat(obj.right, obj.top));
                delete obj.left;
                delete obj.bottom;
                delete obj.right;
                delete obj.top;
            },
            "Language": function(node, obj) {
                obj.language = this.getChildValue(node);
            }
        }
    },

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.OWSCommon.v1.prototype
     * @private
     */
    writers: {
        "ows": {
            "BoundingBox": function(options, nodeName) {
                var node = this.createElementNSPlus(nodeName || "ows:BoundingBox", {
                    attributes: {
                        crs: options.projection
                    }
                });
                this.writeNode("ows:LowerCorner", options, node);
                this.writeNode("ows:UpperCorner", options, node);
                return node;
            },
            "LowerCorner": function(options) {
                var node = this.createElementNSPlus("ows:LowerCorner", {
                    //value: options.bounds.left + " " + options.bounds.bottom });
                    value: options.bounds._sw.lng + " " + options.bounds._sw.lat });
                return node;
            },
            "UpperCorner": function(options) {
                var node = this.createElementNSPlus("ows:UpperCorner", {
                    //value: options.bounds.right + " " + options.bounds.top });
                    value: options.bounds._ne.lng + " " + options.bounds._ne.lat });
                return node;
            },
            "Identifier": function(identifier) {
                var node = this.createElementNSPlus("ows:Identifier", {
                    value: identifier });
                return node;
            },
            "Title": function(title) {
                var node = this.createElementNSPlus("ows:Title", {
                    value: title });
                return node;
            },
            "Abstract": function(abstractValue) {
                var node = this.createElementNSPlus("ows:Abstract", {
                    value: abstractValue });
                return node;
            },
            "OutputFormat": function(format) {
                var node = this.createElementNSPlus("ows:OutputFormat", {
                    value: format });
                return node;
            }
        }
    },

    CLASS_NAME: "GeoGlobe.Format.OWSCommon.v1"

});

/** Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @class GeoGlobe.Format.OWSCommon.v1_0_0
 * @classdesc 解析器的OWS通用版本1.0.0。,Inherits from:GeoGlobe.Format.OWSCommon.v1
 * @private
 */

GeoGlobe.Format.OWSCommon.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Format.OWSCommon.v1, {
    
    /**
     * Mapping of namespace aliases to namespace URIs.
     * @memberof GeoGlobe.Format.OWSCommon.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.OWSCommon.v1_0_0.prototype
     * @private
     */
    readers: {
        "ows": GeoGlobe.Util.applyDefaults({
            "ExceptionReport": function(node, obj) {
                obj.success = false;
                obj.exceptionReport = {
                    version: node.getAttribute('version'),
                    language: node.getAttribute('language'),
                    exceptions: []
                };
                this.readChildNodes(node, obj.exceptionReport);
            } 
        }, GeoGlobe.Format.OWSCommon.v1.prototype.readers.ows)
    },

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.OWSCommon.v1_0_0.prototype
     * @private
     */
    writers: {
        "ows": GeoGlobe.Format.OWSCommon.v1.prototype.writers.ows
    },
    
    CLASS_NAME: "GeoGlobe.Format.OWSCommon.v1_0_0"

});

/** Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @class GeoGlobe.Format.OWSCommon.v1_1_0
 * @classdesc OWS Common Edition 1.1.0的解析器。
 * @private
 *
 */
GeoGlobe.Format.OWSCommon.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Format.OWSCommon.v1, {

    /**
     * Mapping of namespace aliases to namespace URIs.Inherits from:GeoGlobe.Format.OWSCommon.v1
     * @memberof GeoGlobe.Format.OWSCommon.v1_1_0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.OWSCommon.v1_1_0.prototype
     * @private
     */
    readers: {
        "ows": GeoGlobe.Util.applyDefaults({
            "ExceptionReport": function(node, obj) {
                obj.exceptionReport = {
                    version: node.getAttribute('version'),
                    language: node.getAttribute('xml:lang'),
                    exceptions: []
                };
                this.readChildNodes(node, obj.exceptionReport);
            },
            "AllowedValues": function(node, parameter) {
                parameter.allowedValues = {};
                this.readChildNodes(node, parameter.allowedValues);
            },
            "AnyValue": function(node, parameter) {
                parameter.anyValue = true;
            },
            "DataType": function(node, parameter) {
                parameter.dataType = this.getChildValue(node);
            },
            "Range": function(node, allowedValues) {
                allowedValues.range = {};
                this.readChildNodes(node, allowedValues.range);
            },
            "MinimumValue": function(node, range) {
                range.minValue = this.getChildValue(node);
            },
            "MaximumValue": function(node, range) {
                range.maxValue = this.getChildValue(node);
            },
            "Identifier": function(node, obj) {
                obj.identifier = this.getChildValue(node);
            },
            "SupportedCRS": function(node, obj) {
                obj.supportedCRS = this.getChildValue(node);
            }
        }, GeoGlobe.Format.OWSCommon.v1.prototype.readers["ows"])
    },

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.OWSCommon.v1_1_0.prototype
     * @private
     */
    writers: {
        "ows": GeoGlobe.Util.applyDefaults({
            "Range": function(range) {
                var node = this.createElementNSPlus("ows:Range", {
                    attributes: {
                        'ows:rangeClosure': range.closure
                    }
                });
                this.writeNode("ows:MinimumValue", range.minValue, node);
                this.writeNode("ows:MaximumValue", range.maxValue, node);
                return node;
            },
            "MinimumValue": function(minValue) {
                var node = this.createElementNSPlus("ows:MinimumValue", {
                    value: minValue
                });
                return node;
            },
            "MaximumValue": function(maxValue) {
                var node = this.createElementNSPlus("ows:MaximumValue", {
                    value: maxValue
                });
                return node;
            },
            "Value": function(value) {
                var node = this.createElementNSPlus("ows:Value", {
                    value: value
                });
                return node;
            }
        }, GeoGlobe.Format.OWSCommon.v1.prototype.writers["ows"])
    },

    CLASS_NAME: "GeoGlobe.Format.OWSCommon.v1_1_0"

});

/**
 * @class  GeoGlobe.Format.WFSCapabilities
 * @classdesc  网络要素服务获取服务信息操作格式化解析类。将XML格式的网络要素服务能力描述信息解析成JavaScript对象。
 * @returns {Array} 图层列表。
 */
GeoGlobe.Format.WFSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     * 默认版本号-如果没有找到版本号， 默认值是“1.1.0”。
     * @memberof  GeoGlobe.Format.WFSCapabilities.prototype
     * @type {String}
     */
    defaultVersion: "1.1.0",

    /**
     *  为web要素服务功能创建一个新的解析器。
     * @memberof  GeoGlobe.Format.WFSCapabilities.prototype
     * @param {Object} options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     * 读取功能数据，并返回一个图层列表。
     * @memberof  GeoGlobe.Format.WFSCapabilities.prototype
     * @param {String | DOMElement}   data - 数据读取/解析。
     */    
    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities" 
});

/**
 * @class  GeoGlobe.Format.WFSCapabilities.v1
 * @classdesc 抽象类，不能直接实例化，应实例化其子类。
 * 
 */

GeoGlobe.Format.WFSCapabilities.v1 = GeoGlobe.Class4OL(
    GeoGlobe.Format.XML, {

    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof GeoGlobe.Format.WFSCapabilities.v1.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        wfs: "http://www.opengis.net/wfs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        ows: "http://www.opengis.net/ows"
    },


    /**
     * 为了确定解析是否失败而要检查的返回对象的哪个属性。
     * 如果返回的对象上的errorProperty未定义。
     * 则文档将通过OGCExceptionReport解析器运行。
     * @memberof GeoGlobe.Format.WFSCapabilities.v1.prototype
     * @type {String}
     */
    errorProperty: "featureTypeList",

    /**
     * defaultPrefix
     * @memberof GeoGlobe.Format.WFSCapabilities.v1.prototype
     * @type {null}
     * @private
     */
    defaultPrefix: "wfs",
    
    /**
     * 创建其中一个子类的实例。
     * @memberof GeoGlobe.Format.WFSCapabilities.v1.prototype
     * @classdesc GeoGlobe.Format.WFSCapabilities.v1_1
     * @param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */

    /**
     * 从字符串读取功能数据，并返回一个图层列表。
     * @memberof GeoGlobe.Format.WFSCapabilities.v1.prototype
     * @param {String| DOMElement} data - 数据读取/解析。
     * @returns {Array} 命名图层列表。
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var raw = data;
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        return capabilities;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WFSCapabilities.v1.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wfs": {
            "WFS_Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "FeatureTypeList": function(node, request) {
                request.featureTypeList = {
                    featureTypes: []
                };
                this.readChildNodes(node, request.featureTypeList);
            },
            "FeatureType": function(node, featureTypeList) {
                var featureType = {};
                this.readChildNodes(node, featureType);
                featureTypeList.featureTypes.push(featureType);
            },
            "Name": function(node, obj) {
                var name = this.getChildValue(node);
                if(name) {
                    var parts = name.split(":");
                    obj.name = parts.pop();
                    if(parts.length > 0) {
                        obj.featureNS = this.lookupNamespaceURI(node, parts[0]);
                    }
                }
            },
            "Title": function(node, obj) {
                var title = this.getChildValue(node);
                if(title) {
                    obj.title = title;
                }
            },
            "Abstract": function(node, obj) {
                var abst = this.getChildValue(node);
                if(abst) {
                    obj["abstract"] = abst;
                }
            }
        }
    },

    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities.v1" 

});

/**
 * @class  GeoGlobe.Format.WFSCapabilities/v1_0_0
 * @classdesc  Read WFS Capabilities version 1.0.0.
 * WFS服务 1.0.0版本的GetCapabilities操作格式化类。
 * @private
 */


GeoGlobe.Format.WFSCapabilities.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WFSCapabilities.v1, {
    
    /**
     * 为WFS功能版本1.0.0创建一个新的解析器。
     * @memberof GeoGlobe.Format.WFSCapabilities/v1_0_0.prototype
     * @param {Object}options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WFSCapabilities/v1_0_0.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "Service": function(node, capabilities) {
                capabilities.service = {};
                this.readChildNodes(node, capabilities.service);
            },
            "Fees": function(node, service) {
                var fees = this.getChildValue(node);
                if (fees && fees.toLowerCase() != "none") {
                    service.fees = fees;
                }
            },
            "AccessConstraints": function(node, service) {
                var constraints = this.getChildValue(node);
                if (constraints && constraints.toLowerCase() != "none") {
                    service.accessConstraints = constraints;
                }
            },
            "OnlineResource": function(node, service) {
                var onlineResource = this.getChildValue(node);
                if (onlineResource && onlineResource.toLowerCase() != "none") {
                    service.onlineResource = onlineResource;
                }
            },
            "Keywords": function(node, service) {
                var keywords = this.getChildValue(node);
                if (keywords && keywords.toLowerCase() != "none") {
                    service.keywords = keywords.split(', ');
                }
            },
            "Capability": function(node, capabilities) {
                capabilities.capability = {};
                this.readChildNodes(node, capabilities.capability);
            },
            "Request": function(node, obj) {
                obj.request = {};
                this.readChildNodes(node, obj.request);
            },
            "GetFeature": function(node, request) {
                request.getfeature = {
                    href: {}, // DCPType
                    formats: [] // ResultFormat
                };
                this.readChildNodes(node, request.getfeature);
            },
            "ResultFormat": function(node, obj) {
                var children = node.childNodes;
                var childNode;
                for(var i=0; i<children.length; i++) {
                    childNode = children[i];
                    if(childNode.nodeType == 1) {
                        obj.formats.push(childNode.nodeName);
                    }
                }
            },
            "DCPType": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "HTTP": function(node, obj) {
                this.readChildNodes(node, obj.href);
            },
            "Get": function(node, obj) {
                obj.get = node.getAttribute("onlineResource");
            },
            "Post": function(node, obj) {
                obj.post = node.getAttribute("onlineResource");
            },
            "SRS": function(node, obj) {
                var srs = this.getChildValue(node);
                if (srs) {
                    obj.srs = srs;
                }
            },
			"LatLongBoundingBox": function(node, obj) {
				var minx = node.getAttribute("minx");
				var miny = node.getAttribute("miny");
				var maxx = node.getAttribute("maxx");
				var maxy = node.getAttribute("maxy");
				obj.bbox = minx + "," + miny + "," + maxx + "," + maxy;
	        },
			"TemporalFeatureLayer": function(node, featureTypeList){//新增多时态WFS查询参数
			    featureTypeList.temporalFeatureLayers = [];
			    var temporalFeatureLayer = {};
			    this.readChildNodes(node, temporalFeatureLayer);
			    featureTypeList.temporalFeatureLayers.push(temporalFeatureLayer);
			},
			"Extent": function(node, obj){//TODO，需要验证，该节点是否废弃
			    //obj.time.name= node.getAttribute("name");
				obj.defaultTime = node.getAttribute("default");
				var timeArr = this.getChildValue(node).split("/");
				obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
			},
			"Dimension": function(node, obj) {//添加wfs:Dimension方法解析时间版本
				//obj.time.name= node.getAttribute("name");
				obj.defaultTime = node.getAttribute("default");
				var timeArr = this.getChildValue(node).split("/");
				obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
			}
        }, GeoGlobe.Format.WFSCapabilities.v1.prototype.readers["wfs"])
    },
    
    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities.v1_0_0" 

});

/**
 * @class  GeoGlobe.Format.WFSCapabilities/v1_0_0
 * @classdesc  Read WFS Capabilities version 1.0.0.
 * WFS服务 1.0.0版本的GetCapabilities操作格式化类。
 * @private
 */


GeoGlobe.Format.WFSCapabilities.v1_1_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WFSCapabilities.v1, {

    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof GeoGlobe.Format.WFSCapabilities/v1_0_0.prototype
     * @type {null}
     * @private
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },
    
    /**
     * Create a new parser for WFS capabilities version 1.1.0.
     * @memberof GeoGlobe.Format.WFSCapabilities/v1_0_0.prototype
     * @param {Object} options - An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WFSCapabilities/v1_0_0.prototype
     * @type {null}
     * @private
     */
    readers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "DefaultSRS": function(node, obj) {
                var defaultSRS = this.getChildValue(node);
                if (defaultSRS) {
                    obj.srs = defaultSRS;
                }
            },
			"WGS84BoundingBox": function(node, obj) {
				var lowerCorner = node.getElementsByTagName("ows:LowerCorner");
				var lowerCornerValue = this.getChildValue(lowerCorner[0]);
				var lowerCornerArray = lowerCornerValue.split(" ");
				
				var upperCorner = node.getElementsByTagName("ows:UpperCorner");
				var upperCornerValue = this.getChildValue(upperCorner[0]);
				var upperCornerArray = upperCornerValue.split(" ");
				obj.bbox = lowerCornerArray[0] + "," + lowerCornerArray[1] + "," + upperCornerArray[0] + "," + upperCornerArray[1];
			},
			"TemporalFeatureLayer": function(node, featureTypeList){//新增多时态WFS查询参数
			    featureTypeList.temporalFeatureLayers = [];
			    var temporalFeatureLayer = {};
			    this.readChildNodes(node, temporalFeatureLayer);
			    featureTypeList.temporalFeatureLayers.push(temporalFeatureLayer);
			},
			"Extent": function(node, obj){//TODO，需要验证，该节点是否废弃
			    //obj.time.name= node.getAttribute("name");
				obj.defaultTime = node.getAttribute("default");
				var timeArr = this.getChildValue(node).split("/");
				obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
			},
			"Dimension": function(node, obj) {//添加wfs:Dimension方法解析时间版本
				//obj.time.name= node.getAttribute("name");
				obj.defaultTime = node.getAttribute("default");
				var timeArr = this.getChildValue(node).split("/");
				obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
			}
        }, GeoGlobe.Format.WFSCapabilities.v1.prototype.readers["wfs"]),
        "ows": GeoGlobe.Format.OWSCommon.v1.prototype.readers.ows
    },

    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities.v1_1_0" 

});

/**
 * @class  GeoGlobe.Format.WFSDescribeFeatureType
 * @classdesc 阅读WFS DescribeFeatureType响应信息。
 * @returns {Object} 表示WFS DescribeFeatureType响应信息的对象。
 * @private
 */

GeoGlobe.Format.WFSDescribeFeatureType = GeoGlobe.Class4OL(
    GeoGlobe.Format.XML, {

    /**
     *  Compiled regular expressions for manipulating strings.
     * @memberof  GeoGlobe.Format.WFSDescribeFeatureType.prototype
     * @type {null}
     * @private
     *
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g)
    },
    
    /**
     * namespaces-Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.WFSDescribeFeatureType.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        xsd: "http://www.w3.org/2001/XMLSchema"
    },
    
    /**
     *  Create a new parser for WFS DescribeFeatureType responses.
     * @memberof  GeoGlobe.Format.WFSDescribeFeatureType.prototype
     * @param {Object} options - An optional object whose properties will be set on
     *     this instance.
     * @private
     */
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WFSDescribeFeatureType.prototype
     * @type {null}
     * @private
     */
    readers: {
        "xsd": {
            "schema": function(node, obj) {
                var complexTypes = [];
                var customTypes = {};
                var schema = {
                    complexTypes: complexTypes,
                    customTypes: customTypes
                };
                var i, len;
                
                this.readChildNodes(node, schema);

                var attributes = node.attributes;
                var attr, name;
                for(i=0, len=attributes.length; i<len; ++i) {
                    attr = attributes[i];
                    name = attr.name;
                    if(name.indexOf("xmlns") === 0) {
                        this.setNamespace(name.split(":")[1] || "", attr.value);
                    } else {
                        obj[name] = attr.value;
                    }
                }
                obj.featureTypes = complexTypes;                
                obj.targetPrefix = this.namespaceAlias[obj.targetNamespace];
                
                // map complexTypes to names of customTypes
                var complexType, customType;
                for(i=0, len=complexTypes.length; i<len; ++i) {
                    complexType = complexTypes[i];
                    customType = customTypes[complexType.typeName];
                    if(customTypes[complexType.typeName]) {
                        complexType.typeName = customType.name;
                    }
                }
            },
            "complexType": function(node, obj) {
                var complexType = {
                    // this is a temporary typeName, it will be overwritten by
                    // the schema reader with the metadata found in the
                    // customTypes hash
                    "typeName": node.getAttribute("name")
                };
                this.readChildNodes(node, complexType);
                obj.complexTypes.push(complexType);
            },
            "complexContent": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "extension": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "sequence": function(node, obj) {
                var sequence = {
                    elements: []
                };
                this.readChildNodes(node, sequence);
                obj.properties = sequence.elements;
            },
            "element": function(node, obj) {
                var type;
                if(obj.elements) {
                    var element = {};
                    var attributes = node.attributes;
                    var attr;
                    for(var i=0, len=attributes.length; i<len; ++i) {
                        attr = attributes[i];
                        element[attr.name] = attr.value;
                    }
                    
					type = element.type || element.ref;
                    if(!type) {
                        type = {};
                        this.readChildNodes(node, type);
                        element.restriction = type;
                        element.type = type.base;
                    }
                    var fullType = type.base || type;
                    element.localType = fullType.split(":").pop();
                    obj.elements.push(element);
                    this.readChildNodes(node, element);
                }
                
                if(obj.complexTypes) {
                    type = node.getAttribute("type");
                    var localType = type.split(":").pop();
                    obj.customTypes[localType] = {
                        "name": node.getAttribute("name"),
                        "type": type
                    };
                }
            },
            "annotation": function(node, obj) {
                obj.annotation = {};
                this.readChildNodes(node, obj.annotation);
            },
            "appinfo": function(node, obj) {
                if (!obj.appinfo) {
                    obj.appinfo = [];
                }
                obj.appinfo.push(this.getChildValue(node));
            },
            "documentation": function(node, obj) {
                if (!obj.documentation) {
                    obj.documentation = [];
                }
                var value = this.getChildValue(node);
                obj.documentation.push({
                    lang: node.getAttribute("xml:lang"),
                    textContent: value.replace(this.regExes.trimSpace, "")
                });
            },
            "simpleType": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "restriction": function(node, obj) {
                obj.base = node.getAttribute("base");
                this.readRestriction(node, obj);
            }
        }
    },
    
    /**
     * Reads restriction defined in the child nodes of a restriction element
     * @memberof  GeoGlobe.Format.WFSDescribeFeatureType.prototype
     * @param {DOMElement}  node - the node to parse
     * obj - {Object} the object that receives the read result
     * @private
     */
    readRestriction: function(node, obj) {
        var children = node.childNodes;
        var child, nodeName, value;
        for(var i=0, len=children.length; i<len; ++i) {
            child = children[i];
            if(child.nodeType == 1) {
                nodeName = child.nodeName.split(":").pop();
                value = child.getAttribute("value");
                if(!obj[nodeName]) {
                    obj[nodeName] = value;
                } else {
                    if(typeof obj[nodeName] == "string") {
                        obj[nodeName] = [obj[nodeName]];
                    }
                    obj[nodeName].push(value);
                }
            }
        }
    },
    
    /**
     * @memberof  GeoGlobe.Format.WFSDescribeFeatureType.prototype
     * @param {DOMElement|String}data - A WFS DescribeFeatureType document.
     * @private
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var schema = {};
        if (data.nodeName.split(":").pop() === 'ExceptionReport') {
            // an exception must have occurred, so parse it
            var parser = new GeoGlobe.Format.OGCExceptionReport();
            schema.error = parser.read(data);
        } else {
            this.readNode(data, schema);
        }
        return schema;
    },
    
    CLASS_NAME: "GeoGlobe.Format.WFSDescribeFeatureType"

});

/**
 * @class  GeoGlobe.Format.WKT
 * @classdesc 用于阅读和编写公认文本的类。 用GeoGlobe.Format.WKT构造函数创建一个新实例。
 * @returns {GeoGlobe.Format.WKT} 新的WKT解析器。
 */

GeoGlobe.Format.WKT = GeoGlobe.Class4OL(GeoGlobe.Format, {
    
    /**
     * 为WKT创建一个新的解析器
     * @memberof GeoGlobe.Format.WKT.prototype
     * @param {Object} options - 一个可选对象，其属性将在此实例上设置
     */
    initialize: function(options) {
        this.regExes = {
            'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
            'spaces': /\s+/,
            'parenComma': /\)\s*,\s*\(/,
            'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/,  // can't use {2} here
            'trimParens': /^\s*\(?(.*?)\)?\s*$/
        };
        GeoGlobe.Format.prototype.initialize.apply(this, [options]);
    },

    /**
     * 解析WKT字符串并返回矢量要素或矢量要素数组。 支持点，多点，
     * @memberof GeoGlobe.Format.WKT.prototype
     * @param {String}wkt - 一个WKT字符串
     * @returns {GeoGlobe.Feature|Array} 用于GEOMETRYCOLLECTION WKT的特征或特征阵列。
     */
    read: function(wkt) {
        var features, type, str;
        wkt = wkt.replace(/[\n\r]/g, " ");
        var matches = this.regExes.typeStr.exec(wkt);
        if(matches) {
            type = matches[1].toLowerCase();
            str = matches[2];
            if(this.parse[type]) {
                features = this.parse[type].apply(this, [str]);
            }
            if (this.internalProjection && this.externalProjection) {
                if (features && 
                    features.CLASS_NAME == "GeoGlobe.Feature") {
                    features.geometry.transform(this.externalProjection,
                                                this.internalProjection);
                } else if (features &&
                           type != "geometrycollection" &&
                           typeof features == "object") {
                    for (var i=0, len=features.length; i<len; i++) {
                        var component = features[i];
                        component.geometry.transform(this.externalProjection,
                                                     this.internalProjection);
                    }
                }
            }
        }    
        return features;
    },

    /**
     * 将特征或特征数组编译成WKT字符串。
     * @memberof GeoGlobe.Format.WKT.prototype
     * @param {GeoGlobe.Feature|Array}features - 一个功能或一系列功能
     * @returns {String} 返回输入几何图形的WKT字符串表示
     */
    write: function(features) {
        var collection, geometry, isCollection;
        if (features.constructor == Array) {
            collection = features;
            isCollection = true;
        } else {
            collection = [features];
            isCollection = false;
        }
        var pieces = [];
        if (isCollection) {
            pieces.push('GEOMETRYCOLLECTION(');
        }
        for (var i=0, len=collection.length; i<len; ++i) {
            if (isCollection && i>0) {
                pieces.push(',');
            }
            geometry = collection[i].geometry;
            pieces.push(this.extractGeometry(geometry));
        }
        if (isCollection) {
            pieces.push(')');
        }
        return pieces.join('');
    },

    /**
     * Entry point to construct the WKT for a single Geometry object.
     * @memberof  GeoGlobe.Format.WKT.prototype
     * @param {GeoGlobe.Geometry.Geometry} geometry -
     * @returns {String} A WKT string of representing the geometry
     * @private
     */
    extractGeometry: function(geometry) {
        var type = geometry.CLASS_NAME.split('.')[2].toLowerCase();
        if (!this.extract[type]) {
            return null;
        }
        if (this.internalProjection && this.externalProjection) {
            geometry = geometry.clone();
            geometry.transform(this.internalProjection, this.externalProjection);
        }                       
        var wktType = type == 'collection' ? 'GEOMETRYCOLLECTION' : type.toUpperCase();
        var data = wktType + '(' + this.extract[type].apply(this, [geometry]) + ')';
        return data;
    },
    

    extract: {
        /**
         * Return a space delimited string of point coordinates.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.Point} point
         * @returns {String} A string of coordinates representing the point
         * @private
         */
        'point': function(point) {
            return point.x + ' ' + point.y;
        },

        /**
         * Return a comma delimited string of point coordinates from a multipoint.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.MultiPoint} multipoint
         * @returns {String} A string of point coordinate strings representing
         *                  the multipoint
         * @private
         */
        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.point.apply(this, [multipoint.components[i]]) +
                           ')');
            }
            return array.join(',');
        },
        
        /**
         *  Return a comma delimited string of point coordinates from a line.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.LineString} linestring
         * @returns {String} A string of point coordinate strings representing
         *                  the linestring
         * @private
         */
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array.join(',');
        },

        /**
         * Return a comma delimited string of linestring strings from a multilinestring.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.MultiLineString} multilinestring
         * @returns {String} A string of of linestring strings representing
         *                  the multilinestring
         * @private
         */
        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.linestring.apply(this, [multilinestring.components[i]]) +
                           ')');
            }
            return array.join(',');
        },
        
        /**
         * Return a comma delimited string of linear ring arrays from a polygon.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.Polygon} polygon
         * @returns {String} An array of linear ring arrays representing the polygon
         * @private
         */
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.linestring.apply(this, [polygon.components[i]]) +
                           ')');
            }
            return array.join(',');
        },

        /**
         * Return an array of polygon arrays from a multipolygon.
         * @memberof   GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.MultiPolygon} multipolygon
         * @returns {String} An array of polygon arrays representing
         *                  the multipolygon
         * @private
         */
        'multipolygon': function(multipolygon) {
            var array = [];
            for(var i=0, len=multipolygon.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.polygon.apply(this, [multipolygon.components[i]]) +
                           ')');
            }
            return array.join(',');
        },

        /**
         * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an GeoGlobe.Geometry.Collection
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.Collection} collection
         * @returns {String} internal WKT representation of the collection
         * @private
         */
        'collection': function(collection) {
            var array = [];
            for(var i=0, len=collection.components.length; i<len; ++i) {
                array.push(this.extractGeometry.apply(this, [collection.components[i]]));
            }
            return array.join(',');
        }

    },


    parse: {
        /**
         * Return point feature given a point WKT fragment.
         * @param {String} str A WKT fragment representing the point
         * @returns {GeoGlobe.Feature} A point feature
         * @private
         */
        'point': function(str) {
            var coords = GeoGlobe.String.trim(str).split(this.regExes.spaces);
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.Point(coords[0], coords[1])
            );
        },

        /**
         * Return a multipoint feature given a multipoint WKT fragment.
         * @memberof   GeoGlobe.Format.WKT.prototype
         * @param {String} str A WKT fragment representing the multipoint
         * @returns {GeoGlobe.Feature} A multipoint feature
         * @private
         */
        'multipoint': function(str) {
            var point;
            var points = GeoGlobe.String.trim(str).split(',');
            var components = [];
            for(var i=0, len=points.length; i<len; ++i) {
                point = points[i].replace(this.regExes.trimParens, '$1');
                components.push(this.parse.point.apply(this, [point]).geometry);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.MultiPoint(components)
            );
        },
        
        /**
         * Return a linestring feature given a linestring WKT fragment.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {String} str A WKT fragment representing the linestring
         * @returns {GeoGlobe.Feature} A linestring feature
         * @private
         */
        'linestring': function(str) {
            var points = GeoGlobe.String.trim(str).split(',');
            var components = [];
            for(var i=0, len=points.length; i<len; ++i) {
                components.push(this.parse.point.apply(this, [points[i]]).geometry);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.LineString(components)
            );
        },

        /**
         * Return a multilinestring feature given a multilinestring WKT fragment.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {String} str A WKT fragment representing the multilinestring
         * @returns {GeoGlobe.Feature} A multilinestring feature
         * @private
         */
        'multilinestring': function(str) {
            var line;
            var lines = GeoGlobe.String.trim(str).split(this.regExes.parenComma);
            var components = [];
            for(var i=0, len=lines.length; i<len; ++i) {
                line = lines[i].replace(this.regExes.trimParens, '$1');
                components.push(this.parse.linestring.apply(this, [line]).geometry);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.MultiLineString(components)
            );
        },
        
        /**
         * Return a polygon feature given a polygon WKT fragment.
         * @memberof   GeoGlobe.Format.WKT.prototyp
         * @param {String} str A WKT fragment representing the polygon
         * @returns {GeoGlobe.Feature} A polygon feature
         * @private
         */
        'polygon': function(str) {
            var ring, linestring, linearring;
            var rings = GeoGlobe.String.trim(str).split(this.regExes.parenComma);
            var components = [];
            for(var i=0, len=rings.length; i<len; ++i) {
                ring = rings[i].replace(this.regExes.trimParens, '$1');
                linestring = this.parse.linestring.apply(this, [ring]).geometry;
                linearring = new GeoGlobe.Geometry.LinearRing(linestring.components);
                components.push(linearring);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.Polygon(components)
            );
        },

        /**
         * Return a multipolygon feature given a multipolygon WKT fragment.
         * @memberof   GeoGlobe.Format.WKT.prototype
         * @param {String} str A WKT fragment representing the multipolygon
         * @returns {GeoGlobe.Feature.Vector} A multipolygon feature
         * @private
         */
        'multipolygon': function(str) {
            var polygon;
            var polygons = GeoGlobe.String.trim(str).split(this.regExes.doubleParenComma);
            var components = [];
            for(var i=0, len=polygons.length; i<len; ++i) {
                polygon = polygons[i].replace(this.regExes.trimParens, '$1');
                components.push(this.parse.polygon.apply(this, [polygon]).geometry);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.MultiPolygon(components)
            );
        },

        /**
         * Return an array of features given a geometrycollection WKT fragment.
         * @memberof   GeoGlobe.Format.WKT.prototype
         * @param {String} str A WKT fragment representing the geometrycollection
         * @returns {Array} An array of GeoGlobe.Feature.
         * @private
         */
        'geometrycollection': function(str) {
            // separate components of the collection with |
            str = str.replace(/,\s*([A-Za-z])/g, '|$1');
            var wktArray = GeoGlobe.String.trim(str).split('|');
            var components = [];
            for(var i=0, len=wktArray.length; i<len; ++i) {
                components.push(GeoGlobe.Format.WKT.prototype.read.apply(this,[wktArray[i]]));
            }
            return components;
        }

    },

    CLASS_NAME: "GeoGlobe.Format.WKT" 
});     

/**
 * @class  GeoGlobe.Format.CQL.prototype
 * @classdesc 阅读CQL字符串以获取GeoGlobe.Filter对象。 编写GeoGlobe.Filter对象来获取CQL字符串。 使用创建一个新的分析器
  GeoGlobe.Format.CQL构造函数。
 */

GeoGlobe.Format.CQL = (function() {
    
    var tokens = [
        "PROPERTY", "COMPARISON", "VALUE", "LOGICAL"
    ],

    patterns = {
        PROPERTY: /^[_a-zA-Z]\w*/,
        COMPARISON: /^(=|<>|<=|<|>=|>|LIKE)/i,
        IS_NULL: /^IS NULL/i,
        COMMA: /^,/,
        LOGICAL: /^(AND|OR)/i,
        VALUE: /^('([^']|'')*'|\d+(\.\d*)?|\.\d+)/,
        LPAREN: /^\(/,
        RPAREN: /^\)/,
        SPATIAL: /^(BBOX|INTERSECTS|DWITHIN|WITHIN|CONTAINS)/i,
        NOT: /^NOT/i,
        BETWEEN: /^BETWEEN/i,
        GEOMETRY: function(text) {
            var type = /^(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)/.exec(text);
            if (type) {
                var len = text.length;
                var idx = text.indexOf("(", type[0].length);
                if (idx > -1) {
                    var depth = 1;
                    while (idx < len && depth > 0) {
                        idx++;
                        switch(text.charAt(idx)) {
                            case '(':
                                depth++;
                                break;
                            case ')':
                                depth--;
                                break;
                            default:
                                // in default case, do nothing
                        }
                    }
                }
                return [text.substr(0, idx+1)];
            }
        },
        END: /^$/
    },

    follows = {
        LPAREN: ['GEOMETRY', 'SPATIAL', 'PROPERTY', 'VALUE', 'LPAREN'],
        RPAREN: ['NOT', 'LOGICAL', 'END', 'RPAREN'],
        PROPERTY: ['COMPARISON', 'BETWEEN', 'COMMA', 'IS_NULL'],
        BETWEEN: ['VALUE'],
        IS_NULL: ['END'],
        COMPARISON: ['VALUE'],
        COMMA: ['GEOMETRY', 'VALUE', 'PROPERTY'],
        VALUE: ['LOGICAL', 'COMMA', 'RPAREN', 'END'],
        SPATIAL: ['LPAREN'],
        LOGICAL: ['NOT', 'VALUE', 'SPATIAL', 'PROPERTY', 'LPAREN'],
        NOT: ['PROPERTY', 'LPAREN'],
        GEOMETRY: ['COMMA', 'RPAREN']
    },

    operators = {
        '=': GeoGlobe.Filter.Comparison.EQUAL_TO,
        '<>': GeoGlobe.Filter.Comparison.NOT_EQUAL_TO,
        '<': GeoGlobe.Filter.Comparison.LESS_THAN,
        '<=': GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO,
        '>': GeoGlobe.Filter.Comparison.GREATER_THAN,
        '>=': GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO,
        'LIKE': GeoGlobe.Filter.Comparison.LIKE,
        'BETWEEN': GeoGlobe.Filter.Comparison.BETWEEN,
        'IS NULL': GeoGlobe.Filter.Comparison.IS_NULL
    },

    operatorReverse = {},

    logicals = {
        'AND': GeoGlobe.Filter.Logical.AND,
        'OR': GeoGlobe.Filter.Logical.OR
    },

    logicalReverse = {},

    precedence = {
        'RPAREN': 3,
        'LOGICAL': 2,
        'COMPARISON': 1
    };

    var i;
    for (i in operators) {
        if (operators.hasOwnProperty(i)) {
            operatorReverse[operators[i]] = i;
        }
    }

    for (i in logicals) {
        if (logicals.hasOwnProperty(i)) {
            logicalReverse[logicals[i]] = i;
        }
    }

    function tryToken(text, pattern) {
        if (pattern instanceof RegExp) {
            return pattern.exec(text);
        } else {
            return pattern(text);
        }
    }

    function nextToken(text, tokens) {
        var i, token, len = tokens.length;
        for (i=0; i<len; i++) {
            token = tokens[i];
            var pat = patterns[token];
            var matches = tryToken(text, pat);
            if (matches) {
                var match = matches[0];
                var remainder = text.substr(match.length).replace(/^\s*/, "");
                return {
                    type: token,
                    text: match,
                    remainder: remainder
                };
            }
        }

        var msg = "ERROR: In parsing: [" + text + "], expected one of: ";
        for (i=0; i<len; i++) {
            token = tokens[i];
            msg += "\n    " + token + ": " + patterns[token];
        }

        throw new Error(msg);
    }

    function tokenize(text) {
        var results = [];
        var token, expect = ["NOT", "GEOMETRY", "SPATIAL", "PROPERTY", "LPAREN"];

        do {
            token = nextToken(text, expect);
            text = token.remainder;
            expect = follows[token.type];
            if (token.type != "END" && !expect) {
                throw new Error("No follows list for " + token.type);
            }
            results.push(token);
        } while (token.type != "END");

        return results;
    }

    function buildAst(tokens) {
        var operatorStack = [],
            postfix = [];

        while (tokens.length) {
            var tok = tokens.shift();
            switch (tok.type) {
                case "PROPERTY":
                case "GEOMETRY":
                case "VALUE":
                    postfix.push(tok);
                    break;
                case "COMPARISON":
                case "BETWEEN":
                case "IS_NULL":
                case "LOGICAL":
                    var p = precedence[tok.type];

                    while (operatorStack.length > 0 &&
                        (precedence[operatorStack[operatorStack.length - 1].type] <= p)
                    ) {
                        postfix.push(operatorStack.pop());
                    }

                    operatorStack.push(tok);
                    break;
                case "SPATIAL":
                case "NOT":
                case "LPAREN":
                    operatorStack.push(tok);
                    break;
                case "RPAREN":
                    while (operatorStack.length > 0 &&
                        (operatorStack[operatorStack.length - 1].type != "LPAREN")
                    ) {
                        postfix.push(operatorStack.pop());
                    }
                    operatorStack.pop(); // toss out the LPAREN

                    if (operatorStack.length > 0 &&
                        operatorStack[operatorStack.length-1].type == "SPATIAL") {
                        postfix.push(operatorStack.pop());
                    }
                case "COMMA":
                case "END":
                    break;
                default:
                    throw new Error("Unknown token type " + tok.type);
            }
        }

        while (operatorStack.length > 0) {
            postfix.push(operatorStack.pop());
        }

        function buildTree() {
            var tok = postfix.pop();
            switch (tok.type) {
                case "LOGICAL":
                    var rhs = buildTree(),
                        lhs = buildTree();
                    return new GeoGlobe.Filter.Logical({
                        filters: [lhs, rhs],
                        type: logicals[tok.text.toUpperCase()]
                    });
                case "NOT":
                    var operand = buildTree();
                    return new GeoGlobe.Filter.Logical({
                        filters: [operand],
                        type: GeoGlobe.Filter.Logical.NOT
                    });
                case "BETWEEN":
                    var min, max, property;
                    postfix.pop(); // unneeded AND token here
                    max = buildTree();
                    min = buildTree();
                    property = buildTree();
                    return new GeoGlobe.Filter.Comparison({
                        property: property,
                        lowerBoundary: min,
                        upperBoundary: max,
                        type: GeoGlobe.Filter.Comparison.BETWEEN
                    });
                case "COMPARISON":
                    var value = buildTree(),
                        property = buildTree();
                    return new GeoGlobe.Filter.Comparison({
                        property: property,
                        value: value,
                        type: operators[tok.text.toUpperCase()]
                    });
                case "IS_NULL":
                    var property = buildTree();
                    return new GeoGlobe.Filter.Comparison({
                        property: property,
                        type: operators[tok.text.toUpperCase()]
                    });
                case "VALUE":
                    var match = tok.text.match(/^'(.*)'$/);
                    if (match) {
                        return match[1].replace(/''/g, "'");
                    } else {
                        return Number(tok.text);
                    }
                case "SPATIAL":
                    switch(tok.text.toUpperCase()) {
                        case "BBOX":
                            var maxy = buildTree(),
                                maxx = buildTree(),
                                miny = buildTree(),
                                minx = buildTree(),
                                prop = buildTree();

                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.BBOX,
                                property: prop,
                                value: GeoGlobe.LngLatBounds.fromArray(
                                    [minx, miny, maxx, maxy]
                                )
                            });
                        case "INTERSECTS":
                            var value = buildTree(),
                                property = buildTree();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.INTERSECTS,
                                property: property,
                                value: value
                            });
                        case "WITHIN":
                            var value = buildTree(),
                                property = buildTree();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.WITHIN,
                                property: property,
                                value: value
                            });
                        case "CONTAINS":
                            var value = buildTree(),
                                property = buildTree();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.CONTAINS,
                                property: property,
                                value: value
                            });
                        case "DWITHIN":
                            var distance = buildTree(),
                                value = buildTree(),
                                property = buildTree();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.DWITHIN,
                                value: value,
                                property: property,
                                distance: Number(distance)
                            });
                    }
                case "GEOMETRY":
                    return GeoGlobe.Geometry.fromWKT(tok.text);
                default:
                    return tok.text;
            }
        }

        var result = buildTree();
        if (postfix.length > 0) {
            var msg = "Remaining tokens after building AST: \n";
            for (var i = postfix.length - 1; i >= 0; i--) {
                msg += postfix[i].type + ": " + postfix[i].text + "\n";
            }
            throw new Error(msg);
        }

        return result;
    }

    return GeoGlobe.Class4OL(GeoGlobe.Format, {
        /**
         * 从CQL字符串生成过滤器。
         * @memberof  GeoGlobe.Format.CQL.prototype
         * @param {String}  text - CQL文本。
         * @returns {GeoGlobe.Filter} 基于CQL文本的过滤器。
         */
        read: function(text) { 
            var result = buildAst(tokenize(text));
            if (this.keepData) {
                this.data = result;
            }
            return result;
        },

        /**
         * 将过滤器转换为CQL字符串。
         * @memberof GeoGlobe.Format.CQL.prototype
         * @param {GeoGlobe.Filter}filter -  过滤器。
         * @returns {String} 基于过滤器的CQL字符串。
         */
        write: function(filter) {
            if (filter instanceof GeoGlobe.Geometry) {
                return filter.toString();
            }
            switch (filter.CLASS_NAME) {
                case "GeoGlobe.Filter.Spatial":
                    switch(filter.type) {
                        case GeoGlobe.Filter.Spatial.BBOX:
                            return "BBOX(" +
                                filter.property + "," +
                                filter.value.toBBOX() +
                                ")";
                        case GeoGlobe.Filter.Spatial.DWITHIN:
                            return "DWITHIN(" +
                                filter.property + ", " +
                                this.write(filter.value) + ", " +
                                filter.distance + ")";
                        case GeoGlobe.Filter.Spatial.WITHIN:
                            return "WITHIN(" +
                                filter.property + ", " +
                                this.write(filter.value) + ")";
                        case GeoGlobe.Filter.Spatial.INTERSECTS:
                            return "INTERSECTS(" +
                                filter.property + ", " +
                                this.write(filter.value) + ")";
                        case GeoGlobe.Filter.Spatial.CONTAINS:
                            return "CONTAINS(" +
                                filter.property + ", " +
                                this.write(filter.value) + ")";
                        default:
                            throw new Error("Unknown spatial filter type: " + filter.type);
                    }
                case "GeoGlobe.Filter.Logical":
                    if (filter.type == GeoGlobe.Filter.Logical.NOT) {
                        // TODO: deal with precedence of logical operators to 
                        // avoid extra parentheses (not urgent)
                        return "NOT (" + this.write(filter.filters[0]) + ")";
                    } else {
                        var res = "(";
                        var first = true;
                        for (var i = 0; i < filter.filters.length; i++) {
                            if (first) {
                                first = false;
                            } else {
                                res += ") " + logicalReverse[filter.type] + " (";
                            }
                            res += this.write(filter.filters[i]);
                        }
                        return res + ")";
                    }
                case "GeoGlobe.Filter.Comparison":
                    if (filter.type == GeoGlobe.Filter.Comparison.BETWEEN) {
                        return filter.property + " BETWEEN " + 
                            this.write(filter.lowerBoundary) + " AND " + 
                            this.write(filter.upperBoundary);
                    } else {
                        return (filter.value !== null) ? filter.property +
                            " " + operatorReverse[filter.type] + " " + 
                            this.write(filter.value) : filter.property +
                            " " + operatorReverse[filter.type];
                    }
                case undefined:
                    if (typeof filter === "string") {
                        return "'" + filter.replace(/'/g, "''") + "'";
                    } else if (typeof filter === "number") {
                        return String(filter);
                    }
                default:
                    throw new Error("Can't encode: " + filter.CLASS_NAME + " " + filter);
            }
        },

        CLASS_NAME: "GeoGlobe.Format.CQL"

    });
})();


/**
 * @class GeoGlobe.Format.Filter
 * @classdesc  用GeoGlobe.Format.Filter构造函数创建一个新实例。
 * 过滤器的格式化类。
 */


GeoGlobe.Format.Filter = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {

    /**
     * 默认版本 - 如果没有找到，则假定版本号。 默认值是“1.0.0”。
     * @memberof GeoGlobe.Format.Filter.prototype
     * @type {String}
     */

    defaultVersion: "1.0.0",
    
    /**
     * 写一个ogc：Filter给定一个过滤器对象。
     * @memberof GeoGlobe.Format.Filter.prototype
     * @param {GeoGlobe.Filter} filter -一个过滤器。
     * @param  {Object}options - 可选的配置对象。
     * @returns {Elment} ogc：过滤元素节点。
     */
    
    /**
     * 阅读并过滤文档并返回代表过滤器的对象。
     * @memberof GeoGlobe.Format.Filter.prototype
     * @param {String | DOMElement}data -  要读取的数据
     * @returns {GeoGlobe.Filter} 过滤器对象。
     */

    CLASS_NAME: "GeoGlobe.Format.Filter" 
});

/** Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class  GeoGlobe.Format.Filter.v1

 * @classdesc 过滤器的格式化超类。
 *
 * 继承:
 *  - GeoGlobe.Format.XML
 */
GeoGlobe.Format.Filter.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**

     * Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.Filter.v1.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ogc: "http://www.opengis.net/ogc",
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * defaultPrefix
     * @memberof  GeoGlobe.Format.Filter.v1.prototype
     * @private
     */
    defaultPrefix: "ogc",

    /**
     *  Schema location for a particular minor version.
     *@memberof  GeoGlobe.Format.Filter.v1.prototype
     * @type {String}
     * @private
     */
    schemaLocation: null,
    
    /**

     * 这个类的实例不是直接创建的。改为使用GeoGlobe.Format.Filter构造函数。
     *@memberof  GeoGlobe.Format.Filter.v1.prototype
     * @param {Object} options -  一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },
    
    /**

     *@memberof  GeoGlobe.Format.Filter.v1.prototype
     * @param {DOMElement} data -  A Filter document element.
     *
     * @returns {GeoGlobe.Filter} A filter object.
     * @private
     */
    read: function(data) {
        var obj = {};
        this.readers.ogc["Filter"].apply(this, [data, obj]);
        return obj.filter;
    },
    
    /**
     * readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.Filter.v1.prototype
     * @private
     */
    readers: {
        "ogc": {
            "_expression": function(node) {
                // only the simplest of ogc:expression handled
                // "some text and an <PropertyName>attribute</PropertyName>"}
                var obj, value = "";
                for(var child=node.firstChild; child; child=child.nextSibling) {
                    switch(child.nodeType) {
                        case 1:
                            obj = this.readNode(child);
                            if (obj.property) {
                                value += "${" + obj.property + "}";
                            } else if (obj.value !== undefined) {
                                value += obj.value;
                            }
                            break;
                        case 3: // text node
                        case 4: // cdata section
                            value += child.nodeValue;
                    }
                }
                return value;
            },
            "Filter": function(node, parent) {
                // Filters correspond to subclasses of GeoGlobe.Filter.
                // Since they contain information we don't persist, we
                // create a temporary object and then pass on the filter
                // (ogc:Filter) to the parent obj.
                var obj = {
                    fids: [],
                    filters: []
                };
                this.readChildNodes(node, obj);
                if(obj.fids.length > 0) {
                    parent.filter = new GeoGlobe.Filter.FeatureId({
                        fids: obj.fids
                    });
                } else if(obj.filters.length > 0) {
                    parent.filter = obj.filters[0];
                }
            },
            "FeatureId": function(node, obj) {
                var fid = node.getAttribute("fid");
                if(fid) {
                    obj.fids.push(fid);
                }
            },
            "And": function(node, obj) {
                var filter = new GeoGlobe.Filter.Logical({
                    type: GeoGlobe.Filter.Logical.AND
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "Or": function(node, obj) {
                var filter = new GeoGlobe.Filter.Logical({
                    type: GeoGlobe.Filter.Logical.OR
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "Not": function(node, obj) {
                var filter = new GeoGlobe.Filter.Logical({
                    type: GeoGlobe.Filter.Logical.NOT
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLessThan": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LESS_THAN
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsGreaterThan": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.GREATER_THAN
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLessThanOrEqualTo": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsGreaterThanOrEqualTo": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsBetween": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.BETWEEN
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "Literal": function(node, obj) {
                obj.value = GeoGlobe.String.numericIf(
                    this.getChildValue(node), true);
            },
            "PropertyName": function(node, filter) {
                filter.property = this.getChildValue(node);
            },
            "LowerBoundary": function(node, filter) {
                filter.lowerBoundary = GeoGlobe.String.numericIf(
                    this.readers.ogc._expression.call(this, node), true);
            },
            "UpperBoundary": function(node, filter) {
                filter.upperBoundary = GeoGlobe.String.numericIf(
                    this.readers.ogc._expression.call(this, node), true);
            },
            "Intersects": function(node, obj) {
                this.readSpatial(node, obj, GeoGlobe.Filter.Spatial.INTERSECTS);
            },
            "Within": function(node, obj) {
                this.readSpatial(node, obj, GeoGlobe.Filter.Spatial.WITHIN);
            },
            "Contains": function(node, obj) {
                this.readSpatial(node, obj, GeoGlobe.Filter.Spatial.CONTAINS);
            },
            "DWithin": function(node, obj) {
                this.readSpatial(node, obj, GeoGlobe.Filter.Spatial.DWITHIN);
            },
            "Distance": function(node, obj) {
                obj.distance = parseInt(this.getChildValue(node));
                obj.distanceUnits = node.getAttribute("units");
            },
            "Function": function(node, obj) {
                //TODO write decoder for it
                return;
            },
            "PropertyIsNull": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.IS_NULL
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            }
        }
    },
    
    /**

     *@memberof  GeoGlobe.Format.Filter.v1.prototype
     * Read a {GeoGlobe.Filter.Spatial} filter.
     * 

     *  @param {DOMElement} node -A DOM element that contains an ogc:expression.
     *  @param {Object}obj - The target object.
     *  @param {String}type -  One of the GeoGlobe.Filter.Spatial.* constants.
     *
     * @returns
     * {GeoGlobe.Filter.Spatial} The created filter.
     * @private
     */
    readSpatial: function(node, obj, type) {
        var filter = new GeoGlobe.Filter.Spatial({
            type: type
        });
        this.readChildNodes(node, filter);
        filter.value = filter.components[0];
        delete filter.components;
        obj.filters.push(filter);
    },

    /**

     * 生成用于Literal元素值的字符串表示形式。 默认编码器将日期值写为ISO 8601字符串。
     * @memberof  GeoGlobe.Format.Filter.v1.prototype
     * @param {Object}value -  字面值编码
     *
     * @returns {String} 所提供值的字符串表示形式。
     */
    encodeLiteral: function(value) {
        if (value instanceof Date) {
            value = GeoGlobe.Date.toISOString(value);
        }
        return value;
    },

    /**

     * Limited support for writing OGC expressions. Currently it supports
     * (GeoGlobe.Filter.Function || String || Number)
     *@memberof  GeoGlobe.Format.Filter.v1.prototype

     * @param (GeoGlobe.Filter.Function| String | Number)value -
     * @param {DOMElement}node -  A parent DOM element
     *
     * @returns
     * {DOMElement} Updated node element.
     * @private
     */
    writeOgcExpression: function(value, node) {
        if (value instanceof GeoGlobe.Filter.Function){
            this.writeNode("Function", value, node);
        } else {
            this.writeNode("Literal", value, node);
        }
        return node;
    },    
    
    /**

     *@memberof  GeoGlobe.Format.Filter.v1.prototype
     * @param {GeoGlobe.Filter}  filter - A filter object.
     *
     * @returns {DOMElement} An ogc:Filter element.
     * @private
     */
    write: function(filter) {
        return this.writers.ogc["Filter"].apply(this, [filter]);
    },
    
    /**

     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.v1.prototype
     * @private
     */
    writers: {
        "ogc": {
            "Filter": function(filter) {
                var node = this.createElementNSPlus("ogc:Filter");
                this.writeNode(this.getFilterType(filter), filter, node);
                return node;
            },
            "_featureIds": function(filter) {
                var node = this.createDocumentFragment();
                for (var i=0, ii=filter.fids.length; i<ii; ++i) {
                    this.writeNode("ogc:FeatureId", filter.fids[i], node);
                }
                return node;
            },
            "FeatureId": function(fid) {
                return this.createElementNSPlus("ogc:FeatureId", {
                    attributes: {fid: fid}
                });
            },
            "And": function(filter) {
                var node = this.createElementNSPlus("ogc:And");
                var childFilter;
                for (var i=0, ii=filter.filters.length; i<ii; ++i) {
                    childFilter = filter.filters[i];
                    this.writeNode(
                        this.getFilterType(childFilter), childFilter, node
                    );
                }
                return node;
            },
            "Or": function(filter) {
                var node = this.createElementNSPlus("ogc:Or");
                var childFilter;
                for (var i=0, ii=filter.filters.length; i<ii; ++i) {
                    childFilter = filter.filters[i];
                    this.writeNode(
                        this.getFilterType(childFilter), childFilter, node
                    );
                }
                return node;
            },
            "Not": function(filter) {
                var node = this.createElementNSPlus("ogc:Not");
                var childFilter = filter.filters[0];
                this.writeNode(
                    this.getFilterType(childFilter), childFilter, node
                );
                return node;
            },
            "PropertyIsLessThan": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLessThan");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsGreaterThan": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsGreaterThan");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsLessThanOrEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLessThanOrEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsGreaterThanOrEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsGreaterThanOrEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsBetween": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsBetween");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                this.writeNode("LowerBoundary", filter, node);
                this.writeNode("UpperBoundary", filter, node);
                return node;
            },
            "PropertyName": function(filter) {
                // no ogc:expression handling for now
                return this.createElementNSPlus("ogc:PropertyName", {
                    value: filter.property
                });
            },
            "Literal": function(value) {
                var encode = this.encodeLiteral ||
                    GeoGlobe.Format.Filter.v1.prototype.encodeLiteral;
                return this.createElementNSPlus("ogc:Literal", {
                    value: encode(value)
                });
            },
            "LowerBoundary": function(filter) {
                // handle Literals or Functions for now
                var node = this.createElementNSPlus("ogc:LowerBoundary");
                this.writeOgcExpression(filter.lowerBoundary, node);
                return node;
            },
            "UpperBoundary": function(filter) {
                // handle Literals or Functions for now
                var node = this.createElementNSPlus("ogc:UpperBoundary");
                this.writeNode("Literal", filter.upperBoundary, node);
                return node;
            },
            "INTERSECTS": function(filter) {
                return this.writeSpatial(filter, "Intersects");
            },
            "WITHIN": function(filter) {
                return this.writeSpatial(filter, "Within");
            },
            "CONTAINS": function(filter) {
                return this.writeSpatial(filter, "Contains");
            },
            "DWITHIN": function(filter) {
                var node = this.writeSpatial(filter, "DWithin");
                this.writeNode("Distance", filter, node);
                return node;
            },
            "Distance": function(filter) {
                return this.createElementNSPlus("ogc:Distance", {
                    attributes: {
                        units: filter.distanceUnits
                    },
                    value: filter.distance
                });
            },
            "Function": function(filter) {
                var node = this.createElementNSPlus("ogc:Function", {
                    attributes: {
                        name: filter.name
                    }
                });
                var params = filter.params;
                for(var i=0, len=params.length; i<len; i++){
                    this.writeOgcExpression(params[i], node);
                }
                return node;
            },
            "PropertyIsNull": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsNull");
                this.writeNode("PropertyName", filter, node);
                return node;
            },
			"SortBy": function(sortProperties) {
                var node = this.createElementNSPlus("ogc:SortBy");
                for (var i=0,l=sortProperties.length;i<l;i++) {
                    this.writeNode(
                        "ogc:SortProperty",
                        sortProperties[i],
                        node
                    );
                }
                return node;
            },
            "SortProperty": function(sortProperty) {
                var node = this.createElementNSPlus("ogc:SortProperty");
                this.writeNode(
                    "ogc:PropertyName",
                    sortProperty,
                    node
                );
                this.writeNode(
                    "ogc:SortOrder",
                    (sortProperty.order == 'DESC') ? 'DESC' : 'ASC',
                    node
                );
                return node;
            },
            "SortOrder": function(value) {
                var node = this.createElementNSPlus("ogc:SortOrder", {
                    value: value
                });
                return node;
            }
        }
    },

    /**
     *getFilterType
     * @memberof GeoGlobe.v1.prototype
     * @private
     */
    getFilterType: function(filter) {
        var filterType = this.filterMap[filter.type];
        if(!filterType) {
            throw "Filter writing not supported for rule type: " + filter.type;
        }
        return filterType;
    },
    
    /**
     *  Contains a member for each filter type.  Values are node names
     *     for corresponding OGC Filter child elements.
     * @memberof  GeoGlobe.Format.Filter.v1.prototype
     * @type {Object}
     * @private
     */
    filterMap: {
        "&&": "And",
        "||": "Or",
        "!": "Not",
        "==": "PropertyIsEqualTo",
        "!=": "PropertyIsNotEqualTo",
        "<": "PropertyIsLessThan",
        ">": "PropertyIsGreaterThan",
        "<=": "PropertyIsLessThanOrEqualTo",
        ">=": "PropertyIsGreaterThanOrEqualTo",
        "..": "PropertyIsBetween",
        "~": "PropertyIsLike",
        "NULL": "PropertyIsNull",
        "BBOX": "BBOX",
        "DWITHIN": "DWITHIN",
        "WITHIN": "WITHIN",
        "CONTAINS": "CONTAINS",
        "INTERSECTS": "INTERSECTS",
        "FID": "_featureIds"
    },

    CLASS_NAME: "GeoGlobe.Format.Filter.v1"

});

/** Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @memberof GeoGlobe.Format.Filter.v1_0_0.prototype
 * @requires  View2D/Format/GML/v2.js
 * @requires View2D/Format/Filter/v1.js
 */

/**
 * @class GeoGlobe.Format.Filter.v1_0_0
 * @classdesc Write ogc:Filter version 1.0.0.
 * 
 */
GeoGlobe.Format.Filter.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.GML.v2, GeoGlobe.Format.Filter.v1, {
    
    /**
     * Constant: VERSION
     * {String} 1.0.0
     * @private
     */
    VERSION: "1.0.0",
    
    /**
     * schemaLocation
     * {String} http://www.opengis.net/ogc/filter/1.0.0/filter.xsd
     * @memberof GeoGlobe.Format.Filter.v1_0_0.prototype
     * @type {String}
     * @private
     */
    schemaLocation: "http://www.opengis.net/ogc/filter/1.0.0/filter.xsd",

    /**

     * 这个类的实例不是直接创建的。 改为使用GeoGlobe.Format.Filter构造函数。
     *@memberof GeoGlobe.Format.Filter.v1_0_0.prototype
     *@param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        GeoGlobe.Format.GML.v2.prototype.initialize.apply(
            this, [options]
        );
    },

    /**
     * readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.Filter.v1_0_0.prototype
     * @private
     */
    readers: {
        "ogc": GeoGlobe.Util.applyDefaults({
            "PropertyIsEqualTo": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsNotEqualTo": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.NOT_EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLike": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LIKE
                });
                this.readChildNodes(node, filter);
                var wildCard = node.getAttribute("wildCard");
                var singleChar = node.getAttribute("singleChar");
                var esc = node.getAttribute("escape");
                filter.value2regex(wildCard, singleChar, esc);
                obj.filters.push(filter);
            }
        }, GeoGlobe.Format.Filter.v1.prototype.readers["ogc"]),
        "gml": GeoGlobe.Format.GML.v2.prototype.readers["gml"],
        "feature": GeoGlobe.Format.GML.v2.prototype.readers["feature"]        
    },

    /**
     * writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.Filter.v1_0_0.prototype
     * @private
     */
    writers: {
        "ogc": GeoGlobe.Util.applyDefaults({
            "PropertyIsEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsNotEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsNotEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsLike": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLike", {
                    attributes: {
                        wildCard: "*", singleChar: ".", escape: "!"
                    }
                });
                // no ogc:expression handling for now
                this.writeNode("PropertyName", filter, node);
                // convert regex string to ogc string
                this.writeNode("Literal", filter.regex2value(), node);
                return node;
            },
            "BBOX": function(filter) {
                var node = this.createElementNSPlus("ogc:BBOX");
                // PropertyName is mandatory in 1.0.0, but e.g. GeoServer also
                // accepts filters without it. When this is used with
                // GeoGlobe.Protocol.WFS, GeoGlobe.Format.WFST will set a
                // missing filter.property to the geometryName that is
                // configured with the protocol, which defaults to "the_geom".
                // So the only way to omit this mandatory property is to not
                // set the property on the filter and to set the geometryName
                // on the WFS protocol to null. The latter also happens when
                // the protocol is configured without a geometryName and a
                // featureNS.
                filter.property && this.writeNode("PropertyName", filter, node);
                var box = this.writeNode("gml:Box", filter.value, node);
                if(filter.projection) {
                    box.setAttribute("srsName", filter.projection);
                }
                return node;
            }
        }, GeoGlobe.Format.Filter.v1.prototype.writers["ogc"]),
        "gml": GeoGlobe.Format.GML.v2.prototype.writers["gml"],
        "feature": GeoGlobe.Format.GML.v2.prototype.writers["feature"]
    },

    /**

     *
     * Read a {GeoGlobe.Filter.Spatial} filter and converts it into XML.
     *@memberof GeoGlobe.Format.Filter.v1_0_0.prototype
     * @param {GeoGlobe.Filter.Spatial}filter - The filter.
     *@param  {String} name -Name of the generated XML element.
     *
     * @returns {DOMElement} The created XML element.
     * @private
     */
    writeSpatial: function(filter, name) {
        var node = this.createElementNSPlus("ogc:"+name);
        this.writeNode("PropertyName", filter, node);
        if(filter.value instanceof GeoGlobe.Filter.Function) {
            this.writeNode("Function", filter.value, node);
        } else {
        var child;
        if(filter.value instanceof GeoGlobe.Geometry) {
            child = this.writeNode("feature:_geometry", filter.value).firstChild;
        } else {
            child = this.writeNode("gml:Box", filter.value);
        }
        if(filter.projection) {
            child.setAttribute("srsName", filter.projection);
        }
        node.appendChild(child);
        }
        return node;
    },
    CLASS_NAME: "GeoGlobe.Format.Filter.v1_0_0"

});

/**
 * @class GeoGlobe.Format.Filter.v1_1_0
 *@classdesc  Write ogc:Filter version 1.1.0.
 *
 * Differences from the v1.0.0 parser:
 *  - uses GML v3 instead of GML v2
 *  - reads matchCase attribute on ogc:PropertyIsEqual and
 *        ogc:PropertyIsNotEqual elements.
 *  - writes matchCase attribute from comparison filters of type EQUAL_TO,
 *        NOT_EQUAL_TO and LIKE.
 * 
 * Inherits from: 
 *  - GeoGlobe.Format.GML.v3
 *  - GeoGlobe.Format.Filter.v1
 * @private
 */
GeoGlobe.Format.Filter.v1_1_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.GML.v3, GeoGlobe.Format.Filter.v1, {
    
    /**
     * Constant: VERSION
     * {String} 1.1.0
     * @private
     */
    VERSION: "1.1.0",
    
    /**
     * schemaLocation
     * {String} http://www.opengis.net/ogc/filter/1.1.0/filter.xsd
     * @memberof  GeoGlobe .v1_1_0.prototype
     * @type {String}
     * @private
     */
    schemaLocation: "http://www.opengis.net/ogc/filter/1.1.0/filter.xsd",

    /**

     * 这个类的实例不是直接创建的。改为使用GeoGlobe.Format.Filter构造函数。
     * @memberof GeoGlobe .v1_1_0.prototype
     * @param {Object} options -一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        GeoGlobe.Format.GML.v3.prototype.initialize.apply(
            this, [options]
        );
    },

    /**
     * readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe .v1_1_0.prototype
     * @private
     */
    readers: {
        "ogc": GeoGlobe.Util.applyDefaults({
            "PropertyIsEqualTo": function(node, obj) {
                var matchCase = node.getAttribute("matchCase");
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.EQUAL_TO,
                    matchCase: !(matchCase === "false" || matchCase === "0")
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsNotEqualTo": function(node, obj) {
                var matchCase = node.getAttribute("matchCase");
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.NOT_EQUAL_TO,
                    matchCase: !(matchCase === "false" || matchCase === "0")
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLike": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LIKE
                });
                this.readChildNodes(node, filter);
                var wildCard = node.getAttribute("wildCard");
                var singleChar = node.getAttribute("singleChar");
                var esc = node.getAttribute("escapeChar");
                filter.value2regex(wildCard, singleChar, esc);
                obj.filters.push(filter);
            }
        }, GeoGlobe.Format.Filter.v1.prototype.readers["ogc"]),
        "gml": GeoGlobe.Format.GML.v3.prototype.readers["gml"],
        "feature": GeoGlobe.Format.GML.v3.prototype.readers["feature"]        
    },

    /**
     * writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe .v1_1_0.prototype
     * @private
     */
    writers: {
        "ogc": GeoGlobe.Util.applyDefaults({
            "PropertyIsEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsEqualTo", {
                    attributes: {matchCase: filter.matchCase}
                });
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsNotEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsNotEqualTo", {
                    attributes: {matchCase: filter.matchCase}
                });
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsLike": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLike", {
                    attributes: {
                        matchCase: filter.matchCase,
                        wildCard: "*", singleChar: ".", escapeChar: "!"
                    }
                });
                // no ogc:expression handling for now
                this.writeNode("PropertyName", filter, node);
                // convert regex string to ogc string
                this.writeNode("Literal", filter.regex2value(), node);
                return node;
            },
            "BBOX": function(filter) {
                var node = this.createElementNSPlus("ogc:BBOX");
                // PropertyName is optional in 1.1.0
                filter.property && this.writeNode("PropertyName", filter, node);
                var box = this.writeNode("gml:Envelope", filter.value);
                if(filter.projection) {
                    box.setAttribute("srsName", filter.projection);
                }
                node.appendChild(box); 
                return node;
            },
            "SortBy": function(sortProperties) {
                var node = this.createElementNSPlus("ogc:SortBy");
                for (var i=0,l=sortProperties.length;i<l;i++) {
                    this.writeNode(
                        "ogc:SortProperty",
                        sortProperties[i],
                        node
                    );
                }
                return node;
            }, 
            "SortProperty": function(sortProperty) {
                var node = this.createElementNSPlus("ogc:SortProperty");
                this.writeNode(
                    "ogc:PropertyName",
                    sortProperty,
                    node
                );
                this.writeNode(
                    "ogc:SortOrder",
                    (sortProperty.order == 'DESC') ? 'DESC' : 'ASC',
                    node
                );
                return node;
            },
            "SortOrder": function(value) {
                var node = this.createElementNSPlus("ogc:SortOrder", {
                    value: value
                });
                return node;
            }
        }, GeoGlobe.Format.Filter.v1.prototype.writers["ogc"]),
        "gml": GeoGlobe.Format.GML.v3.prototype.writers["gml"],
        "feature": GeoGlobe.Format.GML.v3.prototype.writers["feature"]
    },

    /**

     * @memberof GeoGlobe .v1_1_0.prototype
     * Read a {GeoGlobe.Filter.Spatial} filter and converts it into XML.
     *

     *@param {GeoGlobe.Filter.Spatial} filter -  The filter.
     *@param {String} name -  Name of the generated XML element.
     *
     * @returns {DOMElement} The created XML element.
     * @private
     */
    writeSpatial: function(filter, name) {
        var node = this.createElementNSPlus("ogc:"+name);
        this.writeNode("PropertyName", filter, node);
        if(filter.value instanceof GeoGlobe.Filter.Function) {
            this.writeNode("Function", filter.value, node);
        } else {
        var child;
        if(filter.value instanceof GeoGlobe.Geometry) {
            child = this.writeNode("feature:_geometry", filter.value).firstChild;
        } else {
            child = this.writeNode("gml:Envelope", filter.value);
        }
        if(filter.projection) {
            child.setAttribute("srsName", filter.projection);
        }
        node.appendChild(child);
        }
        return node;
    },

    CLASS_NAME: "GeoGlobe.Format.Filter.v1_1_0"

});

/**
 * @class GeoGlobe.Format.WFST
 * @classdesc 
 * 带有事务操作的网络要素服务格式化类。
 * @returns {GeoGlobe.Format} 给定版本的带有事务操作的网络要素服务。
 */

GeoGlobe.Format.WFST = function(options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Format.WFST.DEFAULTS
    );
    var cls = GeoGlobe.Format.WFST["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported WFST version: " + options.version;
    }
    return new cls(options);
};

/**
 * 带有事务操作的网络要素服务格式的默认属性。
 * @memberof GeoGlobe.Format.WFST.DEFAULTS
 * @type {Object}
 */
GeoGlobe.Format.WFST.DEFAULTS = {
    "version": "1.0.0"
};

/**
 * @class GeoGlobe.Format.WFST.v1
 * @classdesc  
 * 带有事务处理类型的网络要素服务的格式化超类。
 */

GeoGlobe.Format.WFST.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs",
        gml: "http://www.opengis.net/gml",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows"
    },
    
    /**
     * defaultPrefix
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {null}
     * @private
     */
    defaultPrefix: "wfs",

    /**
     * 版本- 网络要素服务的版本号
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {String}
     */
    version: null,

    /**
     * schemaLocation- Schema location for a particular minor version.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {String}
     * @private
     */
    schemaLocations: null,
    
    /**
     * srsName- 空间参考系统的URI。
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {String}
     */
    srsName: null,

    /**
     * 从GML中提取属性。 默认值是true。
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {Boolean}
     */
    extractAttributes: true,
    
    /**
     * GML的xy-Order坐标为true：（x，y）或false：（y，x）
     * 不建议更改，应该实例化新格式。
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {Boolean}
     */ 
    xy: true,

    /**
     * stateName- Maps feature states to node names.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {Object}
     * @private
     */
    stateName: null,
    
    /**
     * 这个类的实例不是直接创建的。  
     * 改为使用GeoGlobe.Format.WFST.v1_0_0或GeoGlobe.Format.WFST.v1_1_0构造函数。
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        // set state name mapping
        this.stateName = {};
        this.stateName[GeoGlobe.State.INSERT] = "wfs:Insert";
        this.stateName[GeoGlobe.State.UPDATE] = "wfs:Update";
        this.stateName[GeoGlobe.State.DELETE] = "wfs:Delete";
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @private
     */
    getSrsName: function(feature, options) {
        var srsName = options && options.srsName;
        if(!srsName) {
            if(feature && feature.layer) {
                srsName = feature.layer.projection.getCode();
            } else {
                srsName = this.srsName;
            }
        }
        return srsName;
    },

    /**
     * 解析事务的响应。 
     * 由于WFS分为事务请求（创建，更新和删除）和GetFeature请求（读取），
     * 因此此方法处理这两种类型的响应的解析。
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @param {String | Document} data -带有事务操作类型的网络要素服务文档。
     * @param {Object} options -选项。
     *
     * 有效的选项属性：{字符串}输出 - “功能”或“对象”。 默认值是“功能”，
     * 这意味着该方法将返回一组功能。 如果设置为“object”，
     * 则将返回解析器读取的具有“features”属性和其他属性的对象。
     *
     * @returns {Array | Object} 输出取决于输出选项。
     */
    read: function(data, options) {
        options = options || {};
        GeoGlobe.Util.applyDefaults(options, {
            output: "features"
        });
        
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var obj = {};
        if(data) {
            this.readNode(data, obj, true);
        }
        if(obj.features && options.output === "features") {
            obj = obj.features;
        }
        return obj;
    },
    
    /**
     *  Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wfs": {
            "FeatureCollection": function(node, obj) {
                obj.features = [];
                this.readChildNodes(node, obj);
            }
        }
    },
    
    /**
     * Given an array of features, write a WFS transaction.  This assumes
     *     the features have a state property that determines the operation
     *     type - insert, update, or delete.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @param {Array(GeoGlobe.Feature)} features -A list of features. See
     *     below for a more detailed description of the influence of the
     *     feature's *modified* property.
     * options - {Object}
     *
     * feature.modified rules:
     * If a feature has a modified property set, the following checks will be
     * made before a feature's geometry or attribute is included in an Update
     * transaction:
     * - *modified* is not set at all: The geometry and all attributes will be
     *     included.
     * - *modified.geometry* is set (null or a geometry): The geometry will be
     *     included. If *modified.attributes* is not set, all attributes will
     *     be included.
     * - *modified.attributes* is set: Only the attributes set (i.e. to null or
     *     a value) in *modified.attributes* will be included. 
     *     If *modified.geometry* is not set, the geometry will not be included.
     *
     * Valid options include:
     * - *multi* {Boolean} If set to true, geometries will be casted to
     *   Multi geometries before writing.
     *
     * @returns {String} A serialized WFS transaction.
     * @private
     */
    write: function(features, options) {
        var node = this.writeNode("wfs:Transaction", {
            features:features,
            options: options
        });
        var value = this.schemaLocationAttr();
        if(value) {
            this.setAttributeNS(
                node, this.namespaces["xsi"], "xsi:schemaLocation",  value
            );
        }
        return GeoGlobe.Format.XML.prototype.write.apply(this, [node]);
    },
    
    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {null}
     * @private
     */
    writers: {
        "wfs": {
            "GetFeature": function(options) {
				/*
                var node = this.createElementNSPlus("wfs:GetFeature", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: options && options.handle,
                        outputFormat: options && options.outputFormat,
                        maxFeatures: options && options.maxFeatures,
                        "xsi:schemaLocation": this.schemaLocationAttr(options)
                    }
                });
                */
				var node = this.createElementNSPlus("wfs:GetFeature", {
			        attributes: {
			            service: "WFS",
			            version: this.version,
						//handle: options && options.handle,
			            outputFormat: options && options.outputFormat,
			            maxFeatures: options && options.maxFeatures,
			            resultType: options && options.resultType,//增加resultType属性
			            startPosition: options && options.startPosition,//增加startPosition属性
			            "xsi:schemaLocation": this.schemaLocationAttr(options)
			        }
			    });
                if (typeof this.featureType == "string") {
                    this.writeNode("Query", options, node);
                } else {
                    for (var i=0,len = this.featureType.length; i<len; i++) { 
                        options.featureType = this.featureType[i]; 
                        this.writeNode("Query", options, node); 
                    } 
                }
			    return node;
            },
            "Transaction": function(obj) {
                obj = obj || {};
                var options = obj.options || {};
                var node = this.createElementNSPlus("wfs:Transaction", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: options.handle
                    }
                });
                var i, len;
                var features = obj.features;
                if(features) {
                    // temporarily re-assigning geometry types
                    if (options.multi === true) {
                        GeoGlobe.Util.extend(this.geometryTypes, {
                            "GeoGlobe.Geometry.Point": "MultiPoint",
                            "GeoGlobe.Geometry.LineString": (this.multiCurve === true) ? "MultiCurve": "MultiLineString",
                            "GeoGlobe.Geometry.Polygon": (this.multiSurface === true) ? "MultiSurface" : "MultiPolygon"
                        });
                    }
                    var name, feature;
                    for(i=0, len=features.length; i<len; ++i) {
                        feature = features[i];
                        name = this.stateName[feature.state];
                        if(name) {
                            this.writeNode(name, {
                                feature: feature, 
                                options: options
                            }, node);
                        }
                    }
                    // switch back to original geometry types assignment
                    if (options.multi === true) {
                        this.setGeometryTypes();
                    }
                }
                if (options.nativeElements) {
                    for (i=0, len=options.nativeElements.length; i<len; ++i) {
                        this.writeNode("wfs:Native", 
                            options.nativeElements[i], node);
                    }
                }
                return node;
            },
            "Native": function(nativeElement) {
                var node = this.createElementNSPlus("wfs:Native", {
                    attributes: {
                        vendorId: nativeElement.vendorId,
                        safeToIgnore: nativeElement.safeToIgnore
                    },
                    value: nativeElement.value
                });
                return node;
            },
            "Insert": function(obj) {
                var feature = obj.feature;
                var options = obj.options;
                var node = this.createElementNSPlus("wfs:Insert", {
                    attributes: {
                        handle: options && options.handle
                    }
                });
                this.srsName = this.getSrsName(feature);
                this.writeNode("feature:_typeName", feature, node);
                return node;
            },
            "Update": function(obj) {
                var feature = obj.feature;
                var options = obj.options;
                var node = this.createElementNSPlus("wfs:Update", {
                    attributes: {
                        handle: options && options.handle,
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") +
                            this.featureType
                    }
                });
                if(this.featureNS) {
                    node.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
                }
                
                // add in geometry
                var modified = feature.modified;
                if (this.geometryName !== null && (!modified || modified.geometry !== undefined)) {
                    this.srsName = this.getSrsName(feature);
                    this.writeNode(
                        "Property", {name: this.geometryName, value: feature.geometry}, node
                    );
                }
        
                // add in attributes
                for(var key in feature.attributes) {
                    if(feature.attributes[key] !== undefined &&
                                (!modified || !modified.attributes ||
                                (modified.attributes && modified.attributes[key] !== undefined))) {
                        this.writeNode(
                            "Property", {name: key, value: feature.attributes[key]}, node
                        );
                    }
                }
                
                // add feature id filter
                this.writeNode("ogc:Filter", new GeoGlobe.Filter.FeatureId({
                    fids: [feature.fid]
                }), node);
        
                return node;
            },
            "Property": function(obj) {
                var node = this.createElementNSPlus("wfs:Property");
                this.writeNode("Name", obj.name, node);
                if(obj.value !== null) {
                    this.writeNode("Value", obj.value, node);
                }
                return node;
            },
            "Name": function(name) {
                return this.createElementNSPlus("wfs:Name", {value: name});
            },
            "Value": function(obj) {
                var node;
                if(obj instanceof GeoGlobe.Geometry) {
                    node = this.createElementNSPlus("wfs:Value");
                    var geom = this.writeNode("feature:_geometry", obj).firstChild;
                    node.appendChild(geom);
                } else {
                    node = this.createElementNSPlus("wfs:Value", {value: obj});                
                }
                return node;
            },
            "Delete": function(obj) {
                var feature = obj.feature;
                var options = obj.options;
                var node = this.createElementNSPlus("wfs:Delete", {
                    attributes: {
                        handle: options && options.handle,
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") +
                            this.featureType
                    }
                });
                if(this.featureNS) {
                    node.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
                }
                this.writeNode("ogc:Filter", new GeoGlobe.Filter.FeatureId({
                    fids: [feature.fid]
                }), node);
                return node;
            }
        }
    },

    /**
     * Generate the xsi:schemaLocation attribute value.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @returns {String} The xsi:schemaLocation attribute or undefined if none.
     * @private
     */
    schemaLocationAttr: function(options) {
        options = GeoGlobe.Util.extend({
            featurePrefix: this.featurePrefix,
            schema: this.schema
        }, options);
        var schemaLocations = GeoGlobe.Util.extend({}, this.schemaLocations);
        if(options.schema) {
            schemaLocations[options.featurePrefix] = options.schema;
        }
        var parts = [];
        var uri;
        for(var key in schemaLocations) {
            uri = this.namespaces[key];
            if(uri) {
                parts.push(uri + " " + schemaLocations[key]);
            }
        }
        var value = parts.join(" ") || undefined;
        return value;
    },
    
    /**
     * Set the property of each spatial filter.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @param {GeoGlobe.Filter}filter
     * @private
     */
    setFilterProperty: function(filter) {
        if(filter.filters) {
            for(var i=0, len=filter.filters.length; i<len; ++i) {
                GeoGlobe.Format.WFST.v1.prototype.setFilterProperty.call(this, filter.filters[i]);
            }
        } else {
            if(filter instanceof GeoGlobe.Filter.Spatial && !filter.property) {
                // got a spatial filter without property, so set it
                filter.property = this.geometryName;
            }
        }
    },

    CLASS_NAME: "GeoGlobe.Format.WFST.v1" 

});

/**
 * @class  GeoGlobe.Format.WFST.v1_0_0
 * @classdesc  创建WFS v1.0.0事务的格式。 使用GeoGlobe.Format.WFST.v1_0_0构造函数创建一个新实例。
 * WFST的格式化类。1.0.0版本。
 * @returns {Object} 输入对象已修改（如果没有提供，则为新的输入对象）。
 * @private
 */


GeoGlobe.Format.WFST.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.Filter.v1_0_0, GeoGlobe.Format.WFST.v1, {
    
    /**
     * version-WFS version number.
     * @memberof GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {String}
     * @private
     */
    version: "1.0.0",

    /**
     * srsNameInQuery- 如果参数系统在查询请求中通过“srsName”属性传递给“wfs：Query”元素，
     * 则该属性默认为false，因为它不符合WFS 1.0.0。
     * @memberof  GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {Boolean}
     */
    srsNameInQuery: false,
    
    /**
     *  Properties are namespace aliases, values are schema locations.
     * @memberof GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    schemaLocations: {
        "wfs": "http://schemas.opengis.net/wfs/1.0.0/WFS-transaction.xsd"
    },


    initialize: function(options) {
        GeoGlobe.Format.Filter.v1_0_0.prototype.initialize.apply(this, [options]);
        GeoGlobe.Format.WFST.v1.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     * @memberof GeoGlobe.Format.WFST.v1_0_0.prototype
     * @param {DOMElement} node - The node to be read (required).
     * @param {Object}obj - The object to be modified (optional).
     * @param {Boolean} first -  Should be set to true for the first node read.
     *    This  is usually the readNode call in the read method. Without this being
     *     set, auto-configured properties will stick on subsequent reads.
     * @private

     */
    readNode: function(node, obj, first) {
        // Not the superclass, only the mixin classes inherit from
        // Format.GML.v2. We need this because we don't want to get readNode
        // from the superclass's superclass, which is GeoGlobe.Format.XML.
        return GeoGlobe.Format.GML.v2.prototype.readNode.apply(this, arguments);
    },
    
    /**
     *  Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {null}
     * @private
     */
    readers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "WFS_TransactionResponse": function(node, obj) {
                obj.insertIds = [];
                obj.success = false;
                this.readChildNodes(node, obj);
            },
            "InsertResult": function(node, container) {
                var obj = {fids: []};
                this.readChildNodes(node, obj);
                container.insertIds = container.insertIds.concat(obj.fids);
            },
            "TransactionResult": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Status": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "SUCCESS": function(node, obj) {
                obj.success = true;
            }
        }, GeoGlobe.Format.WFST.v1.prototype.readers["wfs"]),
        "gml": GeoGlobe.Format.GML.v2.prototype.readers["gml"],
        "feature": GeoGlobe.Format.GML.v2.prototype.readers["feature"],
        "ogc": GeoGlobe.Format.Filter.v1_0_0.prototype.readers["ogc"]
    },

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {null}
     * @private
     *
     */
    writers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "Query": function(options) {
                options = GeoGlobe.Util.extend({
                    featureNS: this.featureNS,
                    featurePrefix: this.featurePrefix,
                    featureType: this.featureType,
                    srsName: this.srsName,
                    srsNameInQuery: this.srsNameInQuery
                }, options);
                var prefix = options.featurePrefix;
                var node = this.createElementNSPlus("wfs:Query", {
                    attributes: {
                        typeName: (options.featureNS ? prefix + ":" : "") +
                            options.featureType,
						time: options && options.time, //可选的。版本时间，此参数只针对多时态矢量数据集。默认为查询最新版本时间
						userecent: options && options.userecent //可选的。是否追溯(取值范围：true或false，true为返回最近匹配，false则精确匹配，默认值为true)
                    }
                });
                if(options.srsNameInQuery && options.srsName) {
                    node.setAttribute("srsName", options.srsName);
                }
                if(options.featureNS) {
                    node.setAttribute("xmlns:" + prefix, options.featureNS);
                }
                if(options.propertyNames) {
                    for(var i=0,len = options.propertyNames.length; i<len; i++) {
                        this.writeNode(
                            "ogc:PropertyName", 
                            {property: options.propertyNames[i]},
                            node
                        );
                    }
                }
                if(options.filter) {
                    this.setFilterProperty(options.filter);
                    this.writeNode("ogc:Filter", options.filter, node);
                }
				if (options.sortBy) {
                    this.writeNode("ogc:SortBy", options.sortBy, node);
                }
				if (options.groupBy) {
	                this.writeNode("ogc:GroupBy", options.groupBy, node);
	            }
                return node;
            }
        }, GeoGlobe.Format.WFST.v1.prototype.writers["wfs"]),
        "gml": GeoGlobe.Format.GML.v2.prototype.writers["gml"],
        "feature": GeoGlobe.Format.GML.v2.prototype.writers["feature"],
        "ogc": GeoGlobe.Format.Filter.v1_0_0.prototype.writers["ogc"]
    },
   
    CLASS_NAME: "GeoGlobe.Format.WFST.v1_0_0" 
});

/**
 * @class  GeoGlobe.Format.WFST.v1_0_0
 * @classdesc  A format for creating WFS v1.0.0 transactions.  Create a new instance with the
 *     GeoGlobe.Format.WFST.v1_0_0 constructor.
 * WFST的格式化类。1.0.0版本。
 * @private
 */

GeoGlobe.Format.WFST.v1_1_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.Filter.v1_1_0, GeoGlobe.Format.WFST.v1, {
    
    /**
     * version- WFS version number.
     * @memberof  GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {String}
     * @private
     */
    version: "1.1.0",
    
    /**
     * schemaLocations- Properties are namespace aliases, values are schema locations.
     * @memberof  GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    schemaLocations: {
        "wfs": "http://schemas.opengis.net/wfs/1.1.0/wfs.xsd"
    },
    
    /**
     * 要从FeatureCollection中读取其他信息（如hit count（numberOfFeatures）），
     * 请使用{output：“object”}作为第二个参数调用GeoGlobe.Format.WFST.v1.read方法。 
     * 请注意，可以使用resultType =“hits”请求参数向WFS 1.1.0服务器请求命中计数。
     * @memberof  GeoGlobe.Format.WFST.v1_0_0.prototype
     * 一个解析和生成WFS v1.1.0事务的类。
     * @param {Object} options -Optional 对象的属性将在实例上设置。
     *
     * 有效的选项属性：
     * @param {String} featureType -  本地（无前缀）功能typeName（必需）。
     * @param {String} featureNS -  功能名称空间（可选）。
     * @param {String} featurePrefix - 功能名称空间别名（可选 - 仅用于如果提供featureNS）。 默认是'feature'。
     * @param {String} geometryName -  几何属性的名称。 默认是'the_geom'。
     */
    initialize: function(options) {
        GeoGlobe.Format.Filter.v1_1_0.prototype.initialize.apply(this, [options]);
        GeoGlobe.Format.WFST.v1.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     *@memberof  GeoGlobe.Format.WFST.v1_0_0.prototype
     *@param {DOMElement} node - The node to be read (required).
     *@param  {Object}obj - The object to be modified (optional).
     *@param {Boolean}first -  Should be set to true for the first node read. This
     *     is usually the readNode call in the read method. Without this being
     *     set, auto-configured properties will stick on subsequent reads.
     *@returns {Object} The input object, modified (or a new one if none was provided).
     *@private
     */
    readNode: function(node, obj, first) {
        // Not the superclass, only the mixin classes inherit from
        // Format.GML.v3. We need this because we don't want to get readNode
        // from the superclass's superclass, which is GeoGlobe.Format.XML.
        return GeoGlobe.Format.GML.v3.prototype.readNode.apply(this, arguments);
    },
    
    /**
     *  Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {null}
     * @private
     */
    readers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "FeatureCollection": function(node, obj) {
                obj.numberOfFeatures = parseInt(node.getAttribute(
                    "numberOfFeatures"));
                GeoGlobe.Format.WFST.v1.prototype.readers["wfs"]["FeatureCollection"].apply(
                    this, arguments);
            },
            "TransactionResponse": function(node, obj) {
                obj.insertIds = [];
                obj.success = false;
                this.readChildNodes(node, obj);
            },
            "TransactionSummary": function(node, obj) {
                // this is a limited test of success
                obj.success = true;
            },
            "InsertResults": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Feature": function(node, container) {
                var obj = {fids: []};
                this.readChildNodes(node, obj);
                container.insertIds.push(obj.fids[0]);
            }
        }, GeoGlobe.Format.WFST.v1.prototype.readers["wfs"]),
        "gml": GeoGlobe.Format.GML.v3.prototype.readers["gml"],
        "feature": GeoGlobe.Format.GML.v3.prototype.readers["feature"],
        "ogc": GeoGlobe.Format.Filter.v1_1_0.prototype.readers["ogc"],
        "ows": GeoGlobe.Format.OWSCommon.v1_0_0.prototype.readers["ows"]
    },

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {null}
     * @private
     */
    writers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "GetFeature": function(options) {
                var node = GeoGlobe.Format.WFST.v1.prototype.writers["wfs"]["GetFeature"].apply(this, arguments);
                options && this.setAttributes(node, {
                    resultType: options.resultType,
                    startIndex: options.startIndex,
                    count: options.count
                });
                return node;
            },
            "Query": function(options) {
                options = GeoGlobe.Util.extend({
                    featureNS: this.featureNS,
                    featurePrefix: this.featurePrefix,
                    featureType: this.featureType,
                    srsName: this.srsName
                }, options);
                var prefix = options.featurePrefix;
                var node = this.createElementNSPlus("wfs:Query", {
                    attributes: {
                        typeName: (options.featureNS ? prefix + ":" : "") +
                            options.featureType,
                        srsName: options.srsName,
						time: options && options.time, //可选的。版本时间，此参数只针对多时态矢量数据集。默认为查询最新版本时间
						userecent: options && options.userecent //可选的。是否追溯(取值范围：true或false，true为返回最近匹配，false则精确匹配，默认值为true)
                    }
                });
                if(options.featureNS) {
                    node.setAttribute("xmlns:" + prefix, options.featureNS);
                }
                if(options.propertyNames) {
                    for(var i=0,len = options.propertyNames.length; i<len; i++) {
                        this.writeNode(
                            "wfs:PropertyName", 
                            {property: options.propertyNames[i]},
                            node
                        );
                    }
                }
                if(options.filter) {
                    GeoGlobe.Format.WFST.v1_1_0.prototype.setFilterProperty.call(this, options.filter);
                    this.writeNode("ogc:Filter", options.filter, node);
                }
				if (options.sortBy) {
	                this.writeNode("ogc:SortBy", options.sortBy, node);
	            }
				if (options.groupBy) {
	                this.writeNode("ogc:GroupBy", options.groupBy, node);
	            }
                return node;
            },
            "PropertyName": function(obj) {
                return this.createElementNSPlus("wfs:PropertyName", {
                    value: obj.property
                });
            }            
        }, GeoGlobe.Format.WFST.v1.prototype.writers["wfs"]),
        "gml": GeoGlobe.Format.GML.v3.prototype.writers["gml"],
        "feature": GeoGlobe.Format.GML.v3.prototype.writers["feature"],
        "ogc": GeoGlobe.Format.Filter.v1_1_0.prototype.writers["ogc"]
    },

    CLASS_NAME: "GeoGlobe.Format.WFST.v1_1_0" 
});

/**
 * @class GeoGlobe.Format.JSON
 * @classdesc   JSON格式化类。解析器安全地读取/写入JSON。 使用GeoGlobe.Format.JSON构造函数创建一个新实例。
 * @returns   {Object} 一个对象，数组，字符串或数字。
 */

GeoGlobe.Format.JSON = GeoGlobe.Class4OL(GeoGlobe.Format, {
    
    /**
     * indent-对于“pretty”打印，缩进字符串将在每个缩进级别使用一次。
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @type {String}
     */
    indent: "    ",
    
    /**
     *  space- 对于“pretty”打印，空格字符串将在“：”分隔名称/值对之后使用。
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @type {String}
     */
    space: " ",
    
    /**
     * newline- 对于“pretty”打印，换行符字符串将用于每个名称/值对或数组项目的末尾。
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @type {String}
     */
    newline: "\n",
    
    /**
     * level- For "pretty" printing, this is incremented/decremented during
     *     serialization.
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @type {int}
     * @private
     */
    level: 0,

    /**
     * pretty-Serialize with extra whitespace for structure.  This is set
     *     by the write method.
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @type {Boolean}
     * @private
     */
    pretty: false,

    /**
     * nativeJSON- Does the browser support native json?
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @type {Boolean}
     * @private
     */
    nativeJSON: (function() {
        return !!(window.JSON && typeof JSON.parse == "function" && typeof JSON.stringify == "function");
    })(),

    /**
     * 为JSON创建一个新的解析器。
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */

    /**
     * 解析json字符串。
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @param {String} json -一个JSON字符串
     * @param  {Function}filter - 将在最终结果的每个级别调用每个键和值的函数。 
     * 每个值将被过滤器功能的结果替换。
     * 这可用于将通用对象改为类的实例，
     * 或将日期字符串转换为Date对象。
     */
    read: function(json, filter) {
        var object;
        if (this.nativeJSON) {
            object = JSON.parse(json, filter);
        } else try {
            /**
             * Parsing happens in three stages. In the first stage, we run the
             *     text against a regular expression which looks for non-JSON
             *     characters. We are especially concerned with '()' and 'new'
             *     because they can cause invocation, and '=' because it can
             *     cause mutation. But just to be safe, we will reject all
             *     unexpected characters.
             */
            if (/^[\],:{}\s]*$/.test(json.replace(/\\["\\\/bfnrtu]/g, '@').
                                replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
                                replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

                /**
                 * In the second stage we use the eval function to compile the
                 *     text into a JavaScript structure. The '{' operator is
                 *     subject to a syntactic ambiguity in JavaScript - it can
                 *     begin a block or an object literal. We wrap the text in
                 *     parens to eliminate the ambiguity.
                 */
                object = eval('(' + json + ')');

                /**
                 * In the optional third stage, we recursively walk the new
                 *     structure, passing each name/value pair to a filter
                 *     function for possible transformation.
                 */
                if(typeof filter === 'function') {
                    function walk(k, v) {
                        if(v && typeof v === 'object') {
                            for(var i in v) {
                                if(v.hasOwnProperty(i)) {
                                    v[i] = walk(i, v[i]);
                                }
                            }
                        }
                        return filter(k, v);
                    }
                    object = walk('', object);
                }
            }
        } catch(e) {
            // Fall through if the regexp test fails.
        }

        if(this.keepData) {
            this.data = object;
        }

        return object;
    },

    /**
     *  将对象序列化为JSON字符串。
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @param {String} value - 要序列化的对象，数组，字符串，数字，布尔值或日期。
     * @param {Boolean} pretty -  使用换行符和缩进结构化输出。默认为false。
     * @returns {String} 输入值的JSON字符串表示形式。
     */
    write: function(value, pretty) {
        this.pretty = !!pretty;
        var json = null;
        var type = typeof value;
        if(this.serialize[type]) {
            try {
                json = (!this.pretty && this.nativeJSON) ?
                    JSON.stringify(value) :
                    this.serialize[type].apply(this, [value]);
            } catch(err) {
                GeoGlobe.Console.error("Trouble serializing: " + err);
            }
        }
        return json;
    },
    
    /**
     * Output an indentation string depending on the indentation level.
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @returns {String} An appropriate indentation string.
     * @private
     */
    writeIndent: function() {
        var pieces = [];
        if(this.pretty) {
            for(var i=0; i<this.level; ++i) {
                pieces.push(this.indent);
            }
        }
        return pieces.join('');
    },
    
    /**
     * Output a string representing a newline if in pretty printing mode.
     * @memberof GeoGlobe.Format.JSON.prototype
     * @returns {String} A string representing a new line.
     * @private
     */
    writeNewline: function() {
        return (this.pretty) ? this.newline : '';
    },
    
    /**
     * Output a string representing a space if in pretty printing mode.
     * @memberof GeoGlobe.Format.JSON.prototype
     * @returns {String} A space.
     * @private
     */
    writeSpace: function() {
        return (this.pretty) ? this.space : '';
    },

    /**
     * \Object with properties corresponding to the serializable data types.
     *     Property values are functions that do the actual serializing.
     * @memberof GeoGlobe.Format.JSON.prototype
     * @type {null}
     * @private
     *
     */
    serialize: {
        /**
         * Transform an object into a JSON string.
         * @memberof  GeoGlobe.Format.JSON.prototype
         * @param {Object}object - The object to be serialized.
         * @returns {String} A JSON string representing the object.
         * @private
         */
        'object': function(object) {
            // three special objects that we want to treat differently
            if(object == null) {
                return "null";
            }
            if(object.constructor == Date) {
                return this.serialize.date.apply(this, [object]);
            }
            if(object.constructor == Array) {
                return this.serialize.array.apply(this, [object]);
            }
            var pieces = ['{'];
            this.level += 1;
            var key, keyJSON, valueJSON;
            
            var addComma = false;
            for(key in object) {
                if(object.hasOwnProperty(key)) {
                    // recursive calls need to allow for sub-classing
                    keyJSON = GeoGlobe.Format.JSON.prototype.write.apply(this,
                                                    [key, this.pretty]);
                    valueJSON = GeoGlobe.Format.JSON.prototype.write.apply(this,
                                                    [object[key], this.pretty]);
                    if(keyJSON != null && valueJSON != null) {
                        if(addComma) {
                            pieces.push(',');
                        }
                        pieces.push(this.writeNewline(), this.writeIndent(),
                                    keyJSON, ':', this.writeSpace(), valueJSON);
                        addComma = true;
                    }
                }
            }
            
            this.level -= 1;
            pieces.push(this.writeNewline(), this.writeIndent(), '}');
            return pieces.join('');
        },
        
        /**
         * Transform an array into a JSON string.
         * @memberof  GeoGlobe.Format.JSON.prototype
         * @param {Array}array -  The array to be serialized
         * @returns {String} A JSON string representing the array.
         * @private
         */
        'array': function(array) {
            var json;
            var pieces = ['['];
            this.level += 1;
    
            for(var i=0, len=array.length; i<len; ++i) {
                // recursive calls need to allow for sub-classing
                json = GeoGlobe.Format.JSON.prototype.write.apply(this,
                                                    [array[i], this.pretty]);
                if(json != null) {
                    if(i > 0) {
                        pieces.push(',');
                    }
                    pieces.push(this.writeNewline(), this.writeIndent(), json);
                }
            }

            this.level -= 1;    
            pieces.push(this.writeNewline(), this.writeIndent(), ']');
            return pieces.join('');
        },
        
        /**
         *  Transform a string into a JSON string.
         * @memberof  GeoGlobe.Format.JSON.prototype
         * @param {String}string - The string to be serialized
         * @returns {String} A JSON string representing the string.
         * @private
         */
        'string': function(string) {
            // If the string contains no control characters, no quote characters, and no
            // backslash characters, then we can simply slap some quotes around it.
            // Otherwise we must also replace the offending characters with safe
            // sequences.    
            var m = {
                '\b': '\\b',
                '\t': '\\t',
                '\n': '\\n',
                '\f': '\\f',
                '\r': '\\r',
                '"' : '\\"',
                '\\': '\\\\'
            };
            if(/["\\\x00-\x1f]/.test(string)) {
                return '"' + string.replace(/([\x00-\x1f\\"])/g, function(a, b) {
                    var c = m[b];
                    if(c) {
                        return c;
                    }
                    c = b.charCodeAt();
                    return '\\u00' +
                        Math.floor(c / 16).toString(16) +
                        (c % 16).toString(16);
                }) + '"';
            }
            return '"' + string + '"';
        },

        /**
         *  Transform a number into a JSON string.
         * @memberof  GeoGlobe.Format.JSON.prototype
         * @param {Number} number -The number to be serialized.
         * @returns {String} A JSON string representing the number.
         * @private
         */
        'number': function(number) {
            return isFinite(number) ? String(number) : "null";
        },
        
        /**
         * Transform a boolean into a JSON string.
         * @memberof  GeoGlobe.Format.JSON.prototype
         * @param {Boolean}bool -  The boolean to be serialized.
         * @returns {String} A JSON string representing the boolean.
         * @private
         */
        'boolean': function(bool) {
            return String(bool);
        },
        
        /**
         * Transform a date into a JSON string.
         * @memberof  GeoGlobe.Format.JSON.prototype
         * @param {Date} date -The date to be serialized.
         * @returns {String} A JSON string representing the date.
         * @private
         */
        'date': function(date) {    
            function format(number) {
                // Format integers to have at least two digits.
                return (number < 10) ? '0' + number : number;
            }
            return '"' + date.getFullYear() + '-' +
                    format(date.getMonth() + 1) + '-' +
                    format(date.getDate()) + 'T' +
                    format(date.getHours()) + ':' +
                    format(date.getMinutes()) + ':' +
                    format(date.getSeconds()) + '"';
        }
    },

    CLASS_NAME: "GeoGlobe.Format.JSON" 

});     

/**
 * @class GeoGlobe.Format.GeoJSON
 * @classdesc  读写GeoJSON。创建一个新的解析器JSON格式化类。
 * 
 */


GeoGlobe.Format.GeoJSON = GeoGlobe.Class4OL(GeoGlobe.Format.JSON, {

    /**
     * ignoreExtraDims- 读取几何时忽略高于2的尺寸。
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @type {Boolean}
     */ 
    ignoreExtraDims: false,
    
    /**
     * 为GeoJSON创建一个新的解析器。
     * @param {Object} options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     *  反序列化GeoJSON字符串。
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @param {String}json -  一个GeoJSON字符串
     * @param {String}type -  用于确定输出结构的可选字符串。 支持的值是“Geometry”，
     * “feature”和“FeatureCollection”。 
     * 如果缺失或为空，则假定缺省为“FeatureCollection”。
     * @param {Function} filter - 将在最终结果的每个级别调用每个键和值的函数。 
     * 每个值将被过滤器功能的结果替换。 
     * 这可用于将通用对象改为类的实例，
     * 或将日期字符串转换为Date对象。
     * @returns {Object} 返回值取决于类型参数的值。 
     * 如果type是“FeatureCollection”（默认），则返回将是一个GeoGlobe.Feature数组。 
     * 如果type是“Geometry”，则输入json必须表示单个几何体，并且返回将是GeoGlobe.Geometry。 
     * 如果type是“Feature”，则输入json必须表示一个特征，返回值将是GeoGlobe.Feature。
     */
    read: function(json, type, filter) {
        type = (type) ? type : "FeatureCollection";
        var results = null;
        var obj = null;
        if (typeof json == "string") {
            obj = GeoGlobe.Format.JSON.prototype.read.apply(this,
                                                              [json, filter]);
        } else { 
            obj = json;
        }    
        if(!obj) {
            GeoGlobe.Console.error("Bad JSON: " + json);
        } else if(typeof(obj.type) != "string") {
            GeoGlobe.Console.error("Bad GeoJSON - no type: " + json);
        } else if(this.isValidType(obj, type)) {
            switch(type) {
                case "Geometry":
                    try {
                        results = this.parseGeometry(obj);
                    } catch(err) {
                        GeoGlobe.Console.error(err);
                    }
                    break;
                case "Feature":
                    try {
                        results = this.parseFeature(obj);
                        results.type = "Feature";
                    } catch(err) {
                        GeoGlobe.Console.error(err);
                    }
                    break;
                case "FeatureCollection":
                    // for type FeatureCollection, we allow input to be any type
                    results = [];
                    switch(obj.type) {
                        case "Feature":
                            try {
                                results.push(this.parseFeature(obj));
                            } catch(err) {
                                results = null;
                                GeoGlobe.Console.error(err);
                            }
                            break;
                        case "FeatureCollection":
                            for(var i=0, len=obj.features.length; i<len; ++i) {
                                try {
                                    results.push(this.parseFeature(obj.features[i]));
                                } catch(err) {
                                    results = null;
                                    GeoGlobe.Console.error(err);
                                }
                            }
                            break;
                        default:
                            try {
                                var geom = this.parseGeometry(obj);
                                results.push(new GeoGlobe.Feature(geom));
                            } catch(err) {
                                results = null;
                                GeoGlobe.Console.error(err);
                            }
                    }
                break;
            }
        }
        return results;
    },
    
    /**
     * Check if a GeoJSON object is a valid representative of the given type.
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @returns {Boolean} The object is valid GeoJSON object of the given type.
     * @private
     */
    isValidType: function(obj, type) {
        var valid = false;
        switch(type) {
            case "Geometry":
                if(GeoGlobe.Util.indexOf(
                    ["Point", "MultiPoint", "LineString", "MultiLineString",
                     "Polygon", "MultiPolygon", "Box", "GeometryCollection"],
                    obj.type) == -1) {
                    // unsupported geometry type
                    GeoGlobe.Console.error("Unsupported geometry type: " +
                                              obj.type);
                } else {
                    valid = true;
                }
                break;
            case "FeatureCollection":
                // allow for any type to be converted to a feature collection
                valid = true;
                break;
            default:
                // for Feature types must match
                if(obj.type == type) {
                    valid = true;
                } else {
                    GeoGlobe.Console.error("Cannot convert types from " +
                                              obj.type + " to " + type);
                }
        }
        return valid;
    },
    
    /**
     * Convert a feature object from GeoJSON into an
     *     GeoGlobe.Feature.
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @param {Object}obj - An object created from a GeoJSON object
     * @returns {GeoGlobe.Feature} A feature.
     * @private
     */
    parseFeature: function(obj) {
        var feature, geometry, attributes, bbox;
        attributes = (obj.properties) ? obj.properties : {};
        bbox = (obj.geometry && obj.geometry.bbox) || obj.bbox;
        try {
            geometry = this.parseGeometry(obj.geometry);
        } catch(err) {
            // deal with bad geometries
            throw err;
        }
        feature = new GeoGlobe.Feature(geometry, attributes);
        if(bbox) {
            feature.bounds = GeoGlobe.LngLatBounds.fromArray(bbox);
        }
        if(obj.id) {
            feature.fid = obj.id;
        }
        return feature;
    },
    
    /**
     * Convert a geometry object from GeoJSON into an GeoGlobe.Geometry.
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @param {Object}obj - An object created from a GeoJSON object
     * @returns {GeoGlobe.Geometry} A geometry.
     * @private
     */
    parseGeometry: function(obj) {
        if (obj == null) {
            return null;
        }
        var geometry, collection = false;
        if(obj.type == "GeometryCollection") {
            if(!(GeoGlobe.Util.isArray(obj.geometries))) {
                throw "GeometryCollection must have geometries array: " + obj;
            }
            var numGeom = obj.geometries.length;
            var components = new Array(numGeom);
            for(var i=0; i<numGeom; ++i) {
                components[i] = this.parseGeometry.apply(
                    this, [obj.geometries[i]]
                );
            }
            geometry = new GeoGlobe.Geometry.Collection(components);
            collection = true;
        } else {
            if(!(GeoGlobe.Util.isArray(obj.coordinates))) {
                throw "Geometry must have coordinates array: " + obj;
            }
            if(!this.parseCoords[obj.type.toLowerCase()]) {
                throw "Unsupported geometry type: " + obj.type;
            }
            try {
                geometry = this.parseCoords[obj.type.toLowerCase()].apply(
                    this, [obj.coordinates]
                );
            } catch(err) {
                // deal with bad coordinates
                throw err;
            }
        }
        // We don't reproject collections because the children are reprojected
        // for us when they are created.
        if (this.internalProjection && this.externalProjection && !collection) {
            geometry.transform(this.externalProjection, 
                               this.internalProjection); 
        }                       
        return geometry;
    },
    
    /**
     *Object with properties corresponding to the GeoJSON geometry types.
     *     Property values are functions that do the actual parsing.
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @type {null}
     * @private
     */
    parseCoords: {
        /**
         * Convert a coordinate array from GeoJSON into an
         *     GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {Object}array -  The coordinates array from the GeoJSON fragment.
         *
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "point": function(array) {
            if (this.ignoreExtraDims == false && 
                  array.length != 2) {
                    throw "Only 2D points are supported: " + array;
            }
            return new GeoGlobe.Geometry.Point(array[0], array[1]);
        },
        
        /**
         * Convert a coordinate array from GeoJSON into an
         *   GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {Object}array -  The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "multipoint": function(array) {
            var points = [];
            var p = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    p = this.parseCoords["point"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                points.push(p);
            }
            return new GeoGlobe.Geometry.MultiPoint(points);
        },

        /**
         *  Convert a coordinate array from GeoJSON into an
            GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {Object}array -  The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "linestring": function(array) {
            var points = [];
            var p = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    p = this.parseCoords["point"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                points.push(p);
            }
            return new GeoGlobe.Geometry.LineString(points);
        },
        
        /**
         * Convert a coordinate array from GeoJSON into an
         *     GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {Object}array -  The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "multilinestring": function(array) {
            var lines = [];
            var l = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    l = this.parseCoords["linestring"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                lines.push(l);
            }
            return new GeoGlobe.Geometry.MultiLineString(lines);
        },
        
        /**
         * Convert a coordinate array from GeoJSON into an
             GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "polygon": function(array) {
            var rings = [];
            var r, l;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    l = this.parseCoords["linestring"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                r = new GeoGlobe.Geometry.LinearRing(l.components);
                rings.push(r);
            }
            return new GeoGlobe.Geometry.Polygon(rings);
        },

        /**
         * Convert a coordinate array from GeoJSON into an
            GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {Object} array - The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "multipolygon": function(array) {
            var polys = [];
            var p = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    p = this.parseCoords["polygon"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                polys.push(p);
            }
            return new GeoGlobe.Geometry.MultiPolygon(polys);
        },

        /**
         * Convert a coordinate array from GeoJSON into an
             GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {Object} array - The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "box": function(array) {
            if(array.length != 2) {
                throw "GeoJSON box coordinates must have 2 elements";
            }
            return new GeoGlobe.Geometry.Polygon([
                new GeoGlobe.Geometry.LinearRing([
                    new GeoGlobe.Geometry.Point(array[0][0], array[0][1]),
                    new GeoGlobe.Geometry.Point(array[1][0], array[0][1]),
                    new GeoGlobe.Geometry.Point(array[1][0], array[1][1]),
                    new GeoGlobe.Geometry.Point(array[0][0], array[1][1]),
                    new GeoGlobe.Geometry.Point(array[0][0], array[0][1])
                ])
            ]);
        }

    },

    /**
     * 将要素，几何图形和要素数组序列化为GeoJSON字符串。
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @param {Object}obj -  GeoGlobe.Feature，GeoGlobe.Geometry，或一系列功能。
     * @param {Boolean}pretty - 用换行符和缩进结构化输出。 默认为false。
     * @returns {String} 输入几何体，要素或要素阵列的GeoJSON字符串表示形式。
     */
    write: function(obj, pretty) {
        var geojson = {
            "type": null
        };
        if(GeoGlobe.Util.isArray(obj)) {
            geojson.type = "FeatureCollection";
            var numFeatures = obj.length;
            geojson.features = new Array(numFeatures);
            for(var i=0; i<numFeatures; ++i) {
                var element = obj[i];
                if(!element instanceof GeoGlobe.Feature) {
                    var msg = "FeatureCollection only supports collections " +
                              "of features: " + element;
                    throw msg;
                }
                geojson.features[i] = this.extract.feature.apply(
                    this, [element]
                );
            }
        } else if (obj.CLASS_NAME.indexOf("GeoGlobe.Geometry") == 0) {
            geojson = this.extract.geometry.apply(this, [obj]);
        } else if (obj instanceof GeoGlobe.Feature) {
            geojson = this.extract.feature.apply(this, [obj]);
            if(obj.layer && obj.layer.projection) {
                geojson.crs = this.createCRSObject(obj);
            }
        }
        return GeoGlobe.Format.JSON.prototype.write.apply(this,
                                                            [geojson, pretty]);
    },

    /**
     *  Create the CRS object for an object.
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @param {GeoGlobe.Feature} object -
     * @returns {Object} An object which can be assigned to the crs property
     * @private
     */
    createCRSObject: function(object) {
       var proj = object.layer.projection.toString();
       var crs = {};
       if (proj.match(/epsg:/i)) {
           var code = parseInt(proj.substring(proj.indexOf(":") + 1));
           if (code == 4326) {
               crs = {
                   "type": "name",
                   "properties": {
                       "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
                   }
               };
           } else {    
               crs = {
                   "type": "name",
                   "properties": {
                       "name": "EPSG:" + code
                   }
               };
           }    
       }
       return crs;
    },
    
    /**
     * extract Object with properties corresponding to the GeoJSON types.
       Property values are functions that do the actual value extraction.
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @type {null}
     * @private
     */
    extract: {
        /**
         *  Return a partial GeoJSON object representing a single feature.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         *@param {GeoGlobe.Feature}feature -
         *
         *@returns {Object} An object representing the point.
         *@private
         */
        'feature': function(feature) {
            var geom = this.extract.geometry.apply(this, [feature.geometry]);
            var json = {
                "type": "Feature",
                "properties": feature.attributes,
                "geometry": geom
            };
            if (feature.fid != null) {
                json.id = feature.fid;
            }
            return json;
        },
        
        /**
         * Return a GeoJSON object representing a single geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry}geometry
         * @returns {Object} An object representing the geometry.
         * @private
         */
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }
            if (this.internalProjection && this.externalProjection) {
                geometry = geometry.clone();
                geometry.transform(this.internalProjection, 
                                   this.externalProjection);
            }                       
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            if(geometryType == "Collection") {
                json = {
                    "type": "GeometryCollection",
                    "geometries": data
                };
            } else {
                json = {
                    "type": geometryType,
                    "coordinates": data
                };
            }
            
            return json;
        },

        /**
         * Return an array of coordinates from a point.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.Point}point -
         * @returns {Array} An array of coordinates representing the point.
         * @private
         */
        'point': function(point) {
            return [point.x, point.y];
        },

        /**
         * Return an array of point coordinates from a multipoint.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.MultiPoint}multipoint -
         *
         * @returns {Array} An array of point coordinate arrays representing
         *     the multipoint.
         * @private
         */
        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        /**
         * Return an array of coordinate arrays from a linestring.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.LineString}linestring -
         * @returns {Array} An array of coordinate arrays representing
         *     the linestring.
         * @private
         */
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        /**
         * Return an array of linestring arrays from a linestring.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.MultiLineString}multilinestring -
         * @returns {Array} An array of linestring arrays representing
         *     the multilinestring.
         * @private
         */
        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        /**
         * Return an array of linear ring arrays from a polygon.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.Polygon}polygon -
         * @returns {Array} An array of linear ring arrays representing the polygon.
         * @private
         */
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        },

        /**
         * Return an array of polygon arrays from a multipolygon.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.MultiPolygon}multipolygon -
         * @returns {Array} An array of polygon arrays representing
         *     the multipolygon
         * @private
         */
        'multipolygon': function(multipolygon) {
            var array = [];
            for(var i=0, len=multipolygon.components.length; i<len; ++i) {
                array.push(this.extract.polygon.apply(this, [multipolygon.components[i]]));
            }
            return array;
        },
        
        /**
         *  Return an array of geometries from a geometry collection.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.Collection}collection -
         * @returns {Array} An array of geometry objects representing the geometry
         *     collection.
         * @private
         */
        'collection': function(collection) {
            var len = collection.components.length;
            var array = new Array(len);
            for(var i=0; i<len; ++i) {
                array[i] = this.extract.geometry.apply(
                    this, [collection.components[i]]
                );
            }
            return array;
        }
        

    },

    CLASS_NAME: "GeoGlobe.Format.GeoJSON" 

});     

/**
 * @class GeoGlobe.Format.WMTS
 * @classdesc 根据网络地图切片服务url，获取服务信息，解析后得到图层配置参数，构建网络切片地图服务的数据源和图层。
 * 使用此工具前，请先验证服务接口是否正常。
 */
GeoGlobe.Format.WMTS = GeoGlobe.Class4OL({

    /**
     * GeoGlobe.Format.WMTS构造函数。
     * @memberof  GeoGlobe.Format.WMTS.prototype
     */
    initialize: function(options){
        GeoGlobe.Util.extend(this, options);
    },
    /**
     * 获取网络切片地图服务信息的XML文档信息
     * @memberOf GeoGlobe.Format.WMTS.prototype
     * @param {string} url - 网络切片地图的服务地址
     * @returns {object} 网络切片地图的服务能力信息
     */
    getWMTSCapabilities: function(url){
        var capabilities = null;
        this.getCapabilities(url, function(result){
                //响应返回capabilities的XML文档信息
                var data = result.responseXML;
                if (!data || !data.documentElement) {
                    data = result.responseText;
                }
                var format = new GeoGlobe.Format.WMTSCapabilities.v1_0_0();
                capabilities = format.read(data);
            },
            function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
            });
        return capabilities;
    },
    /**
     * 根据网络切片地图的服务地址url获取服务能力信息。
     *  @memberof GeoGlobe.Format.WMTS.prototype
     *  @param {String} url-WMTS服务地址
     *  @param {Function} successFn-成功回调函数
     *  @param {Function} failFn-失败回调函数
     *  @private
     */
    getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMTS"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },

    //test
    /**
     * 根据WMTS服务地址url创建图层选项信息。
     *  @memberof GeoGlobe.Format.WMTS.prototype
     *  @param {String} url-WMTS服务地址
     *  @param {Object} capabilities-服务能力信息
     *  @param {Object} config-配置项
     *  @private
     */ 
    createLayerOption: function(url, capabilities, config){
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;
        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }

        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }
        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                        ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }

        // get the default style for the layer
        var style;
        for (var i=0, ii=layerDef.styles.length; i<ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                        (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
            (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink, 
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }
        /*
         var url;
         if (requestEncoding === "REST" && layerDef.resourceUrls) {
         url = [];
         var resourceUrls = layerDef.resourceUrls,
         resourceUrl;
         for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
         resourceUrl = layerDef.resourceUrls[t];
         if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
         url.push(resourceUrl.template);
         }
         }
         } else {
         var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
         url = [];
         var constraint;
         for (var i = 0, ii = httpGet.length; i < ii; i++) {
         constraint = httpGet[i].constraints;
         if (!constraint || (constraint && constraint.
         GetEncoding.allowedValues[requestEncoding])) {
         url.push(httpGet[i].url);
         }
         }
         }
         */
        resolutions.sort(function(a,b){
            return b-a;
        });

        var wmts_url = "";
        //var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
        //GeoGlobe.Util.getParameterString(param);
        var param = this.getParameterString({
            "SERVICE": "WMTS",
            "REQUEST": "GetTile",
            "VERSION": capabilities.version,
            "LAYER": layerDef.identifier,
            "STYLE": style.identifier,
            "TILEMATRIXSET": matrixSet.identifier,
            "FORMAT": format,
            "TILEMATRIX": "{z}",
            "TILEROW": "{y}",
            "TILECOL": "{x}"
        });
        if(url.endsWith("?")){
            wmts_url = GeoGlobe.ProxyHost + url + param;
        }else{
            wmts_url = GeoGlobe.ProxyHost + url + "?" + param;
        }
        //wmts_url = GeoGlobe.Request.makeSameOrigin(wmts_url, GeoGlobe.ProxyHost);
        /*
         var options= GeoGlobe.Util.applyDefaults(config, {
         id:layerDef.identifier,
         url:[wmts_url]
         });
         var wmtsLayer = new GeoGlobe.Layer.WMTS(options);
         wmtsLayer.matrixSet = matrixSet;
         */

        var randomNum = GeoGlobe.Util.randomStr(10);
        /*
         var layerOption = {
         source:{
         "id": "source_" + layerDef.identifier + "_" + randomNum,
         "type": "raster",
         "tiles": [wmts_url],
         "tileSize": 256
         },
         layers:[{
         "id": "layer_" + layerDef.identifier + "_" + randomNum,
         "type": "raster",
         "source": "source_" + layerDef.identifier + "_" + randomNum,
         "paint": {
         "raster-opacity": 1
         }
         }]
         };
         */

        if(layerDef.bounds){
            var bbox = [layerDef.bounds._sw.lng,layerDef.bounds._sw.lat,layerDef.bounds._ne.lng,layerDef.bounds._ne.lat];

        }else if(layerDef.BoundingBox){
            var bbox = layerDef.BoundingBox[0].bounds.toBBOX();
        }
        var link = layerDef.tileMatrixSetLinks[0].tileMatrixSet;
        var zoomoffset =contents.tileMatrixSets[link].matrixIds[0].identifier;
        //扩展图层的字段
        var metadata = {
            "name": layerDef.identifier,
            "srs": projection,
            "bbox": bbox,
            "format":layerDef.formats,
            "zoomoffset":zoomoffset
        };
        var layerOption = {
            "id": "layer_" + layerDef.identifier + "_" + randomNum,
            "type": "raster",
            "source": {
                "type": "raster",
                "tiles": [wmts_url],
                "tileSize": 256
            },
            "metadata":metadata,
            "paint": {
                "raster-opacity": 1
            }
        };
        return layerOption;
    },
    /*
     //test
     createLayerOptions: function(url){
     var cap = this.getWMTSCapabilities(url);
     var layers = cap.contents.layers;
     var layerOptions = [];
     for(var i = 0; i < layers.length; i++){
     var config = {layer: layers[i].identifier};
     var wmtsOpt = this.createLayerOption(url, cap, config);
     layerOptions.push(wmtsOpt);
     }
     return layerOptions;
     },
     */
    /**
     * 获取单个图层信息。
     * @memberof  GeoGlobe.Format.WMTS.prototype
     * @param {string} url - 服务的请求串。
     * @param   {object} options -放置请求服务的信息
     */
    createLayer: function(url,options){
        var cap = this.getWMTSCapabilities(url);
        if(options){
            var config = {layer: options.layer};

        }else{
            var config = {layer: cap.contents.layers[0].identifier};
        }
        var layerOption = this.createLayerOption(url, cap, config);
        return layerOption;
    },
    /**
     * 获取多个图层信息。
     * @memberof  GeoGlobe.Format.WMTS.prototype
     * @param {string} url - 服务的请求串。
     */
    createLayers: function(url){
        var cap = this.getWMTSCapabilities(url);
        var layers = cap.contents.layers;
        var layerOptions = [];
        for(var i = 0; i < layers.length; i++){
            var config = {layer: layers[i].identifier};
            var wmtsOpt = this.createLayerOption(url, cap, config);
            layerOptions.push(wmtsOpt);
        }
        return layerOptions;
    },

    /**
     * 获取参数字符串
     * @memberof  GeoGlobe.Format.WMTS.prototype
     * @param {Object} params-参数数组
     * @returns {String} 参数字符串
     * @private
     */
    getParameterString: function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
        return paramsArray.join("&");
    },

    CLASS_NAME: "GeoGlobe.Format.WMTS"
});

/**
 * @class GeoGlobe.Format.WMS
 * @classdesc 根据网络地图服务url，获取服务信息，解析后得到图层配置参数，构建网络地图服务的数据源和图层。
 * 使用此工具前，请先验证服务接口是否正常。
 */
GeoGlobe.Format.WMS = GeoGlobe.Class4OL({

    /**
     * GeoGlobe.Format.WMS构造函数。
     * @memberof  GeoGlobe.Format.WMS.prototype
     */
    initialize: function(options){
        GeoGlobe.Util.extend(this, options);
    },
    /**
     * 获取网络地图服务服务信息的XML文档信息
     * @memberof  GeoGlobe.Format.WMS.prototype
     * @param {String} url - WMS服务地址
     * @returns {Object} 网络地图服务的的XML文档信息。
     */
    getWMSCapabilities: function(url){
        var capabilities = null;
        this.getCapabilities(url, function(result){
                //响应返回capabilities的XML文档信息
                var data = result.responseXML;
                if (!data || !data.documentElement) {
                    data = result.responseText;
                }
                var format = new GeoGlobe.Format.WMSCapabilities.v1_1_1();
                capabilities = format.read(data);
            },
            function(){
                alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //wmsLayer = new OpenLayers.Layer.WMS({url:url});
            });
        return capabilities;
    },
    /**
     * 根据网络地图服务的地址url获取服务能力信息。
     *  @memberof GeoGlobe.Format.WMS.prototype
     *  @param {String} url-网络地图服务的地址
     *  @param {Function} successFn-成功回调函数
     *  @param {Function} failFn-失败回调函数
     *  @private
     */
    getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMS",
            VERSION:"1.1.1"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
    //test
    /**
     * 根据WMS服务地址url创建图层选项信息。
     *  @memberof GeoGlobe.Format.WMS.prototype
     *  @param {String} url-WMS服务地址
     *  @param {Object} capabilities-服务能力信息
     *  @param {Object} config-配置项
     *  @private
     */    
    createLayerOption: function(url, capabilities, config){
        var layer;
        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }
        var contents = capabilities.capability;

        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].name === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }

        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            for(var f = 0; f < layerDef.formats.length; f++){
                if(layerDef.formats[f] == "image/png"){
                    format = layerDef.formats[f];
                }
            }
            if(format !="image/png"){
                format = layerDef.formats[0];
            }
        }

        var styles = config.styles;
        if (!styles && layerDef.styles && layerDef.styles.length) {
            styles = layerDef.styles[0].name;
        }

        var srs = eval(layerDef.srs);
        var SRS;
        for(var o in srs){
            SRS = o;
        }

        var wms_url = "";
		 var transparent = config.transparent;
        //var param = "SERVICE=WMS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
        //GeoGlobe.Util.getParameterString(param);
        if(config.isTile){
            var param = this.getParameterString({
                "SERVICE": "WMS",
                "REQUEST": "GetMap",
                "VERSION": "1.1.1",
                "LAYERS": layerDef.name,
                "styles":styles,
                "FORMAT": format,
 		"TRANSPARENT":transparent,
                "BBOX": "{bbox-epsg-3857}",
                "WIDTH": "256",
                "HEIGHT": "256",
                "SRS":SRS
            });
            if(url.endsWith("?")){
                wms_url = url + param;
            }else{
                wms_url = url + "?" + param;
            }
            wms_url = GeoGlobe.appendToProxy(wms_url);
            //wms_url = GeoGlobe.Request.makeSameOrigin(wms_url, GeoGlobe.ProxyHost);
            /*
             var options= GeoGlobe.Util.applyDefaults(config, {
             id:layerDef.identifier,
             url:[wms_url]
             });
             var wmsLayer = new GeoGlobe.Layer.WMS(options);
             wmsLayer.matrixSet = matrixSet;
             */

            var randomNum = GeoGlobe.Util.randomStr(10);
            /*
             var layerOption = {
             source:{
             "id": "source_" + layerDef.identifier + "_" + randomNum,
             "type": "raster",
             "tiles": [wms_url],
             "tileSize": 256
             },
             layers:[{
             "id": "layer_" + layerDef.identifier + "_" + randomNum,
             "type": "raster",
             "source": "source_" + layerDef.identifier + "_" + randomNum,
             "paint": {
             "raster-opacity": 1
             }
             }]
             };
             */
            //扩展图层的字段
            var metadata = {
                "name": layerDef.name,
                "srs": SRS,
                "bbox": layerDef.bbox,
                "format":format
            };
            var layerOption = {
                "id": "layer_" + layerDef.name + "_" + randomNum,
                "type": "raster",
                "source": {
                    "type": "raster",
                    "tiles": [wms_url],
                    "tileSize": 256
                },
                "metadata":metadata,
                "paint": {
                    "raster-opacity": 1
                }
            };
            return layerOption;
        }else{

            //根据参数添加wmts图层
             layerOption = new GeoGlobe.Layer.WMS({
                url: url,//地址
                layer: layerDef.name,//图层标识
                format: format,//格式
                version:"1.1.1",
//        tileSize: 256,
                SRS:SRS,
                 styles:styles,
                bbox:layerDef.bbox ,//图层范围
                isTile:false
            });
            return layerOption;

        }

    },
    /**
     * 获取单个图层信息。
     * @memberof  GeoGlobe.Format.WMS.prototype
     * @param {string} url - 服务的请求串。
     * @param  {object} options -放置请求服务的信息。
     * @param {boolean} isTile -是否以瓦片大小方式去请求。
     */
    createLayer: function(url,options,isTile){
  this.url = url;
        isTile = (isTile === undefined || isTile) ? true : false;
        var transparent = (options && options.transparent === undefined || options.transparent) ? true : false;
        var cap = this.getWMSCapabilities(url);
        var layer = (options && options.layer) ? options.layer : cap.capability.layers[0].name;
        var config = {layer: layer,transparent:transparent ,isTile:isTile};
        var layerOption = this.createLayerOption(url, cap, config);
        return layerOption;


    },
	    /**
     * 获取多个图层信息。
     * @memberof  GeoGlobe.Format.WMS.prototype
     * @param {string} url - 服务的请求串。
     * @param {boolean} isTile - 是否以瓦片大小方式去请求。
     */
   createLayers: function(url,options,isTile){
        isTile = (isTile === undefined || isTile) ? true : false;
            var transparent = (options && options.transparent === undefined || options.transparent) ? true : false;
            var cap = this.getWMSCapabilities(url);
            var layers = cap.capability.layers;
            var layerOptions = [];
            for(var i = 0; i < layers.length; i++){
                var config = {layer: layers[i].name,transparent:transparent ,isTile:isTile};
                var wmsOpt = this.createLayerOption(url, cap, config);
                layerOptions.push(wmsOpt);
            }
            return layerOptions;
    },
    /**
     * 获取参数字符串
     * @memberof  GeoGlobe.Format.WMS.prototype
     * @param {Object}params-参数对象
     * @returns {String} 参数字符串
     * @private
     */
    getParameterString: function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
        return paramsArray.join("&");
    },

    CLASS_NAME: "GeoGlobe.Format.WMS"
});

/**
 * @class  GeoGlobe.Format.VTS
 * @classdesc 根据矢量瓦片服务url，获取GetCapabilities信息，解析后得到图层配置参数，构建矢量瓦片服务数据源source和图层layer。
 * 使用此工具前，请先验证服务接口是否正常。
 */
GeoGlobe.Format.VTS = GeoGlobe.Class4OL({

    /**
     * GeoGlobe.Format.VTS构造函数。
     * @memberof  GeoGlobe.Format.VTS.prototype
     */
    initialize: function(options){
        GeoGlobe.Util.extend(this, options);
    },
    /**
     * 获取矢量瓦片服务 capabilities的XML文档信息
     * @memberof GeoGlobe.Format.VTS.prototype
     * @param {string} url - 服务的请求串。
     */
    getVTSCapabilities: function(url){
        this.url = url;
        var capabilities = null;
        this.getCapabilities(url, function(result){
                //响应返回capabilities的XML文档信息
                var data = result.responseXML;
                if (!data || !data.documentElement) {
                    data = result.responseText;
                }
                var format = new GeoGlobe.Format.VTSCapabilities.v1_0_0();
                capabilities = format.read(data);
            },
            function(){
                alert("VTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //VTSLayer = new OpenLayers.Layer.VTS({url:url});
            });
        return capabilities;
    },
    /**
     * 根据矢量瓦片服务地址url获取服务能力信息。
     *  @memberof GeoGlobe.Format.VTS.prototype
     *  @param {String} url - 矢量瓦片服务地址
     *  @param {Function} successFn-成功回调函数
     *  @param {Function} failFn-失败回调函数
     *  @private
     */
    getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMTS"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("VTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },

    /**
     * 根据矢量瓦片服务地址url创建图层选项信息。
     *  @memberof GeoGlobe.Format.VTS.prototype
     *  @param {String} url-矢量瓦片服务地址
     *  @param {Object} capabilities-服务能力信息
     *  @param {Object} config-配置项
     *  @private
     */
    createLayerOption: function(url, capabilities, config){
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;
        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }

        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }
        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                        ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }
        var styleName =[];
        if(config.styleName && config.styleName !=""){
            styleName[0] = config.styleName;
        }else{
            this.GetStyleName(function(result){
                styleName = result
            });
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                        (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
            (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink,
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }
        /*
         var url;
         if (requestEncoding === "REST" && layerDef.resourceUrls) {
         url = [];
         var resourceUrls = layerDef.resourceUrls,
         resourceUrl;
         for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
         resourceUrl = layerDef.resourceUrls[t];
         if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
         url.push(resourceUrl.template);
         }
         }
         } else {
         var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
         url = [];
         var constraint;
         for (var i = 0, ii = httpGet.length; i < ii; i++) {
         constraint = httpGet[i].constraints;
         if (!constraint || (constraint && constraint.
         GetEncoding.allowedValues[requestEncoding])) {
         url.push(httpGet[i].url);
         }
         }
         }
         */
        resolutions.sort(function(a,b){
            return b-a;
        });

        var vts_url = "";
        var layerOption = {
            "layers":[],
            "source":{},
            "source_id":"",
            "url":"",
            "url_tmpl":"",
            "layerType":"VTS"
        };
        //var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
        //GeoGlobe.Util.getParameterString(param);
        var param = this.getParameterString({
            "SERVICE": "WMTS",
            "REQUEST": "GetTile",
            "VERSION": capabilities.version,
            "LAYER": layerDef.identifier,
            //"STYLE": style.identifier,
            "TILEMATRIXSET": matrixSet.identifier,
            "FORMAT": "protobuf",
            "TILEMATRIX": "{z}",
            "TILEROW": "{y}",
            "TILECOL": "{x}"
        });
        layerOption.url =url;

        if(url.endsWith("?")){
            vts_url = GeoGlobe.ProxyHost + url + param;
        }else{
            vts_url = GeoGlobe.ProxyHost + url + "?" + param;
        }
        layerOption.url_tmpl =vts_url;
        //vts_url = GeoGlobe.Request.makeSameOrigin(vts_url, GeoGlobe.ProxyHost);
        /*
         var options= GeoGlobe.Util.applyDefaults(config, {
         id:layerDef.identifier,
         url:[vts_url]
         });
         var vtsLayer = new GeoGlobe.Layer.VTS(options);
         vtsLayer.matrixSet = matrixSet;
         */

        var randomNum = GeoGlobe.Util.randomStr(10);
        /*
         var layerOption = {
         source:{
         "id": "source_" + layerDef.identifier + "_" + randomNum,
         "type": "raster",
         "tiles": [vts_url],
         "tileSize": 256
         },
         layers:[{
         "id": "layer_" + layerDef.identifier + "_" + randomNum,
         "type": "raster",
         "source": "source_" + layerDef.identifier + "_" + randomNum,
         "paint": {
         "raster-opacity": 1
         }
         }]
         };
         */

        if(layerDef.bounds){
            var bbox = [layerDef.bounds._sw.lng,layerDef.bounds._sw.lat,layerDef.bounds._ne.lng,layerDef.bounds._ne.lat];
        }else if(layerDef.BoundingBox){
            var bbox = layerDef.BoundingBox[0].bounds.toBBOX();
        }
        var link = layerDef.tileMatrixSetLinks[0].tileMatrixSet;
        var zoomoffset =contents.tileMatrixSets[link].matrixIds[0].identifier;

        this.GetStyle(styleName[0], function(result){
                if(result.sprite){
                    var sprite = GeoGlobe.ProxyHost+result.sprite;
                }else{
                    var sprite = "";
                }
                if(result.glyphs){
                    var glyphs = GeoGlobe.ProxyHost+result.glyphs;
                }else{
                    var glyphs = "";
                }
                //扩展图层的字段
                var metadata = {
                    "name": layerDef.identifier,
                    "sprite":sprite,
                    "glyphs":glyphs,
                    "styleName":result.styleName,
                    "srs": projection,
                    "bbox": bbox,
                    "format":layerDef.formats,
                    "zoomoffset":zoomoffset
                };
                var source_id = "source_vts_"+GeoGlobe.Util.randomStr(6);
                layerOption.source_id = source_id;
                layerOption.source ={
                    "type": "vector",
                    "tiles": [vts_url]
                };
                if(result.styleData){
                    for(var i=0;i<result.styleData.layers.length;i++){
                        result.styleData.layers[i].metadata = metadata;
                        result.styleData.layers[i].source =source_id;
                        layerOption.layers[i] =  result.styleData.layers[i];
                    }
                }else{
                    for(var i=0;i<result.layers.length;i++){
                        result.layers[i].metadata = metadata;
                        result.layers[i].source =source_id;
                        layerOption.layers[i] =  result.layers[i];
                    }
                }

            },
            function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
            });
        //var layerOption = {
        //    "id": "layer_" + layerDef.identifier + "_" + randomNum,
        //    "type": "raster",
        //    "source": {
        //        "type": "raster",
        //        "tiles": [vts_url],
        //        "tileSize": 256
        //    },
        //    "metadata":metadata,
        //    "paint": {
        //        "raster-opacity": 1
        //    }
        //};
        return layerOption;
    },
    /*
     //test
     createLayerOptions: function(url){
     var cap = this.getVTSCapabilities(url);
     var layers = cap.contents.layers;
     var layerOptions = [];
     for(var i = 0; i < layers.length; i++){
     var config = {layer: layers[i].identifier};
     var vtsOpt = this.createLayerOption(url, cap, config);
     layerOptions.push(vtsOpt);
     }
     return layerOptions;
     },
     */
    /**
     * 获取多个图层信息。
     * @memberof  GeoGlobe.Format.VTS.prototype
     * @param {string} url - 服务的请求串。
     * @param  {object} options- 放置请求的图层名称和样式名称
     * @param {string} layer - 图层名称，若不填，默认第一个
     * @param {string} styleName -  样式名称，若不填，默认第一个
     */
    createLayer: function(url,options){
        var cap = this.getVTSCapabilities(url);
        options = options ? options : {};
        options.layer = options.layer ? options.layer : cap.contents.layers[0].identifier;
        options.styleName = options.styleName ? options.styleName : "";
        var layerOption = this.createLayerOption(url, cap, options);
        return layerOption;
    },
    /**
     * 获取多个图层信息。
     * @memberof  GeoGlobe.Format.VTS.prototype
     * @param {string} url - 服务的请求串。
     */
    createLayers: function(url){
        var cap = this.getVTSCapabilities(url);
        var layers = cap.contents.layers;
        var layerOptions = [];
        for(var i = 0; i < layers.length; i++){
            var config = {layer: layers[i].identifier};
            var vtsOpt = this.createLayerOption(url, cap, config);
            layerOptions.push(vtsOpt);
        }
        return layerOptions;
    },

    /**
     * 获取样式名称。
     * @memberof  GeoGlobe.Format.VTS.prototype
     * @param {Function}successFn - 请求成功的回调函数。
     * @param {Function}  failFn -请求失败的回调函数。
     */
    GetStyleName: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(result){
                var obj = result.responseText;
                if(!obj){
                    failFn();
                    return false;
                }
                var jformat = new GeoGlobe.Format.JSON();
                var geojson = jformat.read(obj);
                var styleName =[];
                if(geojson.style){
                    for(var n =0;n <geojson.style.length;n++){
                        styleName.push(geojson.style[n].styleName);
                    }
                }else if(geojson.styleName){
                    for(var s = 0; s < geojson.styleName.length;s++){
                        styleName.push(geojson.styleName[s]);
                    }
                }

                //var style = geojson.style[0];
                successFn(styleName);
            },
            failure: failFn
        });
    },
    /**
     * 获取样式数据（用json描述）。
     * @memberof  GeoGlobe.Format.VTS.prototype
     * @param {Function}successFn -  请求成功的回调函数。
     * @param {Function}  failFn - 请求失败的回调函数。
     */
    GetStyle: function(styleName,successFn, failFn){
        var url = this.url;
        if(styleName =="" || styleName == undefined){
            alert("请查看样式名称是否存在");
            return ;
        }
        var params = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS",
            VERSION: "1.0.0",
            STYLENAME:styleName
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(result){
                var obj = result.responseText;
                if(!obj){
                    failFn();
                    return false;
                }
                var jformat = new GeoGlobe.Format.JSON();
                var style = jformat.read(obj);
                //var style = geojson.style[0];
                successFn(style);
            },
            failure: failFn
        });
    },
    /**
     * 获取参数字符串。
     * @memberof  GeoGlobe.Format.VTS.prototype
     * @param {Object} params - 参数对象。
     * @returns {String} 参数字符串。
     *
     */
    getParameterString: function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
        return paramsArray.join("&");

    },

    CLASS_NAME: "GeoGlobe.Format.VTS"
});

/**
 * @class  GeoGlobe.Format.WMSCapabilities
 * @classdesc   阅读WMS功能。
 * @returns {Array} 命名图层列表。
 * @private
 */

GeoGlobe.Format.WMSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     * defaultVersion-如果没有找到版本号， 默认值是“1.1.1”。
     * @memberof GeoGlobe.Format.WMSCapabilities.prototype
     * @type {String}
     */
    defaultVersion: "1.1.1",
    
    /**
     * 配置文件 - 如果提供，使用自定义配置文件。
     * 目前支持的配置：
     *- WMSC - 解析WMS-C的提供的特定功能。
     * @memberof GeoGlobe.Format.WMSCapabilities.prototype
     * @type {String}

     */
      profile:null,
    
    /**
     * 为WMS功能创建一个新的分析器。
     * @memberof GeoGlobe.Format.WMSCapabilities.prototype
     * @param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */

    /**
     *  读取功能数据，并返回一个图层列表。
     * @memberof GeoGlobe.Format.WMSCapabilities.prototype
     * @param {String| DOMElement}  data -数据读取/解析。
     */
    
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities" 

});

/**
 * @class GeoGlobe.Format.WMSCapabilities.v1
 * @classdesc   抽象类不要直接实例化。为WMS 1.1.X和WMS 1.3.X创建公共部分。
 * @returns {Array} 命名图层列表。
 */

GeoGlobe.Format.WMSCapabilities.v1 = GeoGlobe.Class4OL(
    GeoGlobe.Format.XML, {
    
    /**
     * namespaces-Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.WMSCapabilities.v1.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        wms: "http://www.opengis.net/wms",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * @memberof   GeoGlobe.Format.WMSCapabilities.v1.prototype
     * @type {null}
     * @private
     */
    defaultPrefix: "wms",
    
    /**
     * 创建其中一个子类的实例。
     * @memberof   GeoGlobe.Format.WMSCapabilities.v1.prototype
     * @param {Object} options -  一个可选对象，其属性将在此实例上设置。
     */

    /**
     * 从字符串读取功能数据，并返回一个图层列表。
     * @memberof   GeoGlobe.Format.WMSCapabilities.v1.prototype
     * @param {String|DOMElement}  data -数据读取/解析。

     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var raw = data;
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        if (capabilities.service === undefined) {
            // an exception must have occurred, so parse it
            var parser = new GeoGlobe.Format.OGCExceptionReport();
            capabilities.error = parser.read(raw);
        }
        return capabilities;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WMSCapabilities.v1.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wms": {
            "Service": function(node, obj) {
                obj.service = {};
                this.readChildNodes(node, obj.service);
            },
            "Name": function(node, obj) {
                obj.name = this.getChildValue(node);
            },
            "Title": function(node, obj) {
                obj.title = this.getChildValue(node);
            },
            "Abstract": function(node, obj) {
                obj["abstract"] = this.getChildValue(node);
            },
            "BoundingBox": function(node, obj) {
                var bbox = {};
                bbox.bbox = [
                    parseFloat(node.getAttribute("minx")),
                    parseFloat(node.getAttribute("miny")),
                    parseFloat(node.getAttribute("maxx")),
                    parseFloat(node.getAttribute("maxy"))
                ];
                var res = {
                    x: parseFloat(node.getAttribute("resx")),
                    y: parseFloat(node.getAttribute("resy"))
                };

                if (! (isNaN(res.x) && isNaN(res.y))) {
                    bbox.res = res;
                }
                // return the bbox so that descendant classes can set the
                // CRS and SRS and add it to the obj
                return bbox;
            },
            "OnlineResource": function(node, obj) {
                obj.href = this.getAttributeNS(node, this.namespaces.xlink, 
                    "href");
            },
            "ContactInformation": function(node, obj) {
                obj.contactInformation = {};
                this.readChildNodes(node, obj.contactInformation);
            },
            "ContactPersonPrimary": function(node, obj) {
                obj.personPrimary = {};
                this.readChildNodes(node, obj.personPrimary);
            },
            "ContactPerson": function(node, obj) {
                obj.person = this.getChildValue(node);
            },
            "ContactOrganization": function(node, obj) {
                obj.organization = this.getChildValue(node);
            },
            "ContactPosition": function(node, obj) {
                obj.position = this.getChildValue(node);
            },
            "ContactAddress": function(node, obj) {
                obj.contactAddress = {};
                this.readChildNodes(node, obj.contactAddress);
            },
            "AddressType": function(node, obj) {
                obj.type = this.getChildValue(node);
            },
            "Address": function(node, obj) {
                obj.address = this.getChildValue(node);
            },
            "City": function(node, obj) {
                obj.city = this.getChildValue(node);
            },
            "StateOrProvince": function(node, obj) {
                obj.stateOrProvince = this.getChildValue(node);
            },
            "PostCode": function(node, obj) {
                obj.postcode = this.getChildValue(node);
            },
            "Country": function(node, obj) {
                obj.country = this.getChildValue(node);
            },
            "ContactVoiceTelephone": function(node, obj) {
                obj.phone = this.getChildValue(node);
            },
            "ContactFacsimileTelephone": function(node, obj) {
                obj.fax = this.getChildValue(node);
            },
            "ContactElectronicMailAddress": function(node, obj) {
                obj.email = this.getChildValue(node);
            },
            "Fees": function(node, obj) {
                var fees = this.getChildValue(node);
                if (fees && fees.toLowerCase() != "none") {
                    obj.fees = fees;
                }
            },
            "AccessConstraints": function(node, obj) {
                var constraints = this.getChildValue(node);
                if (constraints && constraints.toLowerCase() != "none") {
                    obj.accessConstraints = constraints;
                }
            },
            "Capability": function(node, obj) {
                obj.capability = {
                    nestedLayers: [],
                    layers: []
                };
                this.readChildNodes(node, obj.capability);
            },
            "Request": function(node, obj) {
                obj.request = {};
                this.readChildNodes(node, obj.request);
            },
            "GetCapabilities": function(node, obj) {
                obj.getcapabilities = {formats: []};
                this.readChildNodes(node, obj.getcapabilities);
            },
            "Format": function(node, obj) {
                if (GeoGlobe.Util.isArray(obj.formats)) {
                    obj.formats.push(this.getChildValue(node));
                } else {
                    obj.format = this.getChildValue(node);
                }
            },
            "DCPType": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "HTTP": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Get": function(node, obj) {
                obj.get = {};
                this.readChildNodes(node, obj.get);
                // backwards compatibility
                if (!obj.href) {
                    obj.href = obj.get.href;
                }
            },
            "Post": function(node, obj) {
                obj.post = {};
                this.readChildNodes(node, obj.post);
                // backwards compatibility
                if (!obj.href) {
                    obj.href = obj.get.href;
                }
            },
            "GetMap": function(node, obj) {
                obj.getmap = {formats: []};
                this.readChildNodes(node, obj.getmap);
            },
            "GetFeatureInfo": function(node, obj) {
                obj.getfeatureinfo = {formats: []};
                this.readChildNodes(node, obj.getfeatureinfo);
            },
            "Exception": function(node, obj) {
                obj.exception = {formats: []};
                this.readChildNodes(node, obj.exception);
            },
            "Layer": function(node, obj) {
                var parentLayer, capability;
                if (obj.capability) {
                    capability = obj.capability;
                    parentLayer = obj;
                } else {
                    capability = obj;
                }
                var attrNode = node.getAttributeNode("queryable");
                var queryable = (attrNode && attrNode.specified) ? 
                    node.getAttribute("queryable") : null;
                attrNode = node.getAttributeNode("cascaded");
                var cascaded = (attrNode && attrNode.specified) ?
                    node.getAttribute("cascaded") : null;
                attrNode = node.getAttributeNode("opaque");
                var opaque = (attrNode && attrNode.specified) ?
                    node.getAttribute('opaque') : null;
                var noSubsets = node.getAttribute('noSubsets');
                var fixedWidth = node.getAttribute('fixedWidth');
                var fixedHeight = node.getAttribute('fixedHeight');
                var parent = parentLayer || {},
                    extend = GeoGlobe.Util.extend;
                var layer = {
                    nestedLayers: [],
                    styles: parentLayer ? [].concat(parentLayer.styles) : [],
                    srs: parentLayer ? extend({}, parent.srs) : {}, 
                    metadataURLs: [],
                    bbox: parentLayer ? extend({}, parent.bbox) : {},
                    llbbox: parent.llbbox,
                    dimensions: parentLayer ? extend({}, parent.dimensions) : {},
                    authorityURLs: parentLayer ? extend({}, parent.authorityURLs) : {},
                    identifiers: {},
                    keywords: [],
                    queryable: (queryable && queryable !== "") ? 
                        (queryable === "1" || queryable === "true" ) :
                        (parent.queryable || false),
                    cascaded: (cascaded !== null) ? parseInt(cascaded) :
                        (parent.cascaded || 0),
                    opaque: opaque ? 
                        (opaque === "1" || opaque === "true" ) :
                        (parent.opaque || false),
                    noSubsets: (noSubsets !== null) ? 
                        (noSubsets === "1" || noSubsets === "true" ) :
                        (parent.noSubsets || false),
                    fixedWidth: (fixedWidth != null) ? 
                        parseInt(fixedWidth) : (parent.fixedWidth || 0),
                    fixedHeight: (fixedHeight != null) ? 
                        parseInt(fixedHeight) : (parent.fixedHeight || 0),
                    minScale: parent.minScale,
                    maxScale: parent.maxScale,
                    attribution: parent.attribution
                };
                obj.nestedLayers.push(layer);
                layer.capability = capability;
                this.readChildNodes(node, layer);
                delete layer.capability;
                if(layer.name) {
                    var parts = layer.name.split(":"),
                        request = capability.request,
                        gfi = request.getfeatureinfo;
                    if(parts.length > 0) {
                        layer.prefix = parts[0];
                    }
                    capability.layers.push(layer);
                    if (layer.formats === undefined) {
                        layer.formats = request.getmap.formats;
                    }
                    if (layer.infoFormats === undefined && gfi) {
                        layer.infoFormats = gfi.formats;
                    }
                }
            },
            "Attribution": function(node, obj) {
                obj.attribution = {};
                this.readChildNodes(node, obj.attribution);
            },
            "LogoURL": function(node, obj) {
                obj.logo = {
                    width: node.getAttribute("width"),
                    height: node.getAttribute("height")
                };
                this.readChildNodes(node, obj.logo);
            },
            "Style": function(node, obj) {
                var style = {};
                obj.styles.push(style);
                this.readChildNodes(node, style);
            },
            "LegendURL": function(node, obj) {
                var legend = {
                    width: node.getAttribute("width"),
                    height: node.getAttribute("height")
                };
                obj.legend = legend;
                this.readChildNodes(node, legend);
            },
            "MetadataURL": function(node, obj) {
                var metadataURL = {type: node.getAttribute("type")};
                obj.metadataURLs.push(metadataURL);
                this.readChildNodes(node, metadataURL);
            },
            "DataURL": function(node, obj) {
                obj.dataURL = {};
                this.readChildNodes(node, obj.dataURL);
            },
            "FeatureListURL": function(node, obj) {
                obj.featureListURL = {};
                this.readChildNodes(node, obj.featureListURL);
            },
            "AuthorityURL": function(node, obj) {
                var name = node.getAttribute("name");
                var authority = {};
                this.readChildNodes(node, authority);
                obj.authorityURLs[name] = authority.href;
            },
            "Identifier": function(node, obj) {
                var authority = node.getAttribute("authority");
                obj.identifiers[authority] = this.getChildValue(node);
            },
            "KeywordList": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "SRS": function(node, obj) {
                obj.srs[this.getChildValue(node)] = true;
            }
        }
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1" 

});

/**
 * @class   GeoGlobe.Format.WMSCapabilities.v1_1
 * @classdesc  抽象类不要直接实例化。
 * @private
 */


GeoGlobe.Format.WMSCapabilities.v1_1 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1, {
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WMSCapabilities.v1_1.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "WMT_MS_Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Keyword": function(node, obj) {
                if (obj.keywords) {
                    obj.keywords.push(this.getChildValue(node));
                }
            },
            "DescribeLayer": function(node, obj) {
                obj.describelayer = {formats: []};
                this.readChildNodes(node, obj.describelayer);
            },
            "GetLegendGraphic": function(node, obj) {
                obj.getlegendgraphic = {formats: []};
                this.readChildNodes(node, obj.getlegendgraphic);
            },
            "GetStyles": function(node, obj) {
                obj.getstyles = {formats: []};
                this.readChildNodes(node, obj.getstyles);
            },
            "PutStyles": function(node, obj) {
                obj.putstyles = {formats: []};
                this.readChildNodes(node, obj.putstyles);
            },
            "UserDefinedSymbolization": function(node, obj) {
                var userSymbols = {
                    supportSLD: parseInt(node.getAttribute("SupportSLD")) == 1,
                    userLayer: parseInt(node.getAttribute("UserLayer")) == 1,
                    userStyle: parseInt(node.getAttribute("UserStyle")) == 1,
                    remoteWFS: parseInt(node.getAttribute("RemoteWFS")) == 1
                };
                obj.userSymbols = userSymbols;
            },
            "LatLonBoundingBox": function(node, obj) {
                obj.llbbox = [
                    parseFloat(node.getAttribute("minx")),
                    parseFloat(node.getAttribute("miny")),
                    parseFloat(node.getAttribute("maxx")),
                    parseFloat(node.getAttribute("maxy"))
                ];
            },
            "BoundingBox": function(node, obj) {
                var bbox = GeoGlobe.Format.WMSCapabilities.v1.prototype.readers["wms"].BoundingBox.apply(this, [node, obj]);
                bbox.srs  = node.getAttribute("SRS");
                obj.bbox[bbox.srs] = bbox;
            },
            "ScaleHint": function(node, obj) {
                var min = node.getAttribute("min");
                var max = node.getAttribute("max");
                var rad2 = Math.pow(2, 0.5);
                var ipm = GeoGlobe.INCHES_PER_UNIT["m"];
                if (min != 0) {
                    obj.maxScale = parseFloat(
                        ((min / rad2) * ipm * 
                            GeoGlobe.DOTS_PER_INCH).toPrecision(13)
                    );
                }
                if (max != Number.POSITIVE_INFINITY) {
                    obj.minScale = parseFloat(
                        ((max / rad2) * ipm * 
                            GeoGlobe.DOTS_PER_INCH).toPrecision(13)
                    );
                }
            },
            "Dimension": function(node, obj) {
                var name = node.getAttribute("name").toLowerCase();
                var dim = {
                    name: name,
                    units: node.getAttribute("units"),
                    unitsymbol: node.getAttribute("unitSymbol")
                };
                obj.dimensions[dim.name] = dim;
            },
            "Extent": function(node, obj) {
                var name = node.getAttribute("name").toLowerCase();
                if (name in obj["dimensions"]) {
                    var extent = obj.dimensions[name];
                    extent.nearestVal = 
                        node.getAttribute("nearestValue") === "1";
                    extent.multipleVal = 
                        node.getAttribute("multipleValues") === "1";
                    extent.current = node.getAttribute("current") === "1";
                    extent["default"] = node.getAttribute("default") || "";
                    var values = this.getChildValue(node);
                    extent.values = values.split(",");
                }
                }
        }, GeoGlobe.Format.WMSCapabilities.v1.prototype.readers["wms"])
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1" 

});

/**
 * @class   GeoGlobe.Format.WMSCapabilities/v1_1_0
 * @classdesc  阅读WMS功能版本1.1.0。
 * @private
 */


GeoGlobe.Format.WMSCapabilities.v1_1_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1_1, {
    
    /**
     *  version-The specific parser version.
     * @memberof  GeoGlobe.Format.WMSCapabilities/v1_1_0.prototype
     * @type {String}
     * @private
     */
    version: "1.1.0",
    
    /**
     *  Create a new parser for WMS capabilities version 1.1.0.
     * @memberof  GeoGlobe.Format.WMSCapabilities/v1_1_0.prototype
     * @param {Object}options - An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WMSCapabilities/v1_1_0.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "SRS": function(node, obj) {
                var srs = this.getChildValue(node);
                var values = srs.split(/ +/);
                for (var i=0, len=values.length; i<len; i++) {
                    obj.srs[values[i]] = true;
                }
            }
        }, GeoGlobe.Format.WMSCapabilities.v1_1.prototype.readers["wms"])
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1_0" 

});

/**
 * @class  GeoGlobe.Format.WMSCapabilities/v1_1_1
 * @classdesc 阅读WMS功能版本1.1.1。
 */


GeoGlobe.Format.WMSCapabilities.v1_1_1 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1_1, {
    
    /**
     * version- The specific parser version.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     * @private
     */
    version: "1.1.1",
    
    /**
     * 为WMS功能版本1.1.1创建一个新的解析器。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {Object}  options -一个可选对象，其属性将在此实例上设置。
     */

    /**
     *  Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "SRS": function(node, obj) {
                obj.srs[this.getChildValue(node)] = true;
            }
        }, GeoGlobe.Format.WMSCapabilities.v1_1.prototype.readers["wms"])
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1_1" 

});

/**
 * @class  GeoGlobe.Format.WMSCapabilities/v1_1_1
 * @classdesc 阅读WMS功能版本1.1.1。
 * @private
 */


GeoGlobe.Format.WMSCapabilities.v1_1_1_WMSC = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1_1_1, {
    
    /**
     * version- The specific parser version.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     * @private
     */
    version: "1.1.1",
    
    /**
     * profile-The specific profile
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     * @private
     */
    profile: "WMSC",
    
    /**
     * 为WMS-C功能版本1.1.1创建一个新的分析器。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {Object}options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     *  Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {null}
     * @private
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "VendorSpecificCapabilities": function(node, obj) {
                obj.vendorSpecific = {tileSets: []};
                this.readChildNodes(node, obj.vendorSpecific);
            },
            "TileSet": function(node, vendorSpecific) {
                var tileset = {srs: {}, bbox: {}, resolutions: []};
                this.readChildNodes(node, tileset);
                vendorSpecific.tileSets.push(tileset);
            },
            "Resolutions": function(node, tileset) {
                var res = this.getChildValue(node).split(" ");
                for (var i=0, len=res.length; i<len; i++) {
                    if (res[i] != "") {
                        tileset.resolutions.push(parseFloat(res[i]));
                    }
                }
            },
            "Width": function(node, tileset) {
                tileset.width = parseInt(this.getChildValue(node));
            },
            "Height": function(node, tileset) {
                tileset.height = parseInt(this.getChildValue(node));
            },
            "Layers": function(node, tileset) {
                tileset.layers = this.getChildValue(node);
            },
            "Styles": function(node, tileset) {
                tileset.styles = this.getChildValue(node);
            }
        }, GeoGlobe.Format.WMSCapabilities.v1_1_1.prototype.readers["wms"])
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1_1_WMSC" 

});

/**
 * @class  GeoGlobe.Format.WMSCapabilities/v1_3
 * @classdesc  WMS功能版本1.3.X的抽象基类。
 * SLD 1.1.0增加了额外的操作DescribeLayer和GetLegendGraphic，
 * 参阅: http://schemas.opengis.net/sld/1.1.0/sld_capabilities.xsd
 * @private
 */

GeoGlobe.Format.WMSCapabilities.v1_3 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1, {
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_3.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "WMS_Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "LayerLimit": function(node, obj) {
                obj.layerLimit = parseInt(this.getChildValue(node));
            },
            "MaxWidth": function(node, obj) {
                obj.maxWidth = parseInt(this.getChildValue(node));
            },
            "MaxHeight": function(node, obj) {
                obj.maxHeight = parseInt(this.getChildValue(node));
            },
            "BoundingBox": function(node, obj) {
                var bbox = GeoGlobe.Format.WMSCapabilities.v1.prototype.readers["wms"].BoundingBox.apply(this, [node, obj]);
                bbox.srs  = node.getAttribute("CRS");
                obj.bbox[bbox.srs] = bbox;
            },
            "CRS": function(node, obj) {
                // CRS is the synonym of SRS
                this.readers.wms.SRS.apply(this, [node, obj]); 
            },
            "EX_GeographicBoundingBox": function(node, obj) {
                // replacement of LatLonBoundingBox
                obj.llbbox = [];
                this.readChildNodes(node, obj.llbbox);
                
            },
            "westBoundLongitude": function(node, obj) {
                obj[0] = this.getChildValue(node);
            },
            "eastBoundLongitude": function(node, obj) {
                obj[2] = this.getChildValue(node);
            },
            "southBoundLatitude": function(node, obj) {
                obj[1] = this.getChildValue(node);
            },
            "northBoundLatitude": function(node, obj) {
                obj[3] = this.getChildValue(node);
            },
            "MinScaleDenominator": function(node, obj) {
                obj.maxScale = parseFloat(this.getChildValue(node)).toPrecision(16);
            },
            "MaxScaleDenominator": function(node, obj) {
                obj.minScale = parseFloat(this.getChildValue(node)).toPrecision(16);
            },
            "Dimension": function(node, obj) {
                // dimension has extra attributes: default, multipleValues, 
                // nearestValue, current which used to be part of Extent. It now
                // also contains the values.
                var name = node.getAttribute("name").toLowerCase();
                var dim = {
                    name: name,
                    units: node.getAttribute("units"),
                    unitsymbol: node.getAttribute("unitSymbol"),
                    nearestVal: node.getAttribute("nearestValue") === "1",
                    multipleVal: node.getAttribute("multipleValues") === "1",
                    "default": node.getAttribute("default") || "",
                    current: node.getAttribute("current") === "1",
                    values: this.getChildValue(node).split(",")
                    
                };
                // Theoretically there can be more dimensions with the same
                // name, but with a different unit. Until we meet such a case,
                // let's just keep the same structure as the WMS 1.1 
                // GetCapabilities parser uses. We will store the last
                // one encountered.
                obj.dimensions[dim.name] = dim;
            },
            "Keyword": function(node, obj) {
                // TODO: should we change the structure of keyword in v1.js?
                // Make it an object with a value instead of a string?
                var keyword = {value: this.getChildValue(node), 
                    vocabulary: node.getAttribute("vocabulary")};
                if (obj.keywords) {
                    obj.keywords.push(keyword);
                }
            }
        }, GeoGlobe.Format.WMSCapabilities.v1.prototype.readers["wms"]),
        "sld": {
            "UserDefinedSymbolization": function(node, obj) {
                this.readers.wms.UserDefinedSymbolization.apply(this, [node, obj]);
                // add the two extra attributes
                obj.userSymbols.inlineFeature = parseInt(node.getAttribute("InlineFeature")) == 1;
                obj.userSymbols.remoteWCS = parseInt(node.getAttribute("RemoteWCS")) == 1;
            },
            "DescribeLayer": function(node, obj) {
                this.readers.wms.DescribeLayer.apply(this, [node, obj]);
            },
            "GetLegendGraphic": function(node, obj) {
                this.readers.wms.GetLegendGraphic.apply(this, [node, obj]);
            }
        }
    },
    
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_3" 

});

/**
 * @class  GeoGlobe.Format.WMSCapabilities/v1_3_0
 * @classdesc 阅读WMS功能版本1.3.0。
 * SLD 1.1.0增加了额外的操作DescribeLayer和GetLegendGraphic，
 * 参见: http://schemas.opengis.net/sld/1.1.0/sld_capabilities.xsd
 * @private
 */


GeoGlobe.Format.WMSCapabilities.v1_3_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1_3, {
    
    /**
     * version- The specific parser version.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_3_0.prototype
     * @type {String}
     * @private
     */
    version: "1.3.0",
    
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_3_0" 

});

/**
 * @class  GeoGlobe.Format.WMTSCapabilities
 * @classdesc  网络切片地图服务功能描述。
 */


GeoGlobe.Format.WMTSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {

    /**
     * 默认版本-如果没有找到版本号， 默认值是“1.0.0”。
     * @memberof GeoGlobe.Format.WMTSCapabilities.prototype
     * @type {String}
     */
    defaultVersion: "1.0.0",

    /**
     * yx-yx对象中的成员用于确定CRS URN是否对应于具有y，x轴顺序的CRS。 
     * 成员名称是CRS URN，值是布尔值。 
     * 默认情况下，假定以下CRS URN与y，x轴顺序对应的CRS：
     * @memberof GeoGlobe.Format.WMTSCapabilities.prototype
     * @type {Object}

     */
    yx: {
        "urn:ogc:def:crs:EPSG::4326": true
    },

    /**
     *  为WMTS功能创建一个新的解析器。
     * @memberof GeoGlobe.Format.WMTSCapabilities.prototype
     * @param {Object}options - 选项中的值在实例中设置。
     */

    /**
     * 从文档中读取WMTS能力数据，并返回有关服务的信息（主要是提供和观察属性）。
     * @memberof GeoGlobe.Format.WMTSCapabilities.prototype
     * @param {String} or {DOMElement} data - 数据读取/解析。
     * @returns {Object} 有关WMTS功能的信息。
     */

    /**
     * 根据提供的功能对象创建一个WMTS层。
     * @memberof GeoGlobe.Format.WMTSCapabilities.prototype
     * @param {Object} capabilities -  读取后获知的能力信息。
     * @param {Object} config -  图层的配置属性。 如果没有提供，将是默认值。
     * @param {String} layer -  图层标识符。
     *
     * 可选的配置属性：
     *  @param {String}matrixSet -  矩阵集标识符，如果图层功能中存在多个矩阵集，则需要该标识符集。
     * @param {String} projection -  没有指定matrixSet时所需的CRS。 例如：“EPSG：3857”。 如果所需投影不可用，则会抛出错误。
     * @param {String} style -  样式名称。
     * @param {String} format -  图层的图像格式。 默认值是GetCapabilities响应中返回的第一种格式。
     * @param {Object} param -  维度值。例如：{“Year”：“2012”}
     * @returns {GeoGlobe.Layer.WMTS} 正确配置的WMTS图层。 
     * 如果提供了不完整的配置，则会引发错误。 
     * 如果未使用提供的配置创建图层，则返回undefined。
     */
    createLayer: function(capabilities, config) {
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;

        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }

        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                    ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }

        // get the default style for the layer
        var style;
        for (var i=0, ii=layerDef.styles.length; i<ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                            (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
                (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                    GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink, 
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }

        var url;
        if (requestEncoding === "REST" && layerDef.resourceUrls) {
            url = [];
            var resourceUrls = layerDef.resourceUrls,
                resourceUrl;
            for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
                resourceUrl = layerDef.resourceUrls[t];
                if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
                    url.push(resourceUrl.template);
                }
            }
        } else {
            var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
            url = [];
            var constraint;
            for (var i = 0, ii = httpGet.length; i < ii; i++) {
                constraint = httpGet[i].constraints;
                if (!constraint || (constraint && constraint.
                        GetEncoding.allowedValues[requestEncoding])) {
                    url.push(httpGet[i].url);
                }
            }
        }

        resolutions.sort(function(a,b){
            return b-a;
        });
        
        /*var options = GeoGlobe.Util.applyDefaults(config, {
            url: url,
            requestEncoding: requestEncoding,
            name: layerDef.title,
            style: style && style.identifier || "",
            format: format,
            matrixIds: reducedMatrixIds.length ? 
                reducedMatrixIds : matrixSet.matrixIds,
            matrixSet: matrixSet.identifier,
            projection: projection,
            units: units,
            tileFullExtent: matrixSet.bounds,
            dimensions: dimensions,
            params: params,
            resolutions: config.isBaseLayer === false ? undefined :
                resolutions,
            serverResolutions: resolutions,
            minScale: 1/Math.ceil(maxScaleDenominator),
            maxScale: 1/Math.floor(minScaleDenominator)
        });*/
		var wmts_url = "";
		var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
		if(url[0].endsWith("?")){
			wmts_url = url[0] + param;
		}else{
			wmts_url = url[0] + "?" + param;
		}
        //var wmts_url = url+"?SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layers[0].identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format; 
        var options= GeoGlobe.Util.applyDefaults(config, {
        	id:layerDef.identifier,
            url:[wmts_url]
        });
        //var wmtsLayer = new GeoGlobe.Layer.WMTS(options);
		var wmtsLayer = {
            id:options.id,
            layer:{
                "id": options.id,
                "type": "raster",
                "source":options.id
            },
            source:{
                "type": "raster",
                "tiles": options.url,
                "tileSize": 256
            }
        };
        wmtsLayer.matrixSet = matrixSet;
        wmtsLayer.identifier = layerDef.identifier;
        wmtsLayer.bounds = layerDef.bounds;
        return wmtsLayer;
    },

    CLASS_NAME: "GeoGlobe.Format.WMTSCapabilities"
});

/**
 * @class  GeoGlobe.Format.WMTSCapabilities.v1_0_0
 * @classdesc 阅读网络切片地图服务功能版本1.0.0。
 */


GeoGlobe.Format.WMTSCapabilities.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.OWSCommon.v1_1_0, {
        
    /**
     * version- The parser version ("1.0.0").
     * @memberof  GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @type {String}
     * @private
     */
    version: "1.0.0",

    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wmts: "http://www.opengis.net/wmts/1.0",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * yx- Members in the yx object are used to determine if a CRS URN
     *     corresponds to a CRS with y,x axis order.  Member names are CRS URNs
     *     and values are boolean.  Defaults come from the
     *     GeoGlobe.Format.WMTSCapabilities prototype.
     * @memberof GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @type {null}
     * @private
     */
    yx: null,

    /**
     * defaultPrefix- The default namespace alias for creating element nodes.
     * @memberof GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @type {String}
     * @private
     */
    defaultPrefix: "wmts",

    /**
     * 为网络切片地图服务功能版本1.0.0创建一个新的分析器。
     * @memberof  GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
        this.options = options;
        var yx = GeoGlobe.Util.extend(
            {}, GeoGlobe.Format.WMTSCapabilities.prototype.yx
        );
        this.yx = GeoGlobe.Util.extend(yx, this.yx);
    },

    /**
     * 从字符串中读取能力数据，并返回关于网络切片地图服务的信息。
     * @memberof  GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @param {String} or {DOMElement}data -  数据读取/解析。
     * @returns {Object} 有关SOS服务的信息。
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        capabilities.version = this.version;
        return capabilities;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @type {null}
     * @private
     *
     */
    readers: {        
        "wmts": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Contents": function(node, obj) {
                obj.contents = {};                
                obj.contents.layers = [];
                obj.contents.tileMatrixSets = {};                
                this.readChildNodes(node, obj.contents);
            },
            "Layer": function(node, obj) {
                var layer = {
                    styles: [],
                    formats: [],
                    dimensions: [],
                    tileMatrixSetLinks: []
                };
                this.readChildNodes(node, layer);
                obj.layers.push(layer);
            },
            "Style": function(node, obj) {
                var style = {};
                style.isDefault = (node.getAttribute("isDefault") === "true");
                this.readChildNodes(node, style);
                obj.styles.push(style);
            },
            "Format": function(node, obj) {
                obj.formats.push(this.getChildValue(node)); 
            },
            "TileMatrixSetLink": function(node, obj) {
                var tileMatrixSetLink = {};
                this.readChildNodes(node, tileMatrixSetLink);
                obj.tileMatrixSetLinks.push(tileMatrixSetLink);
            },
            "TileMatrixSet": function(node, obj) {
                // node could be child of wmts:Contents or wmts:TileMatrixSetLink
                // duck type wmts:Contents by looking for layers
                if (obj.layers) {
                    // TileMatrixSet as object type in schema
                    var tileMatrixSet = {
                        matrixIds: []
                    };
                    this.readChildNodes(node, tileMatrixSet);
                    obj.tileMatrixSets[tileMatrixSet.identifier] = tileMatrixSet;
                } else {
                    // TileMatrixSet as string type in schema
                    obj.tileMatrixSet = this.getChildValue(node);
                }
            },
            "TileMatrixSetLimits": function(node, obj) {
                obj.tileMatrixSetLimits = [];
                this.readChildNodes(node, obj);
            },
            "TileMatrixLimits": function(node, obj) {
                var tileMatrixLimits = {};
                this.readChildNodes(node, tileMatrixLimits);
                obj.tileMatrixSetLimits.push(tileMatrixLimits);
            },
            "MinTileRow": function(node, obj) {
                obj.minTileRow = parseInt(this.getChildValue(node)); 
            },
            "MaxTileRow": function(node, obj) {
                obj.maxTileRow = parseInt(this.getChildValue(node)); 
            },
            "MinTileCol": function(node, obj) {
                obj.minTileCol = parseInt(this.getChildValue(node)); 
            },
            "MaxTileCol": function(node, obj) {
                obj.maxTileCol = parseInt(this.getChildValue(node)); 
            },
            "TileMatrix": function(node, obj) {
                // node could be child of wmts:TileMatrixSet or wmts:TileMatrixLimits
                if (obj.identifier) {
                    // node is child of wmts:TileMatrixSet
                    var tileMatrix = {
                        supportedCRS: obj.supportedCRS
                    };
                    this.readChildNodes(node, tileMatrix);
                    obj.matrixIds.push(tileMatrix);
                } else {
                    obj.tileMatrix = this.getChildValue(node);
                }
            },
            "ScaleDenominator": function(node, obj) {
                obj.scaleDenominator = parseFloat(this.getChildValue(node)); 
            },
            "TopLeftCorner": function(node, obj) {                
                var topLeftCorner = this.getChildValue(node);
                var coords = topLeftCorner.split(" ");
                // decide on axis order for the given CRS
                var yx;
                if (obj.supportedCRS) {
                    // extract out version from URN
                    var crs = obj.supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):.+:(\w+)$/, 
                        "urn:ogc:def:crs:$1::$2"
                    );
                    yx = !!this.yx[crs];
                }
                if (yx) {
                    obj.topLeftCorner = new GeoGlobe.LngLat(
                        coords[1], coords[0]
                    );
                } else {
                    obj.topLeftCorner = new GeoGlobe.LngLat(
                        coords[0], coords[1]
                    );
                }
            },
            "TileWidth": function(node, obj) {
                obj.tileWidth = parseInt(this.getChildValue(node)); 
            },
            "TileHeight": function(node, obj) {
                obj.tileHeight = parseInt(this.getChildValue(node)); 
            },
            "MatrixWidth": function(node, obj) {
                obj.matrixWidth = parseInt(this.getChildValue(node)); 
            },
            "MatrixHeight": function(node, obj) {
                obj.matrixHeight = parseInt(this.getChildValue(node)); 
            },
            "ResourceURL": function(node, obj) {
                obj.resourceUrl = obj.resourceUrl || {};
                var resourceType = node.getAttribute("resourceType");
                if (!obj.resourceUrls) {
                    obj.resourceUrls = [];
                }
                var resourceUrl = obj.resourceUrl[resourceType] = {
                    format: node.getAttribute("format"),
                    template: node.getAttribute("template"),
                    resourceType: resourceType
                };
                obj.resourceUrls.push(resourceUrl);
            },
            "LegendURL": function(node, obj) {
                obj.legends = obj.legends || [];
                var legend = {
                    format: node.getAttribute("format"),
                    href: node.getAttribute("xlink:href")
                };
                var width = node.getAttribute("width"),
                    height = node.getAttribute("height"),
                    minScaleDenominator = node.getAttribute("minScaleDenominator"),
                    maxScaleDenominator = node.getAttribute("maxScaleDenominator");
                if (width !== null) {
                    legend.width = parseInt(width);
                }
                if (height !== null) {
                    legend.height = parseInt(height);
                }
                if (minScaleDenominator !== null) {
                    legend.minScaleDenominator = parseInt(minScaleDenominator);
                }
                if (maxScaleDenominator !== null) {
                    legend.maxScaleDenominator = parseInt(maxScaleDenominator);
                }
                obj.legends.push(legend);
            },
            "InfoFormat": function(node, obj) {
                obj.infoFormats = obj.infoFormats || [];
                obj.infoFormats.push(this.getChildValue(node));
            },
            // not used for now, can be added in the future though
            /*"Themes": function(node, obj) {
                obj.themes = [];
                this.readChildNodes(node, obj.themes);
            },
            "Theme": function(node, obj) {
                var theme = {};                
                this.readChildNodes(node, theme);
                obj.push(theme);
            },*/
            "WSDL": function(node, obj) {
                obj.wsdl = {};
                obj.wsdl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <WSDL> element                
            },
            "ServiceMetadataURL": function(node, obj) {
                obj.serviceMetadataUrl = {};
                obj.serviceMetadataUrl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <ServiceMetadataURL> element                
            },
            "Dimension": function(node, obj) {
                var dimension = {values: []};
                this.readChildNodes(node, dimension);
                obj.dimensions.push(dimension);
            },
            "Default": function(node, obj) {
                obj["default"] = this.getChildValue(node);
            },
            "Value": function(node, obj) {
                obj.values.push(this.getChildValue(node));
            }
        },
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "GeoGlobe.Format.WMTSCapabilities.v1_0_0" 

});

/**
 * @class GeoGlobe.Format.VTSCapabilities
 * @classdesc 阅读矢量瓦片服务功能。
 * @returns {Object} 有关矢量瓦片服务的功能信息
 */
GeoGlobe.Format.VTSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {

    /**
     * defaultVersion-如果没有找到版本号， 默认值是“1.0.0”。
     * @memberof GeoGlobe.Format.VTSCapabilities.prototype
     * @type {String}
     */
    defaultVersion: "1.0.0",

    /**
     * yx- yx对象中的成员用于确定CRS URN是否对应于y，x轴顺序的CRS。 
     * 成员名称是CRS URN，值是布尔值。 
     * 默认情况下，假定以下CRS URN与y，x轴顺序对应的CRS：
     * @memberof GeoGlobe.Format.VTSCapabilities.prototype
     * @type {Object}
     */
    yx: {
        "urn:ogc:def:crs:EPSG::4326": true
    },

    /**
     * 为VTS功能创建一个新的分析器。
     * @memberof GeoGlobe.Format.VTSCapabilities.prototype
     * @param {Object}options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     * 从字符串中读取有用数据，并返回有关服务的信息（主要是提供和观察属性）。
     * @memberof GeoGlobe.Format.VTSCapabilities.prototype
     * @param {String} or {DOMElement}data -  数据读取/解析。
     */

    /**
     * 给定一个功能对象创建一个VTS图层。
     * @memberof GeoGlobe.Format.VTSCapabilities.prototype
     * @param {Object} capabilities -该对象从读取调用返回到此格式。
     * @param {Object}config -  图层的配置属性。 如果没有提供，该图层的默认值将适用。
     * @param {String} Required 配置属性：layer - 图层标识符。
     *
     * @param {String} Optional config属性：matrixSet - 矩阵集标识符，如果图层功能中存在多个矩阵集，则为必需。
     * projection - {String}没有指定matrixSet时所需的CRS。例如：“EPSG：3857”。 
     * 如果所需投影不可用，则会抛出错误。
     * @param {String} style   样式的名称
     * @param {String} format 图层的图像格式。 默认是第一个格式在GetCapabilities响应中返回。
     * @param {Object}  dimensions 值例如：{“Year”：“2012”}
     * @returns {GeoGlobe.Layer.VTS} 一个正确配置的VTS图层。如果配置不完整会报错，
     * 如果未使用提供的配置创建图层，则返回undefined.
     */
    createLayer: function(capabilities, config) {
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;

        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }

        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                    ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }

        // get the default style for the layer
        var style;
        for (var i=0, ii=layerDef.styles.length; i<ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                            (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
                (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                    GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink, 
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }

        var url;
        if (requestEncoding === "REST" && layerDef.resourceUrls) {
            url = [];
            var resourceUrls = layerDef.resourceUrls,
                resourceUrl;
            for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
                resourceUrl = layerDef.resourceUrls[t];
                if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
                    url.push(resourceUrl.template);
                }
            }
        } else {
            var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
            url = [];
            var constraint;
            for (var i = 0, ii = httpGet.length; i < ii; i++) {
                constraint = httpGet[i].constraints;
                if (!constraint || (constraint && constraint.
                        GetEncoding.allowedValues[requestEncoding])) {
                    url.push(httpGet[i].url);
                }
            }
        }

        resolutions.sort(function(a,b){
            return b-a;
        });
        
        /*var options = GeoGlobe.Util.applyDefaults(config, {
            url: url,
            requestEncoding: requestEncoding,
            name: layerDef.title,
            style: style && style.identifier || "",
            format: format,
            matrixIds: reducedMatrixIds.length ? 
                reducedMatrixIds : matrixSet.matrixIds,
            matrixSet: matrixSet.identifier,
            projection: projection,
            units: units,
            tileFullExtent: matrixSet.bounds,
            dimensions: dimensions,
            params: params,
            resolutions: config.isBaseLayer === false ? undefined :
                resolutions,
            serverResolutions: resolutions,
            minScale: 1/Math.ceil(maxScaleDenominator),
            maxScale: 1/Math.floor(minScaleDenominator)
        });*/
		var VTS_url = "";
		var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
		if(url[0].endsWith("?")){
            VTS_url = url[0] + param;
		}else{
            VTS_url = url[0] + "?" + param;
		}
        //var wmts_url = url+"?SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layers[0].identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format; 
        var options= GeoGlobe.Util.applyDefaults(config, {
        	id:layerDef.identifier,
            url:[VTS_url]
        });
        var VTSLayer = new GeoGlobe.Layer.VTS(options);
        VTSLayer.matrixSet = matrixSet;
        VTSLayer.identifier = layerDef.identifier;
        VTSLayer.bounds = layerDef.bounds;
        return VTSLayer;
    },

    CLASS_NAME: "GeoGlobe.Format.VTSCapabilities"
});

/**
 * @class  GeoGlobe.Format.VTSCapabilities.v1_0_0
 * @classdesc Read VTS Capabilities version 1.0.0.
 * @private
 */

GeoGlobe.Format.VTSCapabilities.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.OWSCommon.v1_1_0, {
        
    /**
     * version-The parser version ("1.0.0").
     * @memberof  GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @type {String}
     */
    version: "1.0.0",

    /**
     * namespaces-Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wmts: "http://www.opengis.net/wmts/1.0",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * yx- Members in the yx object are used to determine if a CRS URN
     *     corresponds to a CRS with y,x axis order.  Member names are CRS URNs
     *     and values are boolean.  Defaults come from the
     *     GeoGlobe.Format.VTSCapabilities prototype.
     * @memberof GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    yx: null,

    /**
     * defaultPrefix- The default namespace alias for creating element nodes.
     * @memberof  GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @type {String}
     * @private
     */
    defaultPrefix: "wmts",

    /**
     * 为VTS功能版本1.0.0创建一个新的解析器。
     * @memberof  GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @classdesc  GeoGlobe.Format.VTSCapabilities.v1_0_0
     * @param {Object} options - 一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
        this.options = options;
        var yx = GeoGlobe.Util.extend(
            {}, GeoGlobe.Format.VTSCapabilities.prototype.yx
        );
        this.yx = GeoGlobe.Util.extend(yx, this.yx);
    },

    /**
     * 从字符串读取能力数据，并返回关于VTS的信息。
     * @memberof  GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @param {String} or {DOMElement} data -数据读取/解析.
     * @returns {Object} 有关SOS服务的信息。
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        capabilities.version = this.version;
        return capabilities;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @type {null}
     * @private
     *
     */
    readers: {        
        "wmts": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Contents": function(node, obj) {
                obj.contents = {};                
                obj.contents.layers = [];
                obj.contents.tileMatrixSets = {};                
                this.readChildNodes(node, obj.contents);
            },
            "Layer": function(node, obj) {
                var layer = {
                    styles: [],
                    formats: [],
                    dimensions: [],
                    tileMatrixSetLinks: []
                };
                this.readChildNodes(node, layer);
                obj.layers.push(layer);
            },
            "Style": function(node, obj) {
                var style = {};
                style.isDefault = (node.getAttribute("isDefault") === "true");
                this.readChildNodes(node, style);
                obj.styles.push(style);
            },
            "Format": function(node, obj) {
                obj.formats.push(this.getChildValue(node)); 
            },
            "TileMatrixSetLink": function(node, obj) {
                var tileMatrixSetLink = {};
                this.readChildNodes(node, tileMatrixSetLink);
                obj.tileMatrixSetLinks.push(tileMatrixSetLink);
            },
            "TileMatrixSet": function(node, obj) {
                // node could be child of VTS:Contents or VTS:TileMatrixSetLink
                // duck type VTS:Contents by looking for layers
                if (obj.layers) {
                    // TileMatrixSet as object type in schema
                    var tileMatrixSet = {
                        matrixIds: []
                    };
                    this.readChildNodes(node, tileMatrixSet);
                    obj.tileMatrixSets[tileMatrixSet.identifier] = tileMatrixSet;
                } else {
                    // TileMatrixSet as string type in schema
                    obj.tileMatrixSet = this.getChildValue(node);
                }
            },
            "TileMatrixSetLimits": function(node, obj) {
                obj.tileMatrixSetLimits = [];
                this.readChildNodes(node, obj);
            },
            "TileMatrixLimits": function(node, obj) {
                var tileMatrixLimits = {};
                this.readChildNodes(node, tileMatrixLimits);
                obj.tileMatrixSetLimits.push(tileMatrixLimits);
            },
            "MinTileRow": function(node, obj) {
                obj.minTileRow = parseInt(this.getChildValue(node)); 
            },
            "MaxTileRow": function(node, obj) {
                obj.maxTileRow = parseInt(this.getChildValue(node)); 
            },
            "MinTileCol": function(node, obj) {
                obj.minTileCol = parseInt(this.getChildValue(node)); 
            },
            "MaxTileCol": function(node, obj) {
                obj.maxTileCol = parseInt(this.getChildValue(node)); 
            },
            "TileMatrix": function(node, obj) {
                // node could be child of VTS:TileMatrixSet or VTS:TileMatrixLimits
                if (obj.identifier) {
                    // node is child of VTS:TileMatrixSet
                    var tileMatrix = {
                        supportedCRS: obj.supportedCRS
                    };
                    this.readChildNodes(node, tileMatrix);
                    obj.matrixIds.push(tileMatrix);
                } else {
                    obj.tileMatrix = this.getChildValue(node);
                }
            },
            "ScaleDenominator": function(node, obj) {
                obj.scaleDenominator = parseFloat(this.getChildValue(node)); 
            },
            "TopLeftCorner": function(node, obj) {                
                var topLeftCorner = this.getChildValue(node);
                var coords = topLeftCorner.split(" ");
                // decide on axis order for the given CRS
                var yx;
                if (obj.supportedCRS) {
                    // extract out version from URN
                    var crs = obj.supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):.+:(\w+)$/, 
                        "urn:ogc:def:crs:$1::$2"
                    );
                    yx = !!this.yx[crs];
                }
                if (yx) {
                    obj.topLeftCorner = new GeoGlobe.LngLat(
                        coords[1], coords[0]
                    );
                } else {
                    obj.topLeftCorner = new GeoGlobe.LngLat(
                        coords[0], coords[1]
                    );
                }
            },
            "TileWidth": function(node, obj) {
                obj.tileWidth = parseInt(this.getChildValue(node)); 
            },
            "TileHeight": function(node, obj) {
                obj.tileHeight = parseInt(this.getChildValue(node)); 
            },
            "MatrixWidth": function(node, obj) {
                obj.matrixWidth = parseInt(this.getChildValue(node)); 
            },
            "MatrixHeight": function(node, obj) {
                obj.matrixHeight = parseInt(this.getChildValue(node)); 
            },
            "ResourceURL": function(node, obj) {
                obj.resourceUrl = obj.resourceUrl || {};
                var resourceType = node.getAttribute("resourceType");
                if (!obj.resourceUrls) {
                    obj.resourceUrls = [];
                }
                var resourceUrl = obj.resourceUrl[resourceType] = {
                    format: node.getAttribute("format"),
                    template: node.getAttribute("template"),
                    resourceType: resourceType
                };
                obj.resourceUrls.push(resourceUrl);
            },
            "LegendURL": function(node, obj) {
                obj.legends = obj.legends || [];
                var legend = {
                    format: node.getAttribute("format"),
                    href: node.getAttribute("xlink:href")
                };
                var width = node.getAttribute("width"),
                    height = node.getAttribute("height"),
                    minScaleDenominator = node.getAttribute("minScaleDenominator"),
                    maxScaleDenominator = node.getAttribute("maxScaleDenominator");
                if (width !== null) {
                    legend.width = parseInt(width);
                }
                if (height !== null) {
                    legend.height = parseInt(height);
                }
                if (minScaleDenominator !== null) {
                    legend.minScaleDenominator = parseInt(minScaleDenominator);
                }
                if (maxScaleDenominator !== null) {
                    legend.maxScaleDenominator = parseInt(maxScaleDenominator);
                }
                obj.legends.push(legend);
            },
            "InfoFormat": function(node, obj) {
                obj.infoFormats = obj.infoFormats || [];
                obj.infoFormats.push(this.getChildValue(node));
            },
            // not used for now, can be added in the future though
            /*"Themes": function(node, obj) {
                obj.themes = [];
                this.readChildNodes(node, obj.themes);
            },
            "Theme": function(node, obj) {
                var theme = {};                
                this.readChildNodes(node, theme);
                obj.push(theme);
            },*/
            "WSDL": function(node, obj) {
                obj.wsdl = {};
                obj.wsdl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <WSDL> element                
            },
            "ServiceMetadataURL": function(node, obj) {
                obj.serviceMetadataUrl = {};
                obj.serviceMetadataUrl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <ServiceMetadataURL> element                
            },
            "Dimension": function(node, obj) {
                var dimension = {values: []};
                this.readChildNodes(node, dimension);
                obj.dimensions.push(dimension);
            },
            "Default": function(node, obj) {
                obj["default"] = this.getChildValue(node);
            },
            "Value": function(node, obj) {
                obj.values.push(this.getChildValue(node));
            }
        },
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "GeoGlobe.Format.VTSCapabilities.v1_0_0"

});

/**
 * @class  GeoGlobe.Format.WPSCapabilities
 * @classdesc  获知网络处理服务具有的功能。
 * @returns {Object} 返回网络处理服务具有的功能
 */

GeoGlobe.Format.WPSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     * defaultVersion-如果没有找到版本号， 默认值是“1.0.0”。
     * @memberof  GeoGlobe.Format.WPSCapabilities.prototype
     * @type {String}
     */
    defaultVersion: "1.0.0",
    
    /**
     * 为WPS功能创建一个新的解析器。
     * @memberof  GeoGlobe.Format.WPSCapabilities.prototype
     * @param {Object} options -在实例化时所需的选项值。
     */

    /**
     * 读取功能描述信息，并返回有关该服务的信息。
     * @memberof  GeoGlobe.Format.WPSCapabilities.prototype
     * @param {String| DOMElement} data -  数据读取/解析。
     */
    
    CLASS_NAME: "GeoGlobe.Format.WPSCapabilities" 

});

/**
 * @class  GeoGlobe.Format.WPSCapabilities.v1_0_0
 * @classdesc 阅读网络处理服务功能版本1.0.0。
 */

GeoGlobe.Format.WPSCapabilities.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.XML, {

    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof GeoGlobe.Format.WPSCapabilities.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wps: "http://www.opengis.net/wps/1.0.0",
        xlink: "http://www.w3.org/1999/xlink"
    },

    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof GeoGlobe.Format.WPSCapabilities.v1_0_0.prototype
     * @type {null}
     * @private
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },
    
    /**
     * 为网络处理服务功能版本1.0.0创建一个新的分析器。
     * @memberof GeoGlobe.Format.网络处理服务Capabilities.v1_0_0.prototype
     * @param {Object}options - 一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * 从字符串中读取能力数据，并返回关于网络处理服务的信息。
     * @memberof GeoGlobe.Format.WPSCapabilities.v1_0_0.prototype
     * @param {String} or {DOMElement}data - 数据读取/解析。
     * @returns {Object} 有关网络处理服务的信息。
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        return capabilities;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WPSCapabilities.v1_0_0.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wps": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "ProcessOfferings": function(node, obj) {
                obj.processOfferings = {};
                this.readChildNodes(node, obj.processOfferings);
            },
            "Process": function(node, processOfferings) {
                var processVersion = this.getAttributeNS(node, this.namespaces.wps, "processVersion");
                var process = {processVersion: processVersion};
                this.readChildNodes(node, process);
                processOfferings[process.identifier] = process;
            },
            "Languages": function(node, obj) {
                obj.languages = [];
                this.readChildNodes(node, obj.languages);
            },
            "Default": function(node, languages) {
                var language = {isDefault: true};
                this.readChildNodes(node, language);
                languages.push(language);
            },
            "Supported": function(node, languages) {
                var language = {};
                this.readChildNodes(node, language);     
                languages.push(language);
            }
        },
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "GeoGlobe.Format.WPSCapabilities.v1_0_0" 

});

/**
 * @class GeoGlobe.Format.WCSGetCoverage version 1.1.0
 * @classdesc GeoGlobe.Format.WCSGetCoverage version 1.1.0类
 * @private
 */

GeoGlobe.Format.WCSGetCoverage = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wcs: "http://www.opengis.net/wcs/1.1",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @type {null}
     * @private
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @type {String}
     * @private
     */
    VERSION: "1.1.2",

    /**
     * schemaLocation- Schema location
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @type {String}
     * @private
     */
    schemaLocation: "http://www.opengis.net/wcs/1.1 http://schemas.opengis.net/wcs/1.1/wcsGetCoverage.xsd",

    /**
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @classdesc GeoGlobe.Format.WCSGetCoverage
     * @param {Object} options - An optional object whose properties will be set on
     *     this instance.
     * @private
     */

    /**
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @param {Object} options -Optional object.
     * @returns {String} A WCS GetCoverage request XML string.
     * @private
     */
    write: function(options) {
        var node = this.writeNode("wcs:GetCoverage", options);
        this.setAttributeNS(
            node, this.namespaces.xsi,
            "xsi:schemaLocation", this.schemaLocation
        );
        return GeoGlobe.Format.XML.prototype.write.apply(this, [node]);
    }, 

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @type {null}
     * @private
     *
     */
    writers: {
        "wcs": {
            "GetCoverage": function(options) {
                var node = this.createElementNSPlus("wcs:GetCoverage", {
                    attributes: {
                        version: options.version || this.VERSION,
                        service: 'WCS'
                    } 
                }); 
                this.writeNode("ows:Identifier", options.identifier, node);
                this.writeNode("wcs:DomainSubset", options.domainSubset, node);
                this.writeNode("wcs:Output", options.output, node);
                return node; 
            },
            "DomainSubset": function(domainSubset) {
                var node = this.createElementNSPlus("wcs:DomainSubset", {});
                this.writeNode("ows:BoundingBox", domainSubset.boundingBox, node);
                if (domainSubset.temporalSubset) {
                    this.writeNode("wcs:TemporalSubset", domainSubset.temporalSubset, node);
                }
                return node;
            },
            "TemporalSubset": function(temporalSubset) {
                var node = this.createElementNSPlus("wcs:TemporalSubset", {});
                for (var i=0, len=temporalSubset.timePeriods.length; i<len; ++i) {
                    this.writeNode("wcs:TimePeriod", temporalSubset.timePeriods[i], node);
                }
                return node;
            },
            "TimePeriod": function(timePeriod) {
                var node = this.createElementNSPlus("wcs:TimePeriod", {});
                this.writeNode("wcs:BeginPosition", timePeriod.begin, node);
                this.writeNode("wcs:EndPosition", timePeriod.end, node);
                if (timePeriod.resolution) {
                    this.writeNode("wcs:TimeResolution", timePeriod.resolution, node);
                }
                return node;
            },
            "BeginPosition": function(begin) {
                var node = this.createElementNSPlus("wcs:BeginPosition", {
                    value: begin
                });
                return node;
            },
            "EndPosition": function(end) {
                var node = this.createElementNSPlus("wcs:EndPosition", {
                    value: end
                });
                return node;
            },
            "TimeResolution": function(resolution) {
                var node = this.createElementNSPlus("wcs:TimeResolution", {
                    value: resolution
                });
                return node;
            },
            "Output": function(output) {
                var node = this.createElementNSPlus("wcs:Output", {
                    attributes: {
                        format: output.format,
                        store: output.store
                    }
                });
                if (output.gridCRS) {
                    this.writeNode("wcs:GridCRS", output.gridCRS, node);
                }
                return node;
            },
            "GridCRS": function(gridCRS) {
                var node = this.createElementNSPlus("wcs:GridCRS", {});
                this.writeNode("wcs:GridBaseCRS", gridCRS.baseCRS, node);
                if (gridCRS.type) {
                    this.writeNode("wcs:GridType", gridCRS.type, node);
                }
                if (gridCRS.origin) {
                    this.writeNode("wcs:GridOrigin", gridCRS.origin, node);
                }
                this.writeNode("wcs:GridOffsets", gridCRS.offsets, node);
                if (gridCRS.CS) {
                    this.writeNode("wcs:GridCS", gridCRS.CS, node);
                }
                return node;
            },
            "GridBaseCRS": function(baseCRS) {
                return this.createElementNSPlus("wcs:GridBaseCRS", {
                    value: baseCRS
                });
            },
            "GridOrigin": function(origin) {
                return this.createElementNSPlus("wcs:GridOrigin", {
                    value: origin
                });
            },
            "GridType": function(type) {
                return this.createElementNSPlus("wcs:GridType", {
                    value: type
                });
            },
            "GridOffsets": function(offsets) {
                return this.createElementNSPlus("wcs:GridOffsets", {
                    value: offsets
                });
            },
            "GridCS": function(CS) {
                return this.createElementNSPlus("wcs:GridCS", {
                    value: CS
                });
            }
        },
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.writers.ows
    },
    
    CLASS_NAME: "GeoGlobe.Format.WCSGetCoverage" 

});

/**
 * @class GeoGlobe.Format.WPSExecute version 1.0.0
 * @private
 */

GeoGlobe.Format.WPSExecute = GeoGlobe.Class4OL(GeoGlobe.Format.XML,
    GeoGlobe.Format.Filter.v1_1_0, {
    
    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        gml: "http://www.opengis.net/gml",
        wps: "http://www.opengis.net/wps/1.0.0",
        wfs: "http://www.opengis.net/wfs",
        ogc: "http://www.opengis.net/ogc",
        wcs: "http://www.opengis.net/wcs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @type {null}
     * @private
     *
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @type {String}
     * @private
     */
    VERSION: "1.0.0",

    /**
     * schemaLocation- Schema location
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @type {String}
     */
    schemaLocation: "http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd",

    schemaLocationAttr: function(options) {
        return undefined;
    },

    /**
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @param  {Object} options -实例化时所需的选项值。
     */

    /**
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @param {Object} options -  Optional object.
     * @returns {String} An WPS Execute request XML string.
     * @private
     */
    write: function(options) {
        var doc;
        if (GeoGlobe.Format.XML.supportActiveX) {
            doc = new ActiveXObject("Microsoft.XMLDOM");
            this.xmldom = doc;
        } else {
            doc = document.implementation.createDocument("", "", null);
        }
        var node = this.writeNode("wps:Execute", options, doc);
        this.setAttributeNS(
            node, this.namespaces.xsi,
            "xsi:schemaLocation", this.schemaLocation
        );
        return GeoGlobe.Format.XML.prototype.write.apply(this, [node]);
    }, 

    /**
     *  解析WPS执行过程并返回执行结果。
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @param {String} or {DOMElement}data - 数据读取/解析。
     * @returns {Object}
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var info = {};
        this.readNode(data, info);
        return info;
    },

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @type {null}
     * @private
     *
     */
    writers: {
        "wps": {
            "Execute": function(options) {
                var node = this.createElementNSPlus("wps:Execute", {
                    attributes: {
                        version: this.VERSION,
                        service: 'WPS'
                    } 
                }); 
                this.writeNode("ows:Identifier", options.identifier, node);
                this.writeNode("wps:DataInputs", options.dataInputs, node);
                this.writeNode("wps:ResponseForm", options.responseForm, node);
                return node; 
            },
            "ResponseForm": function(responseForm) {
                var node = this.createElementNSPlus("wps:ResponseForm", {});
                if (responseForm.rawDataOutput) {
                    this.writeNode("wps:RawDataOutput", responseForm.rawDataOutput, node);
                }
                if (responseForm.responseDocument) {
                    this.writeNode("wps:ResponseDocument", responseForm.responseDocument, node);
                }
                return node;
            },
            "ResponseDocument": function(responseDocument) {
                var node = this.createElementNSPlus("wps:ResponseDocument", {
                    attributes: {
                        storeExecuteResponse: responseDocument.storeExecuteResponse,
                        lineage: responseDocument.lineage,
                        status: responseDocument.status
                    }
                });
                if (responseDocument.outputs) {
                    for (var i = 0, len = responseDocument.outputs.length; i < len; i++) {
                        this.writeNode("wps:Output", responseDocument.outputs[i], node);
                    }
                }
                return node;
            },
            "Output": function(output) {
                var node = this.createElementNSPlus("wps:Output", {
                    attributes: {
                        asReference: output.asReference,
                        mimeType: output.mimeType,
                        encoding: output.encoding,
                        schema: output.schema
                    }
                });
                this.writeNode("ows:Identifier", output.identifier, node);
                this.writeNode("ows:Title", output.title, node);
                this.writeNode("ows:Abstract", output["abstract"], node);
                return node;
            },
            "RawDataOutput": function(rawDataOutput) {
                var node = this.createElementNSPlus("wps:RawDataOutput", {
                    attributes: {
                        mimeType: rawDataOutput.mimeType,
                        encoding: rawDataOutput.encoding,
                        schema: rawDataOutput.schema
                    }
                });
                this.writeNode("ows:Identifier", rawDataOutput.identifier, node);
                return node;
            },
            "DataInputs": function(dataInputs) {
                var node = this.createElementNSPlus("wps:DataInputs", {});
                for (var i=0, ii=dataInputs.length; i<ii; ++i) {
                    this.writeNode("wps:Input", dataInputs[i], node);
                }
                return node;
            },
            "Input": function(input) {
                var node = this.createElementNSPlus("wps:Input", {});
                this.writeNode("ows:Identifier", input.identifier, node);
                if (input.title) {
                    this.writeNode("ows:Title", input.title, node);
                }
                if (input.data) {
                    this.writeNode("wps:Data", input.data, node);
                }
                if (input.reference) {
                    this.writeNode("wps:Reference", input.reference, node);
                }
                if (input.boundingBoxData) {
                    this.writeNode("wps:BoundingBoxData", input.boundingBoxData, node);
                }
                return node;
            },
            "Data": function(data) {
                var node = this.createElementNSPlus("wps:Data", {});
                if (data.literalData) {
                    this.writeNode("wps:LiteralData", data.literalData, node);
                } else if (data.complexData) {
                    this.writeNode("wps:ComplexData", data.complexData, node);
                } else if (data.boundingBoxData) {
                    this.writeNode("ows:BoundingBox", data.boundingBoxData, node);
                }
                return node;
            },
            "LiteralData": function(literalData) {
                var node = this.createElementNSPlus("wps:LiteralData", {
                    attributes: {
                        uom: literalData.uom
                    },
                    value: literalData.value
                });
                return node;
            },
            "ComplexData": function(complexData) {
                var node = this.createElementNSPlus("wps:ComplexData", {
                    attributes: {
                        mimeType: complexData.mimeType,
                        encoding: complexData.encoding,
                        schema: complexData.schema
                    } 
                });
                var data = complexData.value;
                if (typeof data === "string") {
                    node.appendChild(
                        this.getXMLDoc().createCDATASection(complexData.value)
                    );
                } else {
                    node.appendChild(data);
                }
                return node;
            },
            "Reference": function(reference) {
                var node = this.createElementNSPlus("wps:Reference", {
                    attributes: {
                        mimeType: reference.mimeType,
                        "xlink:href": reference.href,
                        method: reference.method,
                        encoding: reference.encoding,
                        schema: reference.schema
                    }
                });
                if (reference.body) {
                    this.writeNode("wps:Body", reference.body, node);
                }
                return node;
            },
            "BoundingBoxData": function(node, obj) {
                this.writers['ows']['BoundingBox'].apply(this, [node, obj, "wps:BoundingBoxData"]);
            },
            "Body": function(body) {
                var node = this.createElementNSPlus("wps:Body", {});
                if (body.wcs) {
                    this.writeNode("wcs:GetCoverage", body.wcs, node);
                }
                else if (body.wfs) {
                    // GeoGlobe.Format.WFST expects these to be on the 
                    // instance and not in the options
                    this.featureType = body.wfs.featureType;
                    this.version = body.wfs.version;
                    this.writeNode("wfs:GetFeature", body.wfs, node);
                } else {
                    this.writeNode("wps:Execute", body, node);
                }
                return node;                
            }
        },
        "wcs": GeoGlobe.Format.WCSGetCoverage.prototype.writers.wcs,
        "wfs": GeoGlobe.Format.WFST.v1_1_0.prototype.writers.wfs,
        "ogc": GeoGlobe.Format.Filter.v1_1_0.prototype.writers.ogc,
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.writers.ows
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wps": {
            "ExecuteResponse": function(node, obj) {
                obj.executeResponse = {
                    lang: node.getAttribute("lang"),
                    statusLocation: node.getAttribute("statusLocation"),
                    serviceInstance: node.getAttribute("serviceInstance"),
                    service: node.getAttribute("service")
                };
                this.readChildNodes(node, obj.executeResponse);
            },
            "Process":function(node,obj) {
                obj.process = {};
                this.readChildNodes(node, obj.process);
            },
            "Status":function(node,obj) {
                obj.status = {
                    creationTime: node.getAttribute("creationTime")
                };
                this.readChildNodes(node, obj.status);
            },
            "ProcessSucceeded": function(node,obj) {
                obj.processSucceeded = true;
            },
            "ProcessOutputs": function(node, processDescription) {
                processDescription.processOutputs = [];
                this.readChildNodes(node, processDescription.processOutputs);
            },
            "Output": function(node, processOutputs) {
                var output = {};
                this.readChildNodes(node, output);
                processOutputs.push(output);
            },
            "Reference": function(node, output) {
                output.reference = {
                    href: node.getAttribute("href"),
                    mimeType: node.getAttribute("mimeType"),
                    encoding: node.getAttribute("encoding"),
                    schema: node.getAttribute("schema")
                };
            },
            "Data": function(node, output) {
                output.data = {};
                this.readChildNodes(node, output);
            },
            "LiteralData": function(node, output) {
                output.literalData = {
                    dataType: node.getAttribute("dataType"),
                    uom: node.getAttribute("uom"),
                    value: this.getChildValue(node)
                };
            },
            "ComplexData": function(node, output) {
                output.complexData = {
                    mimeType: node.getAttribute("mimeType"),
                    schema: node.getAttribute("schema"),
                    encoding: node.getAttribute("encoding"),
                    value: ""
                };
                
                // try to get *some* value, ignore the empty text values
                if (this.isSimpleContent(node)) {
                    var child;
                    for(child=node.firstChild; child; child=child.nextSibling) {
                        switch(child.nodeType) {
                            case 3: // text node
                            case 4: // cdata section
                                output.complexData.value += child.nodeValue;
                        }
                    }
                }
                else {
                    for(child=node.firstChild; child; child=child.nextSibling) {
                        if (child.nodeType == 1) {
                            output.complexData.value = child;
                        }
                    }
                }

            },
            "BoundingBox": function(node, output) {
                output.boundingBoxData = {
                    dimensions: node.getAttribute("dimensions"),
                    crs: node.getAttribute("crs")
                };
                this.readChildNodes(node, output.boundingBoxData);
            }
        },

        // TODO: we should add Exception parsing here
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },
    
    CLASS_NAME: "GeoGlobe.Format.WPSExecute" 

});

/**
 * @class  GeoGlobe.Format.OGCExceptionReport
 * @classdesc 读取各种OGC服务和版本的异常报告。
 */

GeoGlobe.Format.OGCExceptionReport = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {

    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof GeoGlobe.Format.OGCExceptionReport.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ogc: "http://www.opengis.net/ogc"
    },

    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof GeoGlobe.Format.OGCExceptionReport.prototype
     * @type {null}
     * @private
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * defaultPrefix
     * @memberof GeoGlobe.Format.OGCExceptionReport.prototype
     * @type {null}
     * @private
     */
    defaultPrefix: "ogc",

    /**
     * 为OGC例外报告创建一个新的分析器。
     * @memberof GeoGlobe.Format.OGCExceptionReport.prototype
     * @classdesc GeoGlobe.Format.OGCExceptionReport
     * @param {Object}options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     * 从字符串中读取OGC异常报告数据，并返回一个包含异常信息的对象。
     * @memberof GeoGlobe.Format.OGCExceptionReport.prototype
     * @param {String| DOMElement}data -  数据读取/解析。
     * @returns {Object} 返回异常信息。
     */
    read: function(data) {
        var result;
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var root = data.documentElement;
        var exceptionInfo = {exceptionReport: null}; 
        if (root) {
            this.readChildNodes(data, exceptionInfo);
            if (exceptionInfo.exceptionReport === null) {
                // fall-back to OWSCommon since this is a common output format for exceptions
                // we cannot easily use the ows readers directly since they differ for 1.0 and 1.1
                exceptionInfo = new GeoGlobe.Format.OWSCommon().read(data);
            }
        }
        return exceptionInfo;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     *  @memberof GeoGlobe.Format.OGCExceptionReport.prototype
     *  @private
     */
    readers: {
        "ogc": {
            "ServiceExceptionReport": function(node, obj) {
                obj.exceptionReport = {exceptions: []};
                this.readChildNodes(node, obj.exceptionReport);
            },
            "ServiceException": function(node, exceptionReport) {
                var exception = {
                    code: node.getAttribute("code"),
                    locator: node.getAttribute("locator"),
                    text: this.getChildValue(node)
                };
                exceptionReport.exceptions.push(exception);
            }
        }
    },
    
    CLASS_NAME: "GeoGlobe.Format.OGCExceptionReport"
    
});

/**
 * @class GeoGlobe.Format.QueryStringFilter
 * @classdesc 解析器用于读取查询字符串并创建一个简单的过滤器。
 */

GeoGlobe.Format.QueryStringFilter = (function() {


    var cmpToStr = {};
    cmpToStr[GeoGlobe.Filter.Comparison.EQUAL_TO] = "eq";
    cmpToStr[GeoGlobe.Filter.Comparison.NOT_EQUAL_TO] = "ne";
    cmpToStr[GeoGlobe.Filter.Comparison.LESS_THAN] = "lt";
    cmpToStr[GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO] = "lte";
    cmpToStr[GeoGlobe.Filter.Comparison.GREATER_THAN] = "gt";
    cmpToStr[GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO] = "gte";
    cmpToStr[GeoGlobe.Filter.Comparison.LIKE] = "ilike";

    /**
     * 将值从正则表达式字符串转换为Web服务已知的LIKE / ILIKE字符串。
     * @memberof GeoGlobe.Format.QueryStringFilter.prototype
     * @param {String}value - 正则表达式字符串。
     * @returns {String} 转换后的字符串。
     */
    function regex2value(value) {

        // highly sensitive!! Do not change this without running the
        // Protocol/HTTP.html unit tests

        // convert % to \%
        value = value.replace(/%/g, "\\%");

        // convert \\. to \\_ (\\.* occurences converted later)
        value = value.replace(/\\\\\.(\*)?/g, function($0, $1) {
            return $1 ? $0 : "\\\\_";
        });

        // convert \\.* to \\%
        value = value.replace(/\\\\\.\*/g, "\\\\%");

        // convert . to _ (\. and .* occurences converted later)
        value = value.replace(/(\\)?\.(\*)?/g, function($0, $1, $2) {
            return $1 || $2 ? $0 : "_";
        });

        // convert .* to % (\.* occurnces converted later)
        value = value.replace(/(\\)?\.\*/g, function($0, $1) {
            return $1 ? $0 : "%";
        });

        // convert \. to .
        value = value.replace(/\\\./g, ".");

        // replace \* with * (watching out for \\*)
        value = value.replace(/(\\)?\\\*/g, function($0, $1) {
            return $1 ? $0 : "*";
        });

        return value;
    }
    
    return GeoGlobe.Class4OL(GeoGlobe.Format, {
        
        /**
         * wildcarded.- If true percent signs are added around values
         *     read from LIKE filters, for example if the protocol
         *     read method is passed a LIKE filter whose property
         *     is "foo" and whose value is "bar" the string
         *     "foo__ilike=%bar%" will be sent in the query string;
         *     defaults to false.
         *@type {Boolean}
         *@private
         */
        wildcarded: false,

        /**
         * srsInBBOX - 在BBOX查询字符串参数中包含SRS标识符。
         * 默认为false。 如果为true并且该图层设置了投影对象，则将使用标识投影的第五项序列化任何BBOX滤镜。 
         * 例如。BBOX=-1000，-1000,1000,1000，EPSG：900913
         * @memberof GeoGlobe.Format.QueryStringFilter.prototype
         * @type {Boolean}
         */
        srsInBBOX: false,

        /**
         * 使用查询字符串参数的“简单”过滤器语法序列化GeoGlobe.Filter对象。
         * 该功能必须作为协议实例的一种方法被调用。
         * @memberof GeoGlobe.Format.QueryStringFilter.prototype
         * @param {GeoGlobe.Filter}filter - 过滤器转换.
         * @param {Object} params -  参数对象.
         * @returns {Object} 结果参数对象.
         */
        write: function(filter, params) {
            params = params || {};
            var className = filter.CLASS_NAME;
            var filterType = className.substring(className.lastIndexOf(".") + 1);
            switch (filterType) {
                case "Spatial":
                    switch (filter.type) {
                        case GeoGlobe.Filter.Spatial.BBOX:
                            params.bbox = filter.value.toArray();
                            if (this.srsInBBOX && filter.projection) {
                                params.bbox.push(filter.projection.getCode());
                            }
                            break;
                        case GeoGlobe.Filter.Spatial.DWITHIN:
                            params.tolerance = filter.distance;
                            // no break here
                        case GeoGlobe.Filter.Spatial.WITHIN:
                            params.lon = filter.value.x;
                            params.lat = filter.value.y;
                            break;
                        default:
                            GeoGlobe.Console.warn(
                                "Unknown spatial filter type " + filter.type);
                    }
                    break;
                case "Comparison":
                    var op = cmpToStr[filter.type];
                    if (op !== undefined) {
                        var value = filter.value;
                        if (filter.type == GeoGlobe.Filter.Comparison.LIKE) {
                            value = regex2value(value);
                            if (this.wildcarded) {
                                value = "%" + value + "%";
                            }
                        }
                        params[filter.property + "__" + op] = value;
                        params.queryable = params.queryable || [];
                        params.queryable.push(filter.property);
                    } else {
                        GeoGlobe.Console.warn(
                            "Unknown comparison filter type " + filter.type);
                    }
                    break;
                case "Logical":
                    if (filter.type === GeoGlobe.Filter.Logical.AND) {
                        for (var i=0,len=filter.filters.length; i<len; i++) {
                            params = this.write(filter.filters[i], params);
                        }
                    } else {
                        GeoGlobe.Console.warn(
                            "Unsupported logical filter type " + filter.type);
                    }
                    break;
                default:
                    GeoGlobe.Console.warn("Unknown filter type " + filterType);
            }
            return params;
        },
        
        CLASS_NAME: "GeoGolobe.Format.QueryStringFilter"
        
    });


})();

/**
 * @class GeoGlobe.Format.BusCapabilities
 * @classdesc 公交换乘服务Capabilities操作解析类，继承自GeoGlobe.Format.XML类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 */

GeoGlobe.Format.BusCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML,{
	
    /**
     * 常量"NETWORK_Capabilities" ,根据该服务的getCapabilities请求返回而定。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @type {String}
     */
	tagName: "NETWORK_Capabilities",

	 /**
      * * 解析一个XML串并返回capabilitiesObj｛Object｝对象。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {String} data - 一个XML字符串。
     * @returns {object}- capabilitiesObj
     */
    read: function(data){
		if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
		
		var capabilitiesNode;
		if(data.nodeName != this.tagName){
			capabilitiesNode = data.getElementsByTagName(this.tagName);
		} else {
			capabilitiesNode = [data];
		}
		
		var capabilitiesObj = {};
		if(capabilitiesNode.length > 0){
			this.runChildNodes(capabilitiesObj, capabilitiesNode[0]);
		}
		return capabilitiesObj;
	},


    /**
     * 解析每一个节点字符串并把相对应值赋给传入最终返回的对象obj。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object} obj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     * @param {String} parentPath -解析方法拼去，这里使用"capabilities"。
     */
	runChildNodes: function(obj, node, parentPath) {
        var children = node.childNodes;
        var childNode, processor;
        for(var i=0; i<children.length; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
				if(parentPath){
					processor = this["read_" + parentPath + "_" + childNode.nodeName];
				} else{
					processor = this["read_" + childNode.nodeName];
				}
                
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },

	/**
     * 解析节点Service的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}capabilitiesObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Service: function(capabilitiesObj, node){
		var serviceObj = {};
		this.runChildNodes(serviceObj, node, "Service");
		capabilitiesObj.service = serviceObj;
	},

	/**
     * 解析节点为Name的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}servcieObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Service_Name: function(servcieObj,node){
		var name = this.getChildValue(node);
		if(name) {
            servcieObj.name = name;
        }
	},

	/**
     *  解析节点为Title的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}servcieObj -  最终返回的对象
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Service_Title: function(servcieObj,node){
		var title = this.getChildValue(node);
		if(title) {
            servcieObj.title = title;
        }
	},

	/**
     * 解析节点为Abstract的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}servcieObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Service_Abstract: function(servcieObj,node){
		var serviceAbstract = this.getChildValue(node);
		if(serviceAbstract) {
            servcieObj.serviceAbstract = serviceAbstract;
        }
	},

	/**
     * 解析节点为KeywordList的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object} userScenarioObj -最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Service_KeywordList: function(userScenarioObj,node){
	},

	/**
     * 解析节点为OnlineResource的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object} servcieObj -最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Service_OnlineResource: function(servcieObj,node){
		var onlineResource = this.getChildValue(node);
		if(servcieObj) {
            servcieObj.onlineResource = onlineResource;
        }
	},

	/**
     * 解析节点为Capability的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}capabilitiesObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability: function(capabilitiesObj,node){
		var capaObj = {};
		this.runChildNodes(capaObj, node, "Capability");
		capabilitiesObj.capability = capaObj;
	},

	/**
     *  解析节点为Request的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}｛capaObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request: function(capaObj,node){
		var requestObj = {};
		this.runChildNodes(requestObj, node, "Capability_Request");
		capaObj.request = requestObj;
	},

	/**
     * 解析节点为GetCapabilities的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param  {Object}requestObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_GetCapabilities: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var getCapaObj ={};
		if(httpNode[0]){
			this.runChildNodes(getCapaObj, httpNode[0], "Capability_Request_GetCapabilities_DCPType_HTTP");
		}
		requestObj.getCapabilities = getCapaObj;
		
	},

	/**
     *  解析节点为DCPType_HTTP_Get的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}getCapaObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Capability_Request_GetCapabilities_DCPType_HTTP_Get: function(getCapaObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            getCapaObj.getUrl = getUrl;
        }
	},

	/**
     * 解析节点为DCPType_HTTP_Post的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}getCapaObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Capability_Request_GetCapabilities_DCPType_HTTP_Post: function(getCapaObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            getCapaObj.postUrl = postUrl;
        }
	},
	
	/**
     * 解析节点为queryStation的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}requestObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_queryStation: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryStationObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryStationObj, httpNode[0], "Capability_Request_queryStation_DCPType_HTTP");
		}
		requestObj.queryStation = queryStationObj;
		
	},

	/**
     * 解析节点为DCPType_HTTP_Get的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object} queryStationObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Capability_Request_queryStation_DCPType_HTTP_Get: function(queryStationObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryStationObj.getUrl = getUrl;
        }
	},
	
	read_Capability_Request_queryStation_DCPType_HTTP_Post: function(queryStationObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryStationObj.postUrl = postUrl;
        }
	},

	/**
     * 解析节点为queryLine的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}requestObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_queryLine: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryLineObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryLineObj, httpNode[0], "Capability_Request_queryLine_DCPType_HTTP");
		}
		requestObj.queryLine = queryLineObj;
		
	},

	/**
    * 解析节点为DCPType_HTTP_Get的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}queryLineObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */			
	read_Capability_Request_queryLine_DCPType_HTTP_Get: function(queryLineObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryLineObj.getUrl = getUrl;
        }
	},

	/**
    * 解析节点为DCPType_HTTP_Post的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}queryLineObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_queryLine_DCPType_HTTP_Post: function(queryLineObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryLineObj.postUrl = postUrl;
        }	
	},

	/**
     * 解析节点为queryChange的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object} requestObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_queryChange: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryChangeObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryChangeObj, httpNode[0], "Capability_Request_queryChange_DCPType_HTTP");
		}
		
	},

	/**
     * 解析节点为DCPType_HTTP_Get的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}queryChangeObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_queryChange_DCPType_HTTP_Get: function(queryChangeObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryChangeObj.getUrl = getUrl;
        }
	},

	/**
     * 解析节点为DCPType_HTTP_Post的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param read_Capability_Request_queryChange_DCPType_HTTP_Post
     * @param {Object}queryChangeObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_queryChange_DCPType_HTTP_Post: function(queryChangeObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryChangeObj.postUrl = postUrl;
        }	
	},

	/**
     * 解析节点为Networks的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}capabilitiesObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Networks: function(capabilitiesObj,node){		
		var networkNodes = node.getElementsByTagName("Name");
		var networks = [];
		for(var i=0; i<networkNodes.length; i++){
			var network = this.getChildValue(networkNodes[i]);
			if(network){
				networks.push(network);
			}			
		}
		capabilitiesObj.networks = networks;
	},
	
	CLASS_NAME:"GeoGlobe.Format.BusCapabilities"
});
/**
 * @class GeoGlobe.Format.XML2JSON
 * @classdesc 将可扩展标记语言文件解析成Javascript对象。
 */
GeoGlobe.Format.XML2JSON = GeoGlobe.Class4OL({
	
	/**
     *GeoGlobe.Format.XML2JSON构造函数。
     * @memberof  GeoGlobe.Format.XML2JSON.prototype
	 */
	initialize: function(){
		
	},
	
    /**
     * 将传入的可扩展标记语言字符串解析成Javascript对象并返回。
     * @memberof GeoGlobe.Format.XML2JSON.prototype
	 * @param {String}  xmlcode -XML字符串。
	 */	
	read: function(xmlcode,ignoretags,debug){
		if(!ignoretags){ignoretags=""};
		xmlcode=xmlcode.replace(/\s*\/>/g,'/>');
		xmlcode=xmlcode.replace(/<\?[^>]*>/g,"").replace(/<\![^>]*>/g,"");
		if (!ignoretags.sort){ignoretags=ignoretags.split(",")};
		var x=this.no_fast_endings(xmlcode);
		x=this.attris_to_tags(x);
		x=escape(x);
		x=x.split("%3C").join("<").split("%3E").join(">").split("%3D").join("=").split("%22").join("\"");
		for (var i=0;i<ignoretags.length;i++){
			x=x.replace(new RegExp("<"+ignoretags[i]+">","g"),"*$**"+ignoretags[i]+"**$*");
			x=x.replace(new RegExp("</"+ignoretags[i]+">","g"),"*$***"+ignoretags[i]+"**$*")
		};
		x='<JSONTAGWRAPPER>'+x+'</JSONTAGWRAPPER>';
		this.xmlobject={};
		
		//---------------------修正禁止属性小写后,出现jsontagwrapper变成数组
		var y=this.xml_to_object(x).JSONTAGWRAPPER;
		//var y=this.xml_to_object(x).jsontagwrapper;
		
		if(debug){y=this.show_json_structure(y,debug)};
		return y
	},
	
	xml_to_object:function(xmlcode){
		var x=xmlcode.replace(/<\//g,"?");
		x=x.split("<");
		var y=[];
		var level=0;
		var opentags=[];
		for (var i=1;i<x.length;i++){
			var tagname=x[i].split(">")[0];
			opentags.push(tagname);
			level++
			y.push(level+"<"+x[i].split("?")[0]);
			while(x[i].indexOf("?"+opentags[opentags.length-1]+">")>=0){level--;opentags.pop()}
		};
		var oldniva=-1;
		var objname="this.xmlobject";
		for (var i=0;i<y.length;i++){
			var preeval="";
			var niva=y[i].split("<")[0];
			var tagnamn=y[i].split("<")[1].split(">")[0];
			
			//---------------------修正:禁止将属性和标签统一成小写,并将命名空间的冒号转成下划线
			tagnamn = tagnamn.replace(/%3A/,"_");
			//tagnamn=tagnamn.toLowerCase();
			
			var rest=y[i].split(">")[1];
			if(niva<=oldniva){
				var tabort=oldniva-niva+1;
				for (var j=0;j<tabort;j++){objname=objname.substring(0,objname.lastIndexOf("."))}
			};
			objname+="."+tagnamn;
			var pobject=objname.substring(0,objname.lastIndexOf("."));
			if (eval("typeof "+pobject) != "object"){preeval+=pobject+"={value:"+pobject+"};\n"};
			var objlast=objname.substring(objname.lastIndexOf(".")+1);
			var already=false;
			for (k in eval(pobject)){if(k==objlast){already=true}};
			var onlywhites=true;
			for(var s=0;s<rest.length;s+=3){
				if(rest.charAt(s)!="%"){onlywhites=false}
			};
			if (rest!="" && !onlywhites){
				if(rest/1!=rest){
					rest="'"+rest.replace(/\'/g,"\\'")+"'";
					rest=rest.replace(/\*\$\*\*\*/g,"</");
					rest=rest.replace(/\*\$\*\*/g,"<");
					rest=rest.replace(/\*\*\$\*/g,">")
				}
			} 
			else {rest="{}"};
			if(rest.charAt(0)=="'"){rest='unescape('+rest+')'};
			if (already && !eval(objname+".sort")){preeval+=objname+"=["+objname+"];\n"};
			var before="=";after="";
			if (already){before=".push(";after=")"};
			var toeval=preeval+objname+before+rest+after;
			eval(toeval);
			if(eval(objname+".sort")){objname+="["+eval(objname+".length-1")+"]"};
			oldniva=niva
		};
		return this.xmlobject
	},
	show_json_structure:function(obj,debug,l){
		var x='';
		if (obj.sort){x+="[\n"} else {x+="{\n"};
		for (var i in obj){
			if (!obj.sort){x+=i+":"};
			if (typeof obj[i] == "object"){
				x+=this.show_json_structure(obj[i],false,1)
			}
			else {
				if(typeof obj[i]=="function"){
					var v=obj[i]+"";
					//v=v.replace(/\t/g,"");
					x+=v
				}
				else if(typeof obj[i]!="string"){x+=obj[i]+",\n"}
				else {x+="'"+obj[i].replace(/\'/g,"\\'").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r")+"',\n"}
			}
		};
		if (obj.sort){x+="],\n"} else {x+="},\n"};
		if (!l){
			x=x.substring(0,x.lastIndexOf(","));
			x=x.replace(new RegExp(",\n}","g"),"\n}");
			x=x.replace(new RegExp(",\n]","g"),"\n]");
			var y=x.split("\n");x="";
			var lvl=0;
			for (var i=0;i<y.length;i++){
				if(y[i].indexOf("}")>=0 || y[i].indexOf("]")>=0){lvl--};
				tabs="";for(var j=0;j<lvl;j++){tabs+="\t"};
				x+=tabs+y[i]+"\n";
				if(y[i].indexOf("{")>=0 || y[i].indexOf("[")>=0){lvl++}
			};
			if(debug=="html"){
				x=x.replace(/</g,"&lt;").replace(/>/g,"&gt;");
				x=x.replace(/\n/g,"<BR>").replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;")
			};
			if (debug=="compact"){x=x.replace(/\n/g,"").replace(/\t/g,"")}
		};
		return x
	},
	no_fast_endings:function(x){
		x=x.split("/>");
		for (var i=1;i<x.length;i++){
			var t=x[i-1].substring(x[i-1].lastIndexOf("<")+1).split(" ")[0];
			x[i]="></"+t+">"+x[i]
		}	;
		x=x.join("");
		return x
	},
	attris_to_tags: function(x){
		var d=' ="\''.split("");
		x=x.split(">");
		for (var i=0;i<x.length;i++){
			var temp=x[i].split("<");
			for (var r=0;r<4;r++){temp[0]=temp[0].replace(new RegExp(d[r],"g"),"_jsonconvtemp"+r+"_")};
			if(temp[1]){
				temp[1]=temp[1].replace(/'/g,'"');
				temp[1]=temp[1].split('"');
				for (var j=1;j<temp[1].length;j+=2){
					for (var r=0;r<4;r++){temp[1][j]=temp[1][j].replace(new RegExp(d[r],"g"),"_jsonconvtemp"+r+"_")}
				};
				temp[1]=temp[1].join('"')
			};
			x[i]=temp.join("<")
		};
		x=x.join(">");
		x=x.replace(/ ([^=]*)=([^ |>]*)/g,"><$1>$2</$1");
		x=x.replace(/>"/g,">").replace(/"</g,"<");
		for (var r=0;r<4;r++){x=x.replace(new RegExp("_jsonconvtemp"+r+"_","g"),d[r])}	;
		return x
	},
	
    CLASS_NAME: "GeoGlobe.Format.XML2JSON"
});
/**
 * @class GeoGlobe.Format.CSWGetRecords
 * @classdesc Default version is 2.0.2.
 * @returns {GeoGlobe.Format} 给定版本的CSWGetRecords格式。
 * @private
 */


GeoGlobe.Format.CSWGetRecords = function(options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Format.CSWGetRecords.DEFAULTS
    );
    var cls = GeoGlobe.Format.CSWGetRecords["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported CSWGetRecords version: " + options.version;
    }
    return new cls(options);
};

GeoGlobe.Format.CSWGetRecords.DEFAULTS = {
    "version": "2.0.2"
};

/** Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */



/**
 * @class GeoGlobe.Format.CSWGetRecords.v2_0_2
 * @classdesc   用于创建网络目录服务记录 v2.0.2事务的格式。
 * 使用GeoGlobe.Format.CSWGetRecords.v2_0_2构造函数创建一个新实例。
 *
 * Inherits from:
 *  - GeoGlobe.Format.XML
 */
GeoGlobe.Format.CSWGetRecords.v2_0_2 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * Mapping of namespace aliases to namespace URIs.
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        csw: "http://www.opengis.net/cat/csw/2.0.2",
        dc: "http://purl.org/dc/elements/1.1/",
        dct: "http://purl.org/dc/terms/",
        gmd: "http://www.isotc211.org/2005/gmd",
        geonet: "http://www.fao.org/geonetwork",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    
    /**
     * The default prefix (used by Format.XML).
     *@memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     *@type {String}
     *@private
     */
    defaultPrefix: "csw",
    
    /**
     * CSW version number.
     *@memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     *@type {String}
     *@private
     */
    version: "2.0.2",
    
    /**
     * http://www.opengis.net/cat/csw/2.0.2
     * http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     * @private
     */
    schemaLocation: "http://www.opengis.net/cat/csw/2.0.2 http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd",

    /**
     * GetRecords元素的requestId属性的值。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    requestId: null,

    /**
     * GetRecords元素的resultType属性的值指定GetRecords响应中的结果类型，“hits”是默认值。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    resultType: null,

    /**
     *GetRecords元素的outputFormat属性的值指定GetRecords响应的格式，“application / xml”是默认值。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    outputFormat: null,

    /**
     * GetRecords元素的outputSchema属性的值指定了GetRecords响应的模式。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    outputSchema: null,

    /**
     *GetRecords元素的startPosition属性值指定GetRecords响应的起始位置（偏移+ 1），默认值为1。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    startPosition: null,

    /**
     *GetRecords元素的maxRecords属性值指定GetRecords响应中的最大记录数，默认值为10。
     *@memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     *@type {String}
     */
    maxRecords: null,

    /**
     *csw的值：DistributedSearch元素，用于编写csw：GetRecords文档时使用。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    DistributedSearch: null,

    /**
     *写入csw：GetRecords文档时使用的csw：ResponseHandler元素的值。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    ResponseHandler: null,

    /**
     *当写入csw：GetRecords文档时使用的csw：Query元素的值。
     *@memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     *@type {String}
     */
    Query: null,

    /**

     * Compiled regular expressions for manipulating strings.
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @private
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**

     * 解析和生成CSWGetRecords v2.0.2事务的类。
     *@memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype

     * @param {Object}options -  可选对象的属性将在实例上设置。
     *
     * 有效选项属性（记录为类属性）：
     * - requestId
     * - resultType
     * - outputFormat
     * - outputSchema
     * - startPosition
     * - maxRecords
     * - DistributedSearch
     * - ResponseHandler
     * - Query
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**

     * 解析来自GetRecords请求的响应。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var obj = {};
        this.readNode(data, obj);
        return obj;
    },
    
    /**

     * Contains public functions, grouped by namespace prefix, that will
     * be applied when a namespaced node is found matching the function
     * name.  The function will be applied in the scope of this parser
     * with two arguments: the node being read and a context object passed
     * from the parent.
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @private
     */
    readers: {
        "csw": {
            "GetRecordsResponse": function(node, obj) {
                obj.records = [];
                this.readChildNodes(node, obj);
                var version = this.getAttributeNS(node, "", 'version');
                if (version != "") {
                    obj.version = version;
                }
            },
            "RequestId": function(node, obj) {
                obj.RequestId = this.getChildValue(node);
            },
            "SearchStatus": function(node, obj) {
                obj.SearchStatus = {};
                var timestamp = this.getAttributeNS(node, "", 'timestamp');
                if (timestamp != "") {
                    obj.SearchStatus.timestamp = timestamp;
                }
            },
            "SearchResults": function(node, obj) {
                this.readChildNodes(node, obj);
                var attrs = node.attributes;
                var SearchResults = {};
                for(var i=0, len=attrs.length; i<len; ++i) {
                    if ((attrs[i].name == "numberOfRecordsMatched") ||
                        (attrs[i].name == "numberOfRecordsReturned") ||
                        (attrs[i].name == "nextRecord")) {
                        SearchResults[attrs[i].name] = parseInt(attrs[i].nodeValue);
                    } else {
                        SearchResults[attrs[i].name] = attrs[i].nodeValue;
                    }
                }
                obj.SearchResults = SearchResults;
            },
            "SummaryRecord": function(node, obj) {
                var record = {type: "SummaryRecord"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "BriefRecord": function(node, obj) {
                var record = {type: "BriefRecord"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "DCMIRecord": function(node, obj) {
                var record = {type: "DCMIRecord"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "Record": function(node, obj) {
                var record = {type: "Record"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                obj[name] = this.getChildValue(node);
            }
        },
        "geonet": {
            "info": function(node, obj) {
                var gninfo = {};
                this.readChildNodes(node, gninfo);
                obj.gninfo = gninfo;
            }
        },
        "dc": {
            // audience, contributor, coverage, creator, date, description, format,
            // identifier, language, provenance, publisher, relation, rights,
            // rightsHolder, source, subject, title, type, URI
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(GeoGlobe.Util.isArray(obj[name]))) {
                    obj[name] = [];
                }
                var dc_element = {};
                var attrs = node.attributes;
                for(var i=0, len=attrs.length; i<len; ++i) {
                    dc_element[attrs[i].name] = attrs[i].nodeValue;
                }
                dc_element.value = this.getChildValue(node);
                if (dc_element.value != "") {
                    obj[name].push(dc_element);
                }
            }
        },
        "dct": {
            // abstract, modified, spatial
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(GeoGlobe.Util.isArray(obj[name]))) {
                    obj[name] = [];
                }
                obj[name].push(this.getChildValue(node));
            }
        },
        "ows": GeoGlobe.Util.applyDefaults({
            "BoundingBox": function(node, obj) {
                if (obj.bounds) {
                    obj.BoundingBox = [{crs: obj.projection, value: 
                        [
                            obj.bounds._sw.lng,
                            obj.bounds._sw.lat,
                            obj.bounds._ne.lng,
                            obj.bounds._ne.lat
                    ]
                    }];
                    delete obj.projection;
                    delete obj.bounds;
                }
                GeoGlobe.Format.OWSCommon.v1_0_0.prototype.readers["ows"]["BoundingBox"].apply(
                    this, arguments);
            }
        }, GeoGlobe.Format.OWSCommon.v1_0_0.prototype.readers["ows"])
    },
    
    /**

     * Given an configuration js object, write a CSWGetRecords request. 
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @param {Object}options -  A object mapping the request.
     *
     * @returns {String} A serialized CSWGetRecords request.
     * @private
     */
    write: function(options) {
        var node = this.writeNode("csw:GetRecords", options);
        node.setAttribute("xmlns:gmd", this.namespaces.gmd);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [node]);
    },

    /**

     * As a compliment to the readers property, this structure contains public
     * writing functions grouped by namespace alias and named like the
     * node names they produce.
     * @memberof GeoGlobe.v2_0_2.prototype
     * @private
     */
    writers: {
        "csw": {
            "GetRecords": function(options) {
                if (!options) {
                    options = {};
                }
                var node = this.createElementNSPlus("csw:GetRecords", {
                    attributes: {
                        service: "CSW",
                        version: this.version,
                        requestId: options.requestId || this.requestId,
                        resultType: options.resultType || this.resultType,
                        outputFormat: options.outputFormat || this.outputFormat,
                        outputSchema: options.outputSchema || this.outputSchema,
                        startPosition: options.startPosition || this.startPosition,
                        maxRecords: options.maxRecords || this.maxRecords
                    }
                });
                if (options.DistributedSearch || this.DistributedSearch) {
                    this.writeNode(
                        "csw:DistributedSearch",
                        options.DistributedSearch || this.DistributedSearch,
                        node
                    );
                }
                var ResponseHandler = options.ResponseHandler || this.ResponseHandler;
                if (GeoGlobe.Util.isArray(ResponseHandler) && ResponseHandler.length > 0) {
                    // ResponseHandler must be a non-empty array
                    for(var i=0, len=ResponseHandler.length; i<len; i++) {
                        this.writeNode(
                            "csw:ResponseHandler",
                            ResponseHandler[i],
                            node
                        );
                    }
                }
                this.writeNode("Query", options.Query || this.Query, node);
                return node;
            },
            "DistributedSearch": function(options) {
                var node = this.createElementNSPlus("csw:DistributedSearch", {
                    attributes: {
                        hopCount: options.hopCount
                    }
                });
                return node;
            },
            "ResponseHandler": function(options) {
                var node = this.createElementNSPlus("csw:ResponseHandler", {
                    value: options.value
                });
                return node;
            },
            "Query": function(options) {
                if (!options) {
                    options = {};
                }
                var node = this.createElementNSPlus("csw:Query", {
                    attributes: {
                        typeNames: options.typeNames || "csw:Record"
                    }
                });
                var ElementName = options.ElementName;
                if (GeoGlobe.Util.isArray(ElementName) && ElementName.length > 0) {
                    // ElementName must be a non-empty array
                    for(var i=0, len=ElementName.length; i<len; i++) {
                        this.writeNode(
                            "csw:ElementName",
                            ElementName[i],
                            node
                        );
                    }
                } else {
                    this.writeNode(
                        "csw:ElementSetName",
                        options.ElementSetName || {value: 'summary'},
                        node
                    );
                }
                if (options.Constraint) {
                    this.writeNode(
                        "csw:Constraint",
                        options.Constraint,
                        node
                    );
                }
                if (options.SortBy) {
                    this.writeNode(
                        "ogc:SortBy",
                        options.SortBy,
                        node
                    );
                }
                return node;
            },
            "ElementName": function(options) {
                var node = this.createElementNSPlus("csw:ElementName", {
                    value: options.value
                });
                return node;
            },
            "ElementSetName": function(options) {
                var node = this.createElementNSPlus("csw:ElementSetName", {
                    attributes: {
                        typeNames: options.typeNames
                    },
                    value: options.value
                });
                return node;
            },
            "Constraint": function(options) {
                var node = this.createElementNSPlus("csw:Constraint", {
                    attributes: {
                        version: options.version
                    }
                });
                if (options.Filter) {
                    var format = new GeoGlobe.Format.Filter({
                        version: options.version
                    });
                    node.appendChild(format.write(options.Filter));
                } else if (options.CqlText) {
                    var child = this.createElementNSPlus("CqlText", {
                        value: options.CqlText.value
                    });
                    node.appendChild(child);
                }
                return node;
            }
        },
        "ogc": GeoGlobe.Format.Filter.v1_1_0.prototype.writers["ogc"]
    },
   
    CLASS_NAME: "GeoGlobe.Format.CSWGetRecords.v2_0_2"
});

/*
 Copyright 2011-2013 Abdulla Abdurakhmanov
 Original sources are available at https://code.google.com/p/x2js/

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

(function (root, factory) {
	/*//标签式引入，不需要这段判断代码
     if (typeof define === "function" && define.amd) {
         define([], factory);
     } else if (typeof exports === "object") {
         module.exports = factory();
     } else {
         root.X2JS = factory();
     }
	 */
	root.GeoGlobe.Format.X2JS = factory();
	root.GeoGlobe.Format.X2JS.CLASS_NAME = "GeoGlobe.Format.X2JS";
 }(window, function () {
	return function (config) {
		'use strict';
			
		var VERSION = "1.2.0";
		
		config = config || {};
		initConfigDefaults();
		initRequiredPolyfills();
		
		function initConfigDefaults() {
			if(config.escapeMode === undefined) {
				config.escapeMode = true;
			}
			
			config.attributePrefix = config.attributePrefix || "_";
			config.arrayAccessForm = config.arrayAccessForm || "none";
			config.emptyNodeForm = config.emptyNodeForm || "text";		
			
			if(config.enableToStringFunc === undefined) {
				config.enableToStringFunc = true; 
			}
			config.arrayAccessFormPaths = config.arrayAccessFormPaths || []; 
			if(config.skipEmptyTextNodesForObj === undefined) {
				config.skipEmptyTextNodesForObj = true;
			}
			if(config.stripWhitespaces === undefined) {
				config.stripWhitespaces = true;
			}
			config.datetimeAccessFormPaths = config.datetimeAccessFormPaths || [];
	
			if(config.useDoubleQuotes === undefined) {
				config.useDoubleQuotes = false;
			}
			
			config.xmlElementsFilter = config.xmlElementsFilter || [];
			config.jsonPropertiesFilter = config.jsonPropertiesFilter || [];
			
			if(config.keepCData === undefined) {
				config.keepCData = false;
			}
		}
	
		var DOMNodeTypes = {
			ELEMENT_NODE 	   : 1,
			TEXT_NODE    	   : 3,
			CDATA_SECTION_NODE : 4,
			COMMENT_NODE	   : 8,
			DOCUMENT_NODE 	   : 9
		};
		
		function initRequiredPolyfills() {		
		}
		
		function getNodeLocalName( node ) {
			var nodeLocalName = node.localName;			
			if(nodeLocalName == null) // Yeah, this is IE!! 
				nodeLocalName = node.baseName;
			if(nodeLocalName == null || nodeLocalName=="") // =="" is IE too
				nodeLocalName = node.nodeName;
			return nodeLocalName;
		}
		
		function getNodePrefix(node) {
			return node.prefix;
		}
			
		function escapeXmlChars(str) {
			if(typeof(str) == "string")
				return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
			else
				return str;
		}
	
		function unescapeXmlChars(str) {
			return str.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&amp;/g, '&');
		}
		
		function checkInStdFiltersArrayForm(stdFiltersArrayForm, obj, name, path) {
			var idx = 0;
			for(; idx < stdFiltersArrayForm.length; idx++) {
				var filterPath = stdFiltersArrayForm[idx];
				if( typeof filterPath === "string" ) {
					if(filterPath == path)
						break;
				}
				else
				if( filterPath instanceof RegExp) {
					if(filterPath.test(path))
						break;
				}				
				else
				if( typeof filterPath === "function") {
					if(filterPath(obj, name, path))
						break;
				}
			}
			return idx!=stdFiltersArrayForm.length;
		}
		
		function toArrayAccessForm(obj, childName, path) {
			switch(config.arrayAccessForm) {
				case "property":
					if(!(obj[childName] instanceof Array))
						obj[childName+"_asArray"] = [obj[childName]];
					else
						obj[childName+"_asArray"] = obj[childName];
					break;
				/*case "none":
					break;*/
			}
			
			if(!(obj[childName] instanceof Array) && config.arrayAccessFormPaths.length > 0) {
				if(checkInStdFiltersArrayForm(config.arrayAccessFormPaths, obj, childName, path)) {
					obj[childName] = [obj[childName]];
				}			
			}
		}
		
		function fromXmlDateTime(prop) {
			// Implementation based up on http://stackoverflow.com/questions/8178598/xml-datetime-to-javascript-date-object
			// Improved to support full spec and optional parts
			var bits = prop.split(/[-T:+Z]/g);
			
			var d = new Date(bits[0], bits[1]-1, bits[2]);			
			var secondBits = bits[5].split("\.");
			d.setHours(bits[3], bits[4], secondBits[0]);
			if(secondBits.length>1)
				d.setMilliseconds(secondBits[1]);
	
			// Get supplied time zone offset in minutes
			if(bits[6] && bits[7]) {
				var offsetMinutes = bits[6] * 60 + Number(bits[7]);
				var sign = /\d\d-\d\d:\d\d$/.test(prop)? '-' : '+';
	
				// Apply the sign
				offsetMinutes = 0 + (sign == '-'? -1 * offsetMinutes : offsetMinutes);
	
				// Apply offset and local timezone
				d.setMinutes(d.getMinutes() - offsetMinutes - d.getTimezoneOffset())
			}
			else
				if(prop.indexOf("Z", prop.length - 1) !== -1) {
					d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));					
				}
	
			// d is now a local time equivalent to the supplied time
			return d;
		}
		
		function checkFromXmlDateTimePaths(value, childName, fullPath) {
			if(config.datetimeAccessFormPaths.length > 0) {
				var path = fullPath.split("\.#")[0];
				if(checkInStdFiltersArrayForm(config.datetimeAccessFormPaths, value, childName, path)) {
					return fromXmlDateTime(value);
				}
				else
					return value;			
			}
			else
				return value;
		}
		
		function checkXmlElementsFilter(obj, childType, childName, childPath) {
			if( childType == DOMNodeTypes.ELEMENT_NODE && config.xmlElementsFilter.length > 0) {
				return checkInStdFiltersArrayForm(config.xmlElementsFilter, obj, childName, childPath);	
			}
			else
				return true;
		}	
	
		function parseDOMChildren( node, path ) {
			if(node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {
				var result = new Object;
				var nodeChildren = node.childNodes;
				// Alternative for firstElementChild which is not supported in some environments
				for(var cidx=0; cidx <nodeChildren.length; cidx++) {
					var child = nodeChildren.item(cidx);
					if(child.nodeType == DOMNodeTypes.ELEMENT_NODE) {
						var childName = getNodeLocalName(child);
						result[childName] = parseDOMChildren(child, childName);
					}
				}
				return result;
			}
			else
			if(node.nodeType == DOMNodeTypes.ELEMENT_NODE) {
				var result = new Object;
				result.__cnt=0;
				
				var nodeChildren = node.childNodes;
				
				// Children nodes
				for(var cidx=0; cidx <nodeChildren.length; cidx++) {
					var child = nodeChildren.item(cidx); // nodeChildren[cidx];
					var childName = getNodeLocalName(child);
					
					if(child.nodeType!= DOMNodeTypes.COMMENT_NODE) {
						var childPath = path+"."+childName;
						if (checkXmlElementsFilter(result,child.nodeType,childName,childPath)) {
							result.__cnt++;
							if(result[childName] == null) {
								result[childName] = parseDOMChildren(child, childPath);
								toArrayAccessForm(result, childName, childPath);					
							}
							else {
								if(result[childName] != null) {
									if( !(result[childName] instanceof Array)) {
										result[childName] = [result[childName]];
										toArrayAccessForm(result, childName, childPath);
									}
								}
								(result[childName])[result[childName].length] = parseDOMChildren(child, childPath);
							}
						}
					}								
				}
				
				// Attributes
				for(var aidx=0; aidx <node.attributes.length; aidx++) {
					var attr = node.attributes.item(aidx); // [aidx];
					result.__cnt++;
					result[config.attributePrefix+attr.name]=attr.value;
				}
				
				// Node namespace prefix
				var nodePrefix = getNodePrefix(node);
				if(nodePrefix!=null && nodePrefix!="") {
					result.__cnt++;
					result.__prefix=nodePrefix;
				}
				
				if(result["#text"]!=null) {				
					result.__text = result["#text"];
					if(result.__text instanceof Array) {
						result.__text = result.__text.join("\n");
					}
					//if(config.escapeMode)
					//	result.__text = unescapeXmlChars(result.__text);
					if(config.stripWhitespaces)
						result.__text = result.__text.trim();
					delete result["#text"];
					if(config.arrayAccessForm=="property")
						delete result["#text_asArray"];
					result.__text = checkFromXmlDateTimePaths(result.__text, childName, path+"."+childName);
				}
				if(result["#cdata-section"]!=null) {
					result.__cdata = result["#cdata-section"];
					delete result["#cdata-section"];
					if(config.arrayAccessForm=="property")
						delete result["#cdata-section_asArray"];
				}
				
				if( result.__cnt == 0 && config.emptyNodeForm=="text" ) {
					result = '';
				}
				else
				if( result.__cnt == 1 && result.__text!=null  ) {
					result = result.__text;
				}
				else
				if( result.__cnt == 1 && result.__cdata!=null && !config.keepCData  ) {
					result = result.__cdata;
				}			
				else			
				if ( result.__cnt > 1 && result.__text!=null && config.skipEmptyTextNodesForObj) {
					if( (config.stripWhitespaces && result.__text=="") || (result.__text.trim()=="")) {
						delete result.__text;
					}
				}
				delete result.__cnt;			
				
				if( config.enableToStringFunc && (result.__text!=null || result.__cdata!=null )) {
					result.toString = function() {
						return (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');
					};
				}
				
				return result;
			}
			else
			if(node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE) {
				return node.nodeValue;
			}	
		}
		
		function startTag(jsonObj, element, attrList, closed) {
			var resultStr = "<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
			if(attrList!=null) {
				for(var aidx = 0; aidx < attrList.length; aidx++) {
					var attrName = attrList[aidx];
					var attrVal = jsonObj[attrName];
					if(config.escapeMode)
						attrVal=escapeXmlChars(attrVal);
					resultStr+=" "+attrName.substr(config.attributePrefix.length)+"=";
					if(config.useDoubleQuotes)
						resultStr+='"'+attrVal+'"';
					else
						resultStr+="'"+attrVal+"'";
				}
			}
			if(!closed)
				resultStr+=">";
			else
				resultStr+="/>";
			return resultStr;
		}
		
		function endTag(jsonObj,elementName) {
			return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
		}
		
		function endsWith(str, suffix) {
			return str.indexOf(suffix, str.length - suffix.length) !== -1;
		}
		
		function jsonXmlSpecialElem ( jsonObj, jsonObjField ) {
			if((config.arrayAccessForm=="property" && endsWith(jsonObjField.toString(),("_asArray"))) 
					|| jsonObjField.toString().indexOf(config.attributePrefix)==0 
					|| jsonObjField.toString().indexOf("__")==0
					|| (jsonObj[jsonObjField] instanceof Function) )
				return true;
			else
				return false;
		}
		
		function jsonXmlElemCount ( jsonObj ) {
			var elementsCnt = 0;
			if(jsonObj instanceof Object ) {
				for( var it in jsonObj  ) {
					if(jsonXmlSpecialElem ( jsonObj, it) )
						continue;			
					elementsCnt++;
				}
			}
			return elementsCnt;
		}
		
		function checkJsonObjPropertiesFilter(jsonObj, propertyName, jsonObjPath) {
			return config.jsonPropertiesFilter.length == 0
				|| jsonObjPath==""
				|| checkInStdFiltersArrayForm(config.jsonPropertiesFilter, jsonObj, propertyName, jsonObjPath);	
		}
		
		function parseJSONAttributes ( jsonObj ) {
			var attrList = [];
			if(jsonObj instanceof Object ) {
				for( var ait in jsonObj  ) {
					if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf(config.attributePrefix)==0) {
						attrList.push(ait);
					}
				}
			}
			return attrList;
		}
		
		function parseJSONTextAttrs ( jsonTxtObj ) {
			var result ="";
			
			if(jsonTxtObj.__cdata!=null) {										
				result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";					
			}
			
			if(jsonTxtObj.__text!=null) {			
				if(config.escapeMode)
					result+=escapeXmlChars(jsonTxtObj.__text);
				else
					result+=jsonTxtObj.__text;
			}
			return result;
		}
		
		function parseJSONTextObject ( jsonTxtObj ) {
			var result ="";
	
			if( jsonTxtObj instanceof Object ) {
				result+=parseJSONTextAttrs ( jsonTxtObj );
			}
			else
				if(jsonTxtObj!=null) {
					if(config.escapeMode)
						result+=escapeXmlChars(jsonTxtObj);
					else
						result+=jsonTxtObj;
				}
			
			return result;
		}
		
		function getJsonPropertyPath(jsonObjPath, jsonPropName) {
			if (jsonObjPath==="") {
				return jsonPropName;
			}
			else
				return jsonObjPath+"."+jsonPropName;
		}
		
		function parseJSONArray ( jsonArrRoot, jsonArrObj, attrList, jsonObjPath ) {
			var result = ""; 
			if(jsonArrRoot.length == 0) {
				result+=startTag(jsonArrRoot, jsonArrObj, attrList, true);
			}
			else {
				for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
					result+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);
					result+=parseJSONObject(jsonArrRoot[arIdx], getJsonPropertyPath(jsonObjPath,jsonArrObj));
					result+=endTag(jsonArrRoot[arIdx],jsonArrObj);
				}
			}
			return result;
		}
		
		function parseJSONObject ( jsonObj, jsonObjPath ) {
			var result = "";	
	
			var elementsCnt = jsonXmlElemCount ( jsonObj );
			
			if(elementsCnt > 0) {
				for( var it in jsonObj ) {
					
					if(jsonXmlSpecialElem ( jsonObj, it) || (jsonObjPath!="" && !checkJsonObjPropertiesFilter(jsonObj, it, getJsonPropertyPath(jsonObjPath,it))) )
						continue;			
					
					var subObj = jsonObj[it];						
					
					var attrList = parseJSONAttributes( subObj )
					
					if(subObj == null || subObj == undefined) {
						result+=startTag(subObj, it, attrList, true);
					}
					else
					if(subObj instanceof Object) {
						
						if(subObj instanceof Array) {					
							result+=parseJSONArray( subObj, it, attrList, jsonObjPath );					
						}
						else if(subObj instanceof Date) {
							result+=startTag(subObj, it, attrList, false);
							result+=subObj.toISOString();
							result+=endTag(subObj,it);
						}
						else {
							var subObjElementsCnt = jsonXmlElemCount ( subObj );
							if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
								result+=startTag(subObj, it, attrList, false);
								result+=parseJSONObject(subObj, getJsonPropertyPath(jsonObjPath,it));
								result+=endTag(subObj,it);
							}
							else {
								result+=startTag(subObj, it, attrList, true);
							}
						}
					}
					else {
						result+=startTag(subObj, it, attrList, false);
						result+=parseJSONTextObject(subObj);
						result+=endTag(subObj,it);
					}
				}
			}
			result+=parseJSONTextObject(jsonObj);
			
			return result;
		}
		
		this.parseXmlString = function(xmlDocStr) {
			var isIEParser = window.ActiveXObject || "ActiveXObject" in window;
			if (xmlDocStr === undefined) {
				return null;
			}
			var xmlDoc;
			if (window.DOMParser) {
				var parser=new window.DOMParser();			
				var parsererrorNS = null;
				// IE9+ now is here
				if(!isIEParser) {
					try {
						parsererrorNS = parser.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0].namespaceURI;
					}
					catch(err) {					
						parsererrorNS = null;
					}
				}
				try {
					xmlDoc = parser.parseFromString( xmlDocStr, "text/xml" );
					if( parsererrorNS!= null && xmlDoc.getElementsByTagNameNS(parsererrorNS, "parsererror").length > 0) {
						//throw new Error('Error parsing XML: '+xmlDocStr);
						xmlDoc = null;
					}
				}
				catch(err) {
					xmlDoc = null;
				}
			}
			else {
				// IE :(
				if(xmlDocStr.indexOf("<?")==0) {
					xmlDocStr = xmlDocStr.substr( xmlDocStr.indexOf("?>") + 2 );
				}
				xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
				xmlDoc.async="false";
				xmlDoc.loadXML(xmlDocStr);
			}
			return xmlDoc;
		};
		
		this.asArray = function(prop) {
			if (prop === undefined || prop == null)
				return [];
			else
			if(prop instanceof Array)
				return prop;
			else
				return [prop];
		};
		
		this.toXmlDateTime = function(dt) {
			if(dt instanceof Date)
				return dt.toISOString();
			else
			if(typeof(dt) === 'number' )
				return new Date(dt).toISOString();
			else	
				return null;
		};
		
		this.asDateTime = function(prop) {
			if(typeof(prop) == "string") {
				return fromXmlDateTime(prop);
			}
			else
				return prop;
		};
	
		this.xml2json = function (xmlDoc) {
			return parseDOMChildren ( xmlDoc );
		};
		
		this.xml_str2json = function (xmlDocStr) {
			var xmlDoc = this.parseXmlString(xmlDocStr);
			if(xmlDoc!=null)
				return this.xml2json(xmlDoc);
			else
				return null;
		};
	
		this.json2xml_str = function (jsonObj) {
			return parseJSONObject ( jsonObj, "" );
		};
	
		this.json2xml = function (jsonObj) {
			var xmlDocStr = this.json2xml_str (jsonObj);
			return this.parseXmlString(xmlDocStr);
		};
		
		this.getVersion = function () {
			return VERSION;
		};	
	}
}));
/**
 * @class GeoGlobe.Query.Service
 * @classdesc 服务类。本类是服务类的基类，需要由子类去实现。
 *
 */
GeoGlobe.Query.Service = GeoGlobe.Class4OL({
	
	/**
     * 服务名称。
     * @memberof GeoGlobe.Query.Service.prototype
     *  @type {String}
     */
	name: null,
	
	/**
     * 服务地址。
     * @memberof GeoGlobe.Query.Service.prototype
     * @type {String}
     */	
	url: null,
	
	/**
     * 服务版本号。
     * @memberof GeoGlobe.Query.Service.prototype
     * @type {String}
     */		
	version: null,

	
	/**
     * 用户名。
     * @memberof GeoGlobe.Query.Service.prototype
     * @type {String}
     */			
	userid: "test@liferay.com",
	
	/**
     * GeoGlobe.Query.BusQuery类的构造函数。
     * @memberof GeoGlobe.Query.Service.prototype
     * @param {String} name  - 服务名称。
     * @param {String} url  - 服务地址。
     * @param {Object} options  - 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		GeoGlobe.Util.extend(this, options);
	},


	/**
     * 获取服务能力描述信息，由子类实现。
     * @memberof GeoGlobe.Query.Service.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */		
	getCapabilities: function(successFn,failFn){
		//由子类实现
	},

	/**
     * 检查服务是否存在，由子类实现。
     * @memberof GeoGlobe.Query.Service.prototype
     */		
	isExist: function(){
		//由子类实现
	},


	/**
     * 服务操作失败响应回调函数。
     * @memberof GeoGlobe.Query.Service.prototype
     * @param {Object} operate - 失败的操作类型。
     */		
	failFn: function(operate){
		alert("服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" + 
			"请求地址：" + this.url + "\n操作类型：" + operate);
	},

	//将结果解析成XML
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new GeoGlobe.Format.XML();
		return xmlParser.read(doc);
	},
	
	//对返回结果进行检查，是否为错误信息
	_checkIsError: function(xmlString){
		var xmlparser = new GeoGlobe.Format.XML();
		var xml = xmlparser.read(xmlString);
		var exceptions = xml.selectNodes("ServiceExceptionReport");
        if(exceptions.length > 0){
            return this._parseToJSON(xmlString);
        }
        return null;
	},
	
	//对解析后的JSON对象进行判断是否为服务抛出的异常
	_isException:function(result){
		if(result && result.ServiceExceptionReport){
			return true;
		}
		return false;
		
	},
	
	_parseToJSON: function(result){
		var parser = new GeoGlobe.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	CLASS_NAME: "GeoGlobe.Query.Service"
	
});
/**
 * @class GeoGlobe.Query.RouteQuery
 * @classdesc
 * >说明：本类的findRoute方法以及getRouteInfo方法的成功回调中如果包含exceptionInfo节点，则表示服务查询发生异常。
 * >findRoute方法以及getRouteInfo方法成功回调中返回的异常信息包含两个节点（exceptionInfo节点和exceptionCode节点）。
 * >异常信息的数据结构举例：
 * >{
 * >	exceptionInfo:"终点附近无导航链路",
 * >	exceptionCode:"1002"
 * >}
 * >其中exceptionInfo表示异常信息的描述;exceptionCode表示异常编码;异常编码取值说明：
 * >1000：服务逻辑或功能异常。
 * >1001：服务未配置路网数据集。（当服务未配置路网数据集并且请求FindRoute与GetRouteInfo接口将返回此异常）。
 * >1002：导航查询的两点之间无通路。（请求FindRoute接口如果无解决方案则返回此异常）。
 * >1003：无匹配的路段信息。（请求GetRouteInfo接口如果无关联请求路段ID的内容则返回此异常）。
 * >1004：请求参数内容不正确。
 * 本类继承GeoGlobe.Query类。
 *
 */
GeoGlobe.Query.RouteQuery = GeoGlobe.Class4OL(GeoGlobe.Query.Service, {
	
	/**
	 * @Property  _format  - 结果解析器。
     * @memberof GeoGlobe.Query.RouteQuery.prototype
	 * @private
	 */
	_format: null,
	
	/**
     * GeoGlobe.Query.Route类的构造函数。
     * @memberof GeoGlobe.Query.RouteQuery.prototype
     * @param {String} name  -  服务名称。
     * @param {String} url - 服务地址。
     * @param {Object} options - 备用参数，目前暂不使用。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		this._format = new GeoGlobe.Format.RouteQuery();
		GeoGlobe.Util.extend(this, options);
	},
	
	/**
     * 获取服务能力描述信息。
     * @memberof GeoGlobe.Query.RouteQuery.prototype
     * @param {Function} successFn  - 请求成功的回调函数
     * @param {Function} failFn  -  请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn) {
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		GeoGlobe.loadURL(url,params,this,successFn,failFn);
	},
	
	/**
	 * 返回请求起始坐标对应路网模型的导航链路信息。
	 * @memberof GeoGlobe.Query.RouteQuery.prototype
	 * @param {Object} options - 请求参数。
	 * @param {Function} successFn - 请求成功的回调函数。
     * @param {Function} failFn - 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * @param {String}  data   - （必选）路网名称。
	 * @param {String} orig  - （必选）起点坐标。   例如："120,30"。
	 * @param {String} dest    -  （必选）终点坐标。
	 * @param {Number} radius  -(可选) 抓取起点与终点距离有效道路的半径范围，单位为米，默认值为10米。
	 * @param {Number} queryType   - (可选)导航查询类型。0表示最快时间；1表示最短路径，默认为按最短路径查询。
	 * @param {String} midpos   - (可选) 途径点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * @param {String} avoidPos   - (可选) 规避点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * @param {Number} filterRoute  - (可选) 导航查询的途径路段类型过滤，可选值：0 – 不进行过滤；1 – 过滤高速公路；2 – 过滤小路；默认值为0。
	 * @param {Number} resultCount  - (可选) 导航查询返回的最大解决方案数目，参数值必须为正整数，参数默认值为1。
     * 
	 * @example
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new GeoGlobe.Query.Route("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.findRoute({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routes){
	 *
	 *			});
	 *   (end)
	 */
	findRoute: function(options, successFn, failFn) {
		var params = {
			REQUEST: "FindRoute",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
        var required = {
            data: true,
            orig: true,
            dest: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("Missing property '" + prop + "'");
            }
        }
		params.DATA = options.data;
		params.ORIG = options.orig;
		params.DEST = options.dest;
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
	  	if(options.radius !== null && options.radius !== undefined){
            params.RADIUS = options.radius;
        }
        
        if(options.queryType !== null && options.queryType !== undefined){
            params.QUERYTYPE = options.queryType;
        }
		
		if(options.midpos !== null && options.midpos !== undefined){
            params.MIDPOS = options.midpos;
        }
		if(options.avoidPos !== null && options.avoidPos !== undefined){
            params.AVOIDPOS = options.avoidPos;
        }
		if(options.filterRoute !== null && options.filterRoute !== undefined){
            params.FILTERROUTE = options.filterRoute;
        }
		if(options.resultCount !== null && options.resultCount !== undefined){
            params.RESULTCOUNT = options.resultCount;
        }
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
			async:false,
            scope: this,
            success: function(result){
				var routes = this._format.read(result.responseText);
				//处理异常情况，当发生异常时，直接返回异常串
				if(typeof routes.exceptionInfo === "string") {
					 successFn(routes);
					 return;
				}
				var routeInfo = new GeoGlobe.Query.RoutesResult(routes);
				//将路线数据转化为GeoJSON类型
				var routeLine = routeInfo.routes;
				var gj = new GeoGlobe.Format.GeoJSON();
				var gjstr = gj.write(routeLine);
				var j = new GeoGlobe.Format.JSON();
				geojsonRoute = j.read(gjstr);
				routeInfo.geojsonRoute = geojsonRoute;
                successFn(routeInfo);
            },
            failure: failFn
        });
	},
	
	/**
	 *  getRouteInfo  - 返回请求编号查询到路段的详细信息。
	 * @memberof GeoGlobe.Query.RouteQuery.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String} data  - （必选）路网名称
	 * @param {String} id - （必选）查询路段的ID名称，可以有0个或多个，多个ID之间以逗号分隔。
	 *
	 * @example
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new GeoGlobe.Query.Route("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.getRouteInfo({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routeInfo){});
	 *   (end)
	 */
	getRouteInfo: function(options, successFn, failFn) {
		var params = {
			REQUEST: "GetRouteInfo",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
		if(!options.data || !options.id){
            throw "Error!Not data and id for bus query.";
            return;
        }
		params.DATA = options.data;
		params.ID = options.id;
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var routeInfo = this._format.read(result.responseText);
				//处理异常情况，当发生异常时，直接返回异常串
				if(typeof routeInfo.exceptionInfo === "string") {
					 successFn(routeInfo);
					 return;
				}
				routeInfo = new GeoGlobe.Query.RouteInfoResult(routeInfo);
            	successFn(routeInfo);
            },
            failure: failFn
        });
	},	

	CLASS_NAME: "GeoGlobe.Query.RouteQuery"
	
});

/**
 * @class GeoGlobe.Util.Format.RouteQuery
 * @classdesc 路网导航查询结果解析类，本类供内部调用，用户一般无需使用。
 *
 */
GeoGlobe.Format.RouteQuery = new GeoGlobe.Class4OL(GeoGlobe.Format.XML,{

	/**
	 * 构造函数。
	 * @memberof GeoGlobe.Util.Format.RouteQuery.prototype
	 * @param {Object} data  - 服务端生成的原始JSON数据。
	 */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

	/**
	 * 读入服务端响应的XML内容并解析为JSON对象返回。
	 * @memberof GeoGlobe.Util.Format.RouteQuery.prototype
	 * @param  {String} data  - 服务端响应的XML。
	 * 
     * @returns {Object | String}  -  JSON对象
     * 说明：当返回结果为字符串时表示查询发生异常。
     */	
    read: function(data) {
        var result = {};
		var routes = [];
		var dataTemp = data;
        if(typeof data == "string") {
			//调用父类的read方法。将xml串转换为dom对象。
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            routes = [];
			//获得根节点名称
			var elName = GeoGlobe.Format.XML.prototype.getChildEl.apply(this, [data]).nodeName;
			//处理异常情况：
			if("ServiceExceptionReport" === elName) {
				//var serviceException = data.getElementsByTagName("ogc:ServiceException")[0];
				var serviceException = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(data, "*", "ServiceException")[0];
				var text = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [serviceException]);
				var code = serviceException.getAttribute("code");
				return {
					exceptionInfo: text,
					exceptionCode: code
				};
			}
			
			//获取跟节点的子元素
			var nodes = data.getElementsByTagName(elName)[0].childNodes;
			//Todo 如果elName不带前缀的，取整个elName。如果elName带前缀的，则取前缀之后的名称。
			//var nodes = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(data, "*", elName)[0];
			//遍历子节点
            for(var i=0; i<nodes.length; i++){
                var node = nodes[i];
				//获取节点名称
                var nodeName = node.nodeName;
				//判断方法是否存在
                if(this._resultPaser[elName][nodeName]) {
					//使用apply方法改变调用方法的上下文环境
					this._resultPaser[elName][nodeName].apply(this, [node, routes]);
                }
            }
        }
		elName = elName.toLowerCase();
		if("routeinfo" === elName) {
			result["items"] = routes;
		}else {
			result[elName] = routes;
		}
		
        return result;
    },
	
	/**
	 * 查询结果解析器。
     * @memberof GeoGlobe.Util.Format.RouteQuery.prototype
	 * @private
	 */
    _resultPaser: {
		"RouteInfo":{
			"Item": function(node, obj) {
				var nodes = node.childNodes;
				var id = node.getAttribute("id");
	            var item = {};
				if(id) {
					item = {
						id: id
					}
				}
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["RouteInfo"][nodeName]){
						this._resultPaser["RouteInfo"][nodeName].apply(this, [node,item]);
	                }
	            }
				obj.push(item);
			},
	        "Name": function(node, obj){
				//调用父类的getChildValue方法，并且使用本对象的上下文环境。
				var name = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            if(name) {
	                obj.name = name;
	            }
	        },
	        "Toll": function(node, obj){
				var toll = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.toll = toll;
	        },
			"Level": function(node, obj) {
				var level = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
				obj.level = level;
			},
			"Length": function(node, obj) {
				var length = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.length = length;
			},
			"Geometry": function(node, obj) {
				//获取gml:LineString节点对象。
				//var geometryDom = node.getElementsByTagName("gml:LineString")[0];//chrome下解析不到
				var geometryDom = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(node, "*", "LineString")[0];
				if(geometryDom) {
					var text = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [geometryDom]);
					if(typeof text === "string" && text.length > 0) {
						var pointArrStr = text.split(" ");
						var points = [];
						for(var i = 0, len = pointArrStr.length; i < len; i++) {
							var pois = pointArrStr[i].split(",");
							points.push(new GeoGlobe.Geometry.Point(new Number(pois[0]),new Number(pois[1])));
						}
						var lineString = new GeoGlobe.Geometry.LineString(points);
						obj.geometry = lineString;
					}
				}
			},
			"Directions": function(node, obj) {
				obj.directions = [];
				var nodes = node.childNodes;
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["RouteInfo"][nodeName]){
	                    this._resultPaser["RouteInfo"][nodeName](node,obj.directions);
	                }
	            }
			},
			"Direction": function(node, obj) {
				var dir = {};
				var direction = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            dir.direction = direction;
				//获取节点的属性值
				dir.nextID = node.getAttribute("nextID");
				dir.nextItem = node.getAttribute("nextItem");
				obj.push(dir);
			}
			//TODO：是否还有可选属性没有加进来，待查
	    },
		"Routes": {
			"Route": function(node, obj) {
				var nodes = node.childNodes;
	            var route = {};
	            for(var i=0; i<nodes.length; i++){
	                var node = nodes[i];
					var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,route]);
	                }
	            }
				obj.push(route);
			},
			"Item": function(node, obj) {
				if(!GeoGlobe.Util.isArray(obj.items)) {
					obj.items = [];
				}
				var nodes = node.childNodes;
				var id = node.getAttribute("id");
				var item = {};
				if(id) {
					item = {
						id: id
					}
				}
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,item]);
	                }
	            }
				obj.items.push(item);
			},
			"Distance": function(node, obj){
				var distance = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.distance = distance;
			},
			"Name": function(node, obj){
				var name = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            if(name) {
	                obj.name = name;
	            }
	        },
			"Length": function(node, obj) {
				var length = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.length = length;
			},
			"Direction": function(node, obj) {
				var dir = {};
				var direction = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            dir.direction = direction;
				dir.nextID = node.getAttribute("nextID");
				dir.nextItem = node.getAttribute("nextItem");
				obj.direction = dir;
			},
			"Geometry": function(node, obj) {
				//var geometryDom = node.getElementsByTagName("gml:LineString")[0];//chrome下解析不到
				var geometryDom = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(node, "*", "LineString")[0];
				if(geometryDom) {
					var text = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [geometryDom]);
					if(typeof text === "string" && text.length > 0) {
						var pointArrStr = text.split(" ");
						var points = [];
						for(var i = 0, len = pointArrStr.length; i < len; i++) {
							var pois = pointArrStr[i].split(",");
							points.push(new GeoGlobe.Geometry.Point(new Number(pois[0]),new Number(pois[1])));
						}
						var lineString = new GeoGlobe.Geometry.LineString(points);
						obj.geometry = lineString;
					}
				}
			},
			"Duration": function(node, obj) {
				var duration = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.duration = duration;
			},
			"BoundingBox": function(node, obj) {
				var nodes = node.childNodes;
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,obj]);
	                }
	            }
			},
            "LowerCorner": function(node, obj) {
				var str = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]).replace(
                    (/^\s*|\s*$/g), "");
                str = str.replace((/\s*,\s*/g), ",");
                var pointList = str.split(",");
                obj.left = pointList[0];
                obj.bottom = pointList[1];
            },
            "UpperCorner": function(node, obj) {
				var str = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]).replace(
                    (/^\s*|\s*$/g), "");
                str = str.replace((/\s*,\s*/g), ",");
                var pointList = str.split(",");
                obj.right = pointList[0];
                obj.top = pointList[1];
                //obj.bounds = new GeoGlobe.Bounds(obj.left, obj.bottom,obj.right, obj.top);
                obj.bounds = new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(obj.left, obj.bottom),new GeoGlobe.LngLat(obj.right, obj.top));
				//left,bottom,right,top只是临时使用，所以用完后需要清掉。
                delete obj.left;
                delete obj.bottom;
                delete obj.right;
                delete obj.top;
            },
			"Count": function(node, obj) {
				var count = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.count = count;
			}
		}
	}
});
/**
 * @class GeoGlobe.Query.RoutesResult
 * @classdesc 导航链路信息结果对象。结果对象中包含起点到目的地的所有行走方案。
 *
 */
GeoGlobe.Query.RoutesResult = GeoGlobe.Class4OL({
	
	/**
	 * 解析服务返回的XML后，得到的完整JSON对象。
     * @memberof GeoGlobe.Query.RoutesResult.prototype
     * @type {Object}
	 */
	data: null,
	
	/**
	 * 起点到终点的所有行走方案。
     * @memberof GeoGlobe.Query.RoutesResult.prototype
     * @type {Array(GeoGlobe.Query.RouteResult)}
	 */
	routes: null,
	
	/**
     * GeoGlobe.Service.GeoRoutesResult类的构造函数。
     * @memberof GeoGlobe.Query.RoutesResult.prototype
     * @param {Object} data  -  JSON对象
     *
     */
	initialize: function(data) {
		this.routes = [];
		var routes = null;
		if(data && data.routes) {
			this.data = data;
			routes = data.routes;
		}
		if(GeoGlobe.Util.isArray(routes)) {
			for(var i = 0, len = routes.length;i < len; i++) {
				var routeObj = new GeoGlobe.Query.RouteResult();
				for(var route in routes[i]) {
					routeObj[route] = routes[i][route];
				}
				this.routes.push(routeObj);
			}
        }
	},

	CLASS_NAME: "GeoGlobe.Query.RoutesResult"
	
});

/**
 * @class GeoGlobe.Query.RouteResult
 * @classdesc 起点到终点的一条行走方案。
 *
 */
GeoGlobe.Query.RouteResult = GeoGlobe.Class4OL({
	
	/**
	 * 两点间的一条通路的范围
     * @memberof GeoGlobe.Query.RouteResult.prototype
     * @type {GeoGlobe.LngLatBounds}
	 */
	bounds: null,
	
	/**
	 * 导航线路包含的路段总数。
     * @memberof GeoGlobe.Query.RouteResult.prototype
     * @type {Integer}
	 */
	count: null,
	
	/**
	 * 导航线路总里程，单位为米。
     * @memberof GeoGlobe.Query.RouteResult.prototype
     * @type {Number}
	 */
	distance: null,
	
	/**
	 * 导航行驶总时间，单位为分钟。
	 *	（导航行驶总时间根据由总里程换算而来，具体换算公式由服务定制）
     *@memberof GeoGlobe.Query.RouteResult.prototype
     *  @type {Integer}
	 */
	duration: null,
	
	/**
	 * 线路的几何信息。
     * @memberof GeoGlobe.Query.RouteResult.prototype
     * @type {GeoGlobe.Geometry}
	 */
	geometry: null,
	
	/**
	 * 路段元素，可以有零或多个；每个元素包含一个属性id，标识路段的唯一编号；
	 * 	如果路段不在道路上（如起点到某条道路），将不包含路段编号与路段名称。
	 * @memberof GeoGlobe.Query.RouteResult.prototype
     * @type {Array<object>}
     *
     * @example
	 * 数组中的对象结构举例:
	 * {
	 * 	id:"33",
	 * 	length: "161",
	 * 	name: "玉兰路",
	 * 	geometry:值为GeoGlobe.Geometry对象,
	 * 	direction: {
	 * 		text:"4",
	 * 		nextID:"8414",
	 * 		nextItem:"佳园路"
	 * 	}
	 * }
	 * 示例中节点说明：
	 * id: 路段id
	 * name:路段名称
	 * length：路段总长，单位为米
	 * geometry:路段行走路线
	 * text:方位,0代表正西方向，7代表西北方向，4代表正北方向，2代表东北方向，1代表正东方向，3代表东南方向，5代表正南方向，8代表西南方向。
	 * nextID:下一路段编号
	 * nextItem:下一路段名称
	 */
	items: null,
	
	/**
     * GeoGlobe.Query.RouteResult类的构造函数。
     * @memberof GeoGlobe.Query.RouteResult.prototype
     */
	initialize: function() {
		
	},

	CLASS_NAME: "GeoGlobe.Query.RouteResult"
	
});

/**
 * @class GeoGlobe.Query.RouteInfoResult
 * @classdesc 路段信息结果类。用于记录路段所在道路的详细信息。
 *
 */
GeoGlobe.Query.RouteInfoResult = GeoGlobe.Class4OL({
	
	/**
	 * 解析服务返回的XML后，得到的完整JSON对象。
     * @memberof GeoGlobe.Query.RouteInfoResult.prototype
     * @type {Object}
	 */
	data: null,
	
	/**
	 *  路段数组。
     * @memberof GeoGlobe.Query.RouteInfoResult.prototype
	 */
	items: null,
	
	/**
     * GeoGlobe.Query.RouteInfoResult类的构造函数。
     * @memberof GeoGlobe.Query.RouteInfoResult.prototype
     * @param {Object} data  - JSON对象。
     */
	initialize: function(data) {
		this.items = [];
		if(data && data.items) {
			this.data = data;
			var items = data.items;
		}
		if(GeoGlobe.Util.isArray(items)){
			for(var i = 0, len = items.length;i < len; i++) {
				var routeInfoItem = new GeoGlobe.Query.RouteInfoItem();
				for(var route in items[i]) {
					routeInfoItem[route] = items[i][route];
				}
				this.items.push(routeInfoItem);
			}
        }
	},

	CLASS_NAME: "GeoGlobe.Query.RouteInfoResult"
	
});

/**
 * @class GeoGlobe.Query.RouteInfoItem
 * @classdesc 路段对象。从出发点到目的地的路程由一个或多个路段组成。
 */
GeoGlobe.Query.RouteInfoItem = GeoGlobe.Class4OL({
	
	/**
	 * 路段编号。
     * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     * @type {String}
	 */
	id:  null,
	
	/**
	 * 路段名称。
     * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     * @type {String}
	 */
	name: null,
	
	/**
	 *  - 路段收费信息，元素值定义：
	 *	0 – 免费路段；
	 *	1 – 部分收费路段；
	 *	2 – 收费路段。
	 *	（路段收费信息匹配路网数据库的特定属性，如果没有该属性则默认值为“0”免费路段）
     * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     *  @type {Number}
	 */
	toll: null,
	
	/**
	 * 路段行驶的里程，单位为米。
     * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     * @type {Number}
	 */
	length: null,
	
	/**
	 * 线路几何信息
     * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     * @type {GeoGlobe.Geometry}
	 */
	geometry: null,
	
	/**
	 * 道路级别，由路网数据库定义。
	 *	（路段级别一般标识路段的类型；例如路段级别分为1-3级，级别1为普通小路，级别2为城镇公路，级别3为高速公路；如果路网数据库未指定路段级别则默认值为0）
	 * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     *  @type {String}
     */
	level: null,
	
	/**
	 * 路段朝向。
	 * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     *  @type {Array<Object>}
     * @example
	 * 数组中的对象结构举例:
	 * [
	 * 	{
	 *  	nextID: "4211",
	 *  	nextItem: "红钢二街",
	 *  	direction: 1
	 *  }
	 * ]
	 * 
	 * 示例中节点说明：
	 * direction:方位,0代表正西方向，7代表西北方向，4代表正北方向，2代表东北方向，1代表正东方向，3代表东南方向，5代表正南方向，8代表西南方向。
	 * nextID:下一路段编号
	 * nextItem:下一路段名称
	 */
	directions: null,
	
	/**
     * GeoGlobe.Service.GeoRouteInfoItem类的构造函数。
     * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     */
	initialize: function() {
		
	},

	CLASS_NAME: "GeoGlobe.Query.RouteInfoItem"
	
});
/**
 * @class GeoGlobe.Query.BusQuery
 * @classdesc 公交服务类。
 *
 */
GeoGlobe.Query.BusQuery = GeoGlobe.Class4OL(GeoGlobe.Query.Service,{
	
	/**
	 * 网络名称。
     * @memberof GeoGlobe.Query.BusQuery.prototype
	 */
	networkName: null,
	
	/**
	 * 换乘方案信息。
     *  @memberof GeoGlobe.Query.BusQuery.prototype
	 */
	transferScheme: null,
	
	/**
     * GeoGlobe.Query.BusQuery类的构造函数。
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {String} name  - 服务名称。
     * @param {String} url  - 服务地址。
     * @param {Object} options - 实例的选项设置，此参数可选。
     * 
     * @example
     * (code)
     *  var url = "http://map.geostar.com.cn:9001/bus_sdk_new/bus";
     *  var busService = new GeoGlobe.Query.BusQuery("公交服务", url);
     * (end)
     */
	initialize: function(name, url,  options){ 
		this.name = name;
		this.url = url;
		GeoGlobe.Util.extend(this, options);
	},

	/**
     * 获取服务能力描述信息。
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var params = {
           REQUEST: "GetCapabilities"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + this.url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
	
	/**
     * 将向服务发送"GetCapabilities"同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *  @memberof GeoGlobe.Query.BusQuery.prototype
     * @returns {Boolean}  - 服务是否存在。
     */	
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};		
		var xhr = GeoGlobe.Request.GET({
            url: url,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},	
	
	/**
     * 站点查询操作。
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Object} options  - 请求参数。
     * @param {Function} successFn  -  请求成功的回调函数。
     * @param {Function}  failFn  - 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * @param {String} networkName  - (必选) 网络模型名称。
     * @param {String} stationName -  (可选) 站点名称。
     * @param {Integer} stationId - (可选) 站点ID  必须为正整型。
     * @param {Integer} lineId  - (可选) 线路ID。
     * @param {String} lineName  -  (可选) 线路名称。
     * @param {String} coordinate  - (可选) 站点位置  用逗号分隔XY轴坐标如(X,Y)。
     * @param {String} bbox  - (可选) 矩形范围。
	 *     
     * @example
     * (code)
     *  //示例1 根据站点名称查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      stationName: encodeURIComponent('口'),
     *  }
     *  //示例2 根据站点ID查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  //示例3 根据矩形范围查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      bbox : '-1,-1,1,1'
     *  }
     *  (end)
     */	
    queryStation:function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryStation"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }
		
        if(options.stationName !== null && options.stationName !== undefined){
            params.STATIONNAME = options.stationName;
        }
		
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
		
		if(options.lineName !== null && options.lineName !== undefined){
            params.LINENAME = options.lineName;
        }
		
		if(options.coordinate !== null && options.coordinate !== undefined){
        	params.COORDINATE = options.coordinate;
        }   
		
        if(options.bbox !== null && options.bbox !== undefined){
            params.BOX = options.bbox;
        }
        
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });

    },

	/**
     * 线路查询操作。
     *  @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Object} options   -  请求参数。
     * @param  {Function} successFn  - 请求成功的回调函数。
     * @param  {Function} failFn  - 请求失败的回调函数。
     *
	 * options请求参数属性可为:
     * @param {String} networkName - (必选) 网络模型名称。
     * @param {String} lineName  -(可选) 线路名称。
     * @param {Integer} lineId - (可选) 线路ID。
     * @param {String} stationName - (可选) 站点名称。
     * @param {Integer} stationId - (可选) 站点ID。
     * @param {String} coordinate - (可选) 站点位置。
     * @param {String} bbox  - (可选) 矩形范围。
     *
     * @example
     * (code)
     *  //示例1 根据站点名称查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      stationName: encodeURIComponent('口'),
     *  }
     * //示例2 根据站点ID查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     * //示例3 根据路线名称查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      lineName : '4'
     *  }
     *  (end)
     */	
    queryLine: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryLine"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.lineName !== null && options.lineName !== undefined){
            params.LINENAME = options.lineName;
        }
        
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
        
        if(options.stationName !== null && options.stationName !== undefined){
            params.STATIONNAME = options.stationName;
        }    
        
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }    
                
        if(options.coordinate !== null && options.coordinate !== undefined){
            params.COORDINATE = options.coordinate;
        }   
                     
        if(options.bbox !== null && options.bbox !== undefined){
            params.BOX = options.bbox;
        }
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });

    },
    
	/**
     * 公交换乘方案查询操作。
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param  {Object} options  - 请求参数。
     * @param  {Function} successFn  - 请求成功的回调函数。
     * @param  {Function} failFn  - 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * @param {String} networkName  - (必选) 网络模型名称。
     * @param {Integer} startStationId  - (可选) 起始站点ID。
     * @param {Integer} endStationId  - (可选) 终止站点ID。
     * @param {String} startCoordinate  - (可选) 起始站点坐标。
     * @param {String} endCoordinate  - (可选) 起始站点坐标。
     * @param {Integer} maxDepth  - (可选) 最大边数范围,正整型参数,没有则默认值为5。
     * @param {Float} maxCost  - (可选) 最大权值范围,正双精度符点型参数,没有则默认为100.0。
     * @param {Integer} maxSolutions - (可选) 最多解决方案数量,正整型参数,没有则默认为5。
     * @param {String} orderType - (可选) 值为LeastCost时表示较快捷，值为LeastWalk时表示少步行，值为LeastChange时表示少换乘。
     * 
     * @example
     * (code)
     *  busService.queryChange({
     *      networkName: "BusChangeModule",
     *        startStationId: "238",
     *        endStationId: "25",
	 *		  maxDepth:5,
	 *		  maxCost:100.0,
	 *		  maxSolutions:5,
	 *		  //orderType表示换乘的类型。LeastCost表示较快捷，用户还可以选择LeastWalk或LeastChange，LeastWalk表示少步行，值为LeastChange时表示少换乘
	 *		  orderType:"LeastCost" 
     *  })
     *  (end)
     */	
    queryChange: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryChange"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.startStationId !== null && options.startStationId !== undefined){
            params.STARTSTATIONID = options.startStationId;
        }
        
        if(options.endStationId !== null && options.endStationId !== undefined){
            params.ENDSTATIONID = options.endStationId;
        }
		
		if(options.orderType !== null && options.orderType !== undefined){
            params.ORDERTYPE = options.orderType;
        }
        
        if(options.startCoordinate !== null && options.startCoordinate !== undefined){
            params.STARTCOORDINATE = options.startCoordinate;
        }    
        
        if(options.endCoordinate !== null && options.endCoordinate !== undefined){
            params.ENDCOORDINATE = options.endCoordinate;
        }  
		
		if(options.maxDepth !== null && options.maxDepth !== undefined){
            params.MAXDEPTH = options.maxDepth;
        } 
		
		if(options.maxCost !== null && options.maxCost !== undefined){
            params.MAXCOST = options.maxCost;
        }  
		
		if(options.maxSolutions !== null && options.maxSolutions !== undefined){
            params.MAXSOLUTIONS = options.maxSolutions;
        }  
		if (options.ChangeCount !== null && options.ChangeCount !== undefined) {
			params.CHANGECOUNT = options.ChangeCount;
        }
		  
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
            	var  featureCollection = [];
				var resXML;//= result.responseXML;
				if (!result.responseXML.documentElement) {
					resXML = format.read(result.responseText);
				}
				else {         
					resXML = result.responseXML;
				}       

				var docElement = resXML.selectNodes("/Features/FeatureCollection");
				
            	var xmlparser = new GeoGlobe.Format.XML();
				
            	for(var i = 0; i < docElement.length; i++) {
					//获取FeatureCollection元素节点的属性
					var featureCollectionElement = docElement[i];
					var attArray = ['cost','price','walkingDistance','transferTimes'];
					var attributionObj = this._getAttibutionOfNode(featureCollectionElement, attArray);
					
					var str = xmlparser.write(docElement[i]);
					var features = this._parserFeatures(str);
					//features或featureCollectionElement相当于一个FeatureCollection
					features.attributes= attributionObj;
					var featureMember = featureCollectionElement.selectNodes("featureMember");
					for(var j = 0; j < featureMember.length; j++) {
						var road = featureMember[j].selectNodes("Road");
						//线路添加是否步行属性：isOnFoot
						features[j]["isOnFoot"] = road[0].getAttribute("isOnFoot");
					}
	            	featureCollection.push(features);
            	}

                successFn(featureCollection);
            },
            failure: failFn
        });

    },
	
	//根据节点得到节点的属性
	_getAttibutionOfNode: function(node, keyArray) {
		//获取FeatureCollection属性信息
		var fcAttibution = {};
		if(node.tagName){
			for(var i = 0; i < keyArray.length; i++) {
				fcAttibution[keyArray[i]] = node.getAttribute(keyArray[i])
			}
	    }
		return fcAttibution;
	},
   
    _getGeometryType: function(geometry){
        var maping = {
            "GeoGlobe.Geometry.Point": "point",
            "GeoGlobe.Geometry.LineString": "line",
            "GeoGlobe.Geometry.Polygon": "polygon"
        };
        return "polygon";
    },
    
    _pagingToString: function(curPage,maxPerPage){
        maxPerPage = maxPerPage || this.maxPerPage;
        curPage = curPage || 1;
        return "<numPerPage>" + maxPerPage + "</numPerPage>"+
                "<curPage>" + curPage + "</curPage>";
    },
    
    _orderByToString: function(property,type){
        var str = "<orderBy>"+
    	            "<PropertyName>" + property + "</PropertyName>"+
    	        "</orderBy>";
        return property ? str : "";
    },
    
    _geometryToString: function(geometry){
        return '<geometry>'+
                    '<Polygon>'+
                        '<outerBoundaryIs>'+
                            '<LinearRing>'+
                                '<coordinates decimal="." cs="," ts=" ">20,30 21,41 52,42 53,33 20,30</coordinates>'+
                            '</LinearRing>'+
                        '</outerBoundaryIs>'+
                    '</Polygon>'+
                '</geometry>';
    },
    
    _stringToGeometry: function(string){
        return GeoGlobe.Geometry.Polygon.createRegularPolygon(
            new GeoGlobe.Geometry.Point( Math.random()*360 - 160, 
                                           Math.random()*90 - 70 ),
            Math.round(Math.random()*20),
            Math.round(Math.random()*10)
        );
    },
	
    _parserFeatures: function(resultString){
        var parser = new GeoGlobe.Format.GML();
        parser.gmlns = "*";
        var features = parser.read(resultString);
        return features;
    },
	
	// 把节点名称所在的节点外套上<featureMember></featureMember>
	_parserResponseText: function(resultString, nodeName){
		if(nodeName){
			var re1 = new RegExp("<" + nodeName + ">", ["g"]);
	        var re2 = new RegExp("</" + nodeName + ">", ["g"]);
			
	        resultString = resultString.replace(re1, "<featureMember><" + nodeName + ">");
	        resultString = resultString.replace(re2, "</" + nodeName + "></featureMember>");
		}
		
		resultString = resultString.replace(/<gml:LineString>/g,"<gml:LineString><gml:coordinates>");
		resultString = resultString.replace(/<\/gml:LineString>/g,"</gml:coordinates></gml:LineString>");
		resultString = resultString.replace(/<gml:Point>/g,"<gml:Point><gml:coordinates>");
		resultString = resultString.replace(/<\/gml:Point>/g,"</gml:coordinates></gml:Point>");
		return resultString;
	},
	
	_parserFeaturesNew: function(resultString, featureName){
		var parser = new GeoGlobe.Format.GML();
        parser.gmlns = "*";
		if(featureName){
			parser.featureName = featureName;
		}
        var features = parser.read(resultString);
        return features;
    },
    
	_parserSuccessResult: function(result){
		var parser = new GeoGlobe.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new GeoGlobe.Format.XML();
		return xmlParser.read(doc);

	},
	
	_parseToJSON: function(result){
		var parser = new GeoGlobe.Format.XML2JSON();
		return parser.read(result);
	},
	
	/**
	 * 根据始终点的空间坐标或一组起始站点ID和一组终止站点的ID，查询公交换乘的文字信息，必要时也查询出第一条方案的几何信息。（公交2.0）
	 * @memberof GeoGlobe.Query.BusQuery.prototype
	 * @param {Object} options   -  请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String} networkName  - (必选) 网络模型名称。
	 * @param {Integer} transferMode  - (必选) 换乘模式  ,有三种值：0-较快捷   1-少换乘  2-少步行。
	 * @param {String} startInput  - (必选) 始点信息，可以是坐标信息也可也是ID类型（坐标类型,格式为:x y。分隔符为空格符；ID类型,格式为:id,… ,id。分隔符为逗号）。
	 * @param {String} endInput  - (必选)终点信息支持坐标与ID类型:坐标类型,格式为:x y。分隔符为空格符ID类型,格式为:id,… ,id。分隔符为逗号。
	 * @param {Integer} inputMode  - (可选)始终点输入模式,值为0|1|2: 0-坐标,1-车站外部唯一编号,2-车站内部唯一编号（当前服务没有外部唯一编号）。
	 * @param ComputeModel
	 * @param transferSubset
	 * @param existGoTime
	 * @param startTime
	 * @param specificSubset
	 * @param maxSearchDistance
	 * @param computeSort
	 * @param transferPolicy
	 * @param resultSort
	 * @param prioritySubset
	 * @param existAbsolutePriority
	 * @param lagSubset
	 * @param outputPage
	 * @param pageSize
	 * @param changeCount
     * @private
	 */
	queryTransferScheme: function(options, successFn, failFn) {
		var params = {
			request: "QueryTransferScheme",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
		//四个必选参数
		var required = {
			networkName:true,
            transferMode: true,
            startInput: true,
			endInput: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("缺少必选属性：'" + prop + "'。");
            }
        }
		params.networkName = options.networkName;
		
		//这样判断的原因是为了避免0,1这样的值在进行if判断的时候被当做false把参数给过滤掉；""串不需要被过滤，这个已经向服务组确认
        if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		if(options.transferMode !== null && options.transferMode !== undefined) {
			params.TRANSFERMODE = options.transferMode;
        }
		if(options.startInput !== null && options.startInput !== undefined) {
			params.STARTINPUT = options.startInput;
        }
		if(options.endInput !== null && options.endInput !== undefined) {
			params.ENDINPUT = options.endInput;
        }
		if(options.inputMode !== null && options.inputMode !== undefined) {
			params.INPUTMODEL = options.inputMode;
        }
		if (options.ExistGoTime !== null && options.ExistGoTime !== undefined) {
			params.EXISTGOTIME = options.ExistGoTime;
        }
		if (options.StartTime !== null && options.StartTime !== undefined) {
			params.STARTTIME = options.StartTime;
        }
		if (options.MaxSearchDistance !== null && options.MaxSearchDistance !== undefined) {
			params.MAXSEARCHDISTANCE = options.MaxSearchDistance;
		}
		if (options.PrioritySubset !== null && options.PrioritySubset !== undefined) {
			params.PRIORITYSUBSET = options.PrioritySubset;
        }
		if (options.ExistAbsolutePriority !== null && options.ExistAbsolutePriority !== undefined) {
			params.EXISTABSOLUTEPRIORITY = options.ExistAbsolutePriority;
        }
		if (options.LagSubset !== null && options.LagSubset !== undefined) {
			params.LAGSUBSET = options.LagSubset;
        }
		if (options.OutputPage !== null && options.OutputPage !== undefined) {
			params.OUTPUTPAGE = options.OutputPage;
        }
		if (options.PageSize !== null && options.PageSize !== undefined) {
			params.PAGESIZE = options.PageSize;
        }
		if (options.ChangeCount !== null && options.ChangeCount !== undefined) {
			params.CHANGECOUNT = options.ChangeCount;
        }
		
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            async: false,//true表示异步，false表示同步
            scope: this,
            success: GeoGlobe.Function.bind(function(result){
				var resXML = result.responseXML;
                var features = {
                    startPoint: [],
                    transferScheme: [],
                    endPoint: []
                };	
				if(!resXML) {
					successFn(features);
					return features;
				}
				var xmlparser = new GeoGlobe.Format.XML();
				var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
				//没有查询到数据的情况
				if(errorTemp && errorTemp.length > 0) {
					successFn(features);
					return features;
				}
				
				var element = resXML.selectNodes("/QueryTransferSchemeResponse");	
				var elementXMLStr = xmlparser.write(element[0]);
				// XML解析成json对象
				var jsonObj = this._parseToJSON(elementXMLStr);
				var startPoint = jsonObj.QueryTransferSchemeResponse.StartPoint;
				if (!GeoGlobe.Util.isArray(startPoint)) {
		            startPoint = [startPoint];
		        }
				var endPoint = jsonObj.QueryTransferSchemeResponse.EndPoint;
				if (!GeoGlobe.Util.isArray(endPoint)) {
		            endPoint = [endPoint];
		        }
				var transferScheme = jsonObj.QueryTransferSchemeResponse.TransferScheme;
				
				// 起点要素
                var startPointGeometry = this._getPointGeometryByGMLPointStr(startPoint[0].Geometry.gml_Point);
            	var startPointFeature = new GeoGlobe.Feature(startPointGeometry);
				// 终点要素
                var endPointGeometry = this._getPointGeometryByGMLPointStr(endPoint[0].Geometry.gml_Point);
            	var endPointFeature = new GeoGlobe.Feature(endPointGeometry);
				// 换乘要素
				var transferSchemeFeatures = this._parserTransferScheme(transferScheme);
				
                features = {
                    startPoint: startPointFeature,
                    transferScheme: transferSchemeFeatures,
                    endPoint: endPointFeature
                };
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	// 解析换乘要素
    _parserTransferScheme: function(transferSchemeObjs){
		if (!GeoGlobe.Util.isArray(transferSchemeObjs)) {
            transferSchemeObjs = [transferSchemeObjs];
        }
        var transferSchemeFeatures = new Array();
        for (var i = 0; i < transferSchemeObjs.length; i++) {
			var transferSchemeObj = transferSchemeObjs[i];
			// 解析片段信息
			var SectionInfo = this._parserSectionInfo(transferSchemeObj.SectionInfo);
			// 解析片段步行
			var SectionRoutingFeatures = this._parserSectionRouting(transferSchemeObj.SectionRouting);
            
			var transferSchemeFeature = {
                Cost: transferSchemeObjs[i].Cost,
                SectionInfo: SectionInfo,
                SectionRouting: SectionRoutingFeatures,
                TotalDistance: transferSchemeObjs[i].TotalDistance,
                TransferCount: transferSchemeObjs[i].TransferCount
            };
            transferSchemeFeatures.push(transferSchemeFeature);
        }
        return transferSchemeFeatures;
    },
	
	// 解析片段信息
    _parserSectionInfo: function(sectionInfoObjs){
		if (!GeoGlobe.Util.isArray(sectionInfoObjs)) {
            sectionInfoObjs = [sectionInfoObjs];
        }
		var sectionInfos = new Array();
		for (var i = 0; i < sectionInfoObjs.length; i++) {
			
			// 上车点要素
			var fromStationFeature = this._getPointFeatureByObj(sectionInfoObjs[i].FromStation);
			if (sectionInfoObjs[i].FromStation.PassagewayRouting) {
                var passagewayRoutingFeature = this._getPointFeatureByObj(sectionInfoObjs[i].FromStation.PassagewayRouting);
				if(passagewayRoutingFeature.SectionRouting){
                    passagewayRoutingFeature.attributes.SectionRouting = passagewayRoutingFeature.data.SectionRouting = this._parserSectionRouting(passagewayRoutingFeature.SectionRouting);
				}
                fromStationFeature.attributes.PassagewayRouting = fromStationFeature.data.PassagewayRouting = passagewayRoutingFeature;
            }
			
			// 下车点要素
			var toStationFeature = this._getPointFeatureByObj(sectionInfoObjs[i].ToStation);
			if (sectionInfoObjs[i].ToStation.PassagewayRouting) {
                var passagewayRoutingFeature = this._getPointFeatureByObj(sectionInfoObjs[i].ToStation.PassagewayRouting);
                if(passagewayRoutingFeature.SectionRouting){
                    passagewayRoutingFeature.attributes.SectionRouting = passagewayRoutingFeature.data.SectionRouting = this._parserSectionRouting(passagewayRoutingFeature.SectionRouting);
				}
				toStationFeature.attributes.PassagewayRouting = toStationFeature.data.PassagewayRouting = passagewayRoutingFeature;
            }
			
			// 线路要素
			var sectionLine = this._parserSectionLines(sectionInfoObjs[i].SectionLines.SectionLine);
			var sectionRouting = this._parserSectionRouting(sectionInfoObjs[i].SectionRouting);
			
			sectionInfos.push({
				FromStation: fromStationFeature,
				SectionLine: sectionLine,
				ToStation: toStationFeature,
				SectionRouting: sectionRouting
			});
		}
		return sectionInfos;
	},
	
	// 解析片段信息内的片段线路
    _parserSectionLines: function(sectionLineObjs){
        if (!GeoGlobe.Util.isArray(sectionLineObjs)) {
            sectionLineObjs = [sectionLineObjs];
        }
		var sectionLineFeatures = new Array();
		for (var i = 0; i < sectionLineObjs.length; i++) {
            var sectionLineFeature = new GeoGlobe.Feature(null, sectionLineObjs[i]);
			sectionLineFeatures.push(sectionLineFeature);
		}
		return sectionLineFeatures;
	},
	
	// 解析片段步行
    _parserSectionRouting: function(sectionRoutingObjs){
		// TODO
        if (!GeoGlobe.Util.isArray(sectionRoutingObjs)) {
            sectionRoutingObjs = [sectionRoutingObjs];
        }
		var sectionRoutingFeatures = new Array();
		for (var i = 0; i < sectionRoutingObjs.length; i++) {
			sectionRoutingFeatures.push(sectionRoutingObjs[i]);
		}
		return sectionRoutingFeatures;
	},
	
	// -----根据点串得到点对象
	_getPointGeometryByGMLPointStr: function(pointStr) {
		var pointArr = pointStr.split(",");
		var point = new GeoGlobe.Geometry.Point(parseFloat(pointArr[0]),parseFloat(pointArr[1]));
		return point;
	},
	
	// 解析站点或出入口点的要素
    _getPointFeatureByObj: function(pointInfoObj){
        var pointGeometry = null;
        if (pointInfoObj.Geometry && pointInfoObj.Geometry.gml_Point) {
            pointGeometry = this._getPointGeometryByGMLPointStr(pointInfoObj.Geometry.gml_Point);
        }
        var pointFeature = new GeoGlobe.Feature(pointGeometry, pointInfoObj);
        return pointFeature;
    },
	
	// -----根据id等信息获取geometry串并生成geometry对象
    _getLineGeometryByGMLLineStr: function(geometryStr){
        if (!geometryStr) {
            return null;
        }
        var pointStrArr = geometryStr.split(" ");
        var pointArr = [];
        for (var i = 0, j = pointStrArr.length; i < j; i++) {
            var pointGeometry = this._getPointGeometryByGMLPointStr(pointStrArr[i]);
            pointArr.push(pointGeometry);
        }
        var lineGeometry = new GeoGlobe.Geometry.LineString(pointArr);
        return lineGeometry;
    },
	
	/**
	 * 根据线路ID或者步行ID来获取相应的线要素（公交2.0。注意：这些线要素不包含属性信息）。
	 * @memberof GeoGlobe.Query.BusQuery.prototype
	 * @param {Object} options  - 请求参数。
	 * 
	 * options请求参数属性可为:
	 * @param {String} networkName - (必选) 网络模型名称。
	 * @param {Arrays} parameterInfo - 取值格式：[[geometryTypeID,geometryInfoID,FromOrdinal,ToOrdinal]]例如[[0,10,22,24]]。
	 * @param {Integer} geometryTypeID - (必选) 0-线路内部ID,1-步行路由内部ID。如果这个属性的值为1，那么FromOrdinal和ToOrdinal这两个属性的的值就都为0。
	 * @param {Integer} geometryInfoID - 几何信息 的ID。
	 * @param {Integer} FromOrdinal -  (必选) 起点序号。
	 * @param {Integer} ToOrdinal -  (必选) 终点序号。
	 */
	queryTransferGeometry: function(options, successFn, failFn) {
		var params = {
			request: "QueryTransferGeometry",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
		if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.parameterInfo === null || options.parameterInfo === undefined || options.parameterInfo === ""){
            throw "Error!Not parameterInfo for bus query.";
            return;
        }
		params.networkName = options.networkName;
		params.PARAMETERINFO = "";
        for (var i = 0; i < options.parameterInfo.length; i++) {
            params.PARAMETERINFO += options.parameterInfo[i].toString();
            if (i != options.parameterInfo.length - 1) {
                params.PARAMETERINFO += "_";
            }
        }
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: GeoGlobe.Function.bind(function(result){
				var features = this._parseQueryTransferGeometryResult(result);
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	//解析QueryTransferGeometry接口返回结果 -----获取线路要素
	_parseQueryTransferGeometryResult: function(result) {
		resXML = result.responseXML;
		var features = [];
		if(!resXML) {
			return features;
		}
		var xmlparser = new GeoGlobe.Format.XML();
		var geometrysStrTemp = resXML.selectNodes("/QueryTransferGeometryResponse");	
		//没有查询到数据的情况
		if(geometrysStrTemp && geometrysStrTemp.length <= 0) {
			return features;
		}
		var geometrysXMLStr = xmlparser.write(geometrysStrTemp[0]);
		var geometrysXMLObj = this._parseToJSON(geometrysXMLStr);
		var geometrys = geometrysXMLObj.QueryTransferGeometryResponse.SectionGeometry;	
		
		if(geometrys) {
			if(!GeoGlobe.Util.isArray(geometrys)) {
				geometrys = [geometrys];
			}
			//得到一个个站点
			for(var i = 0 ;i < geometrys.length; i++)  {
				//得到几何对象
				var geometryTemp = this._getLineGeometryByGMLLineStr(geometrys[i].Geometry.gml_LineString);
				//得到线要素
                var lineFeature = new GeoGlobe.Feature(geometryTemp, {
                    ID: geometrys[i].ID
                });
				features.push(lineFeature);
			}
		}
		return features;
	},
	
	/**
	 * 根据关键字来获取线路信息或者站点信息或者出入口信息。（公交2.0）
	 *  @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Object} options  - 请求参数。
	 * 
	 * options请求参数属性可为:
	 * @param {String} networkName  - (必选) 网络模型名称。
	 * @param {String} keyWord  - (必选)查询关键字。
	 * @param {Integer} searchType  - (可选) 查询类型，默认值为 2，查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊默认值为2。
	 * @param {Integer} keyWordType  - (可选) 查询关键字类型，默认值为 -1，可供选择的值为-1|0|1|2:-1:先查线路，然后查车站，最后查出入口0-查线路，1-查车站，2-查出入口。
	 *     
	 * @returns {Array(GeoGlobe.Feature)}  - 返回的是出入口、站点、线路要素。
	 */
	queryKeyWord: function(options, successFn, failFn) {
		var params = {
			REQUEST: "QueryKeyWord",
			SERVICE: "BUS",
			VERSION: "1.0.0",
			SEARCHTYPE: 2
		};
		if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.keyWord === null || options.keyWord === undefined || options.keyWord === ""){
            throw "Error!Not keyWord for bus query.";
            return;
        }
		params.NETWORKNAME = options.networkName;
		params.KEYWORD = options.keyWord;
		
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		if (options.searchType !== null && options.searchType !== undefined) {
        	params.SEARCHTYPE = options.searchType;
        }
		if (options.keyWordType !== null && options.keyWordType !== undefined) {
        	params.KEYWORDTYPE = options.keyWordType;
        }
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            async: false,//true表示异步，false表示同步
            scope: this,
            success: GeoGlobe.Function.bind(function(result){
				var features = this._parserQueryKeyWordResult(result,options.keyWordType);
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	//解析queryKeyWord接口返回结果 -----获取站点或出入口或线路文字描述信息
	_parserQueryKeyWordResult: function(result,keyWordType) {
		var resXML = result.responseXML;
		var features = [];	
		if(!resXML) {
			return features;
		}
		var xmlparser = new GeoGlobe.Format.XML();
		var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
		//没有查询到数据的情况
		if(errorTemp && errorTemp.length > 0) {
			return features;
		}
		var objectsStrTemp = resXML.selectNodes("/QueryKeyWordResponse");	
		var objectsXMLStr = xmlparser.write(objectsStrTemp[0]);
		var objectsXMLObj = this._parseToJSON(objectsXMLStr);
		
		// 0-查线路，1-查车站，2-查出入口
        if (keyWordType === 1) {
            var stations = objectsXMLObj.QueryKeyWordResponse.Stations.Station;
			if (stations && !(GeoGlobe.Util.isArray(stations))) {
				stations = [stations];
			}
            for (var i = 0; i < stations.length; i++) {
                var pointFeature = this._getPointFeatureByObj(stations[i]);
                features.push(pointFeature);
            }
        } else if (keyWordType === 2) {
            var passageways = objectsXMLObj.QueryKeyWordResponse.Passageways.Passageway;
			if (passageways && !(GeoGlobe.Util.isArray(passageways))) {
				passageways = [passageways];
			}
            for (var i = 0; i < passageways.length; i++) {
                var pointFeature = this._getPointFeatureByObj(passageways[i]);
                features.push(pointFeature);
            }
        } else {
            var lines = objectsXMLObj.QueryKeyWordResponse.Lines.Line;
			if (lines && !(GeoGlobe.Util.isArray(lines))) {
				lines = [lines];
			}
            for (var i = 0; i < lines.length; i++) {
                var lineFeature = new GeoGlobe.Feature(null,lines[i]);
                features.push(lineFeature);
            }
        }
		return features;
	},
	
	/**
     * 站点查询操作。（公交2.0）
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Object} options  - 请求参数。
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * @param {String} networkName  - (必选) 网络模型名称。
     * @param {Integer} stationId  - (必选) 站点ID  必须为正整型。
     *   
     *       
     * @example
     * (code)
     *  busService.queryStationInfo({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     */	
    queryStationInfo:function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryStationInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.stationId === null || options.stationId === undefined || options.stationId === ""){
            throw "Error!Not stationId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }
        
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				resXML = result.responseXML;
				if(!resXML) {
					var features = {
						lines:[],
						passageways:[]
					};
	                successFn(features);
					return;
				}
				var xmlparser = new GeoGlobe.Format.XML();
				
				//根据节点名字，解析成对象
				var lines = this._parserQueryStationInfoNode("Lines", xmlparser, resXML);
				var passageways = this._parserQueryStationInfoNode("Passageways", xmlparser, resXML);
                
				//解析后转feature
				var passagewaysFeature = new Array();
                for (var i = 0; i < passageways.length; i++) {
					var pointFeature = this._getPointFeatureByObj(passageways[i]);
					passagewaysFeature.push(pointFeature);
                }
		
				var features = {
					lines: lines,
					passageways: passagewaysFeature
				};
                successFn(features);
            },
            failure: failFn
        });

    },
	
	//解析queryStationInfo接口返回的结果中的xml串
    _parserQueryStationInfoNode: function(nodeName, xmlparser, resXML){
		switch (nodeName) {
            case "Lines":
                //解析lines
	            var element = resXML.selectNodes("/QueryStationInfoResponse/StationInfo/Lines");
	            var lines = new Array();
	            if (element.length > 0) {
	                var xmlObj = xmlparser.write(element[0]);
	                var jsonObj = this._parseToJSON(xmlObj);
	                lines = jsonObj.Lines.Line;
	                if (!(GeoGlobe.Util.isArray(lines))) {
	                    lines = [lines];
	                }
	            }
	            return lines;
                break;
            case "Passageways":
                //解析Passageways
	            var element = resXML.selectNodes("/QueryStationInfoResponse");
	            var passageways = new Array();
	            if (element.length > 0) {
	                var xmlObj = xmlparser.write(element[0]);
	                var jsonObj = this._parseToJSON(xmlObj);
					var passagewaysJson = jsonObj.QueryStationInfoResponse.StationInfo.Passageways;
					if(passagewaysJson){
						passageways = passagewaysJson.Passageway;
		                if (!(GeoGlobe.Util.isArray(passageways))) {
		                    passageways = [passageways];
		                }
					}
	            }
	            return passageways;
                break;
            default:
				return [];
                break;
        }
    },
    
    /**
     * 线路查询操作。（公交2.0）
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Object} options  -  请求参数。
     * @param {Function} successFn - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * @param {String} networkName - (必选) 网络模型名称。
     * @param {Integer} lineId - (必选) 线路ID。
     * @param {String} STARTNODENUMBER - (可选) 线路中某一个站点的序号。多个序号采用逗号分割。
     * @param  {String} ENDNODENUMBER - (可选) 线路中某一个站点的序号。多个序号采用逗号分割。
     * 
     * @example
     * (code)
     *  busService.queryLineInfo({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     */
    queryLineInfo: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryLineInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.lineId === null || options.lineId === undefined || options.lineId === ""){
            throw "Error!Not lineId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
        
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
        
        if(options.startNodeNumber !== null && options.startNodeNumber !== undefined){
            params.STARTNODENUMBER = options.startNodeNumber;
        }    
                
        if(options.endNodeNumber !== null && options.endNodeNumber !== undefined){
            params.ENDNODENUMBER = options.endNodeNumber;
        }   
                     
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
//				// 传入包含gml的结点名称
//				var resultString = this._parserResponseText(result.responseText, "Line");
//				var features = this._parserFeaturesNew(resultString);
//				
//				// 线路所包含的站点要素
//				var resultStationString = this._parserResponseText(result.responseText, "Station");
//				var stationFeatures = this._parserFeaturesNew(resultStationString);
//                features[0].attributes.Stations = features[0].data.Stations = stationFeatures;
//				
//				successFn(features);
//				return;
				
				var features = [];
				var resXML = null;
				if(result.responseXML) {         
					resXML = result.responseXML;
					var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
					//没有查询到数据的情况
					if(errorTemp && errorTemp.length > 0) {
						successFn(features);
						return;
					}
					var xmlparser = new GeoGlobe.Format.XML();
					//根据节点名字，解析成对象
					var line = this._parserQueryLineInfoNode("Line", xmlparser, resXML);
					//解析后转feature
					var lineFeatures = new Array();
	                for (var i = 0; i < line.length; i++) {
						//线路内站点信息转要素
						var stationFeatures = new Array();
	                    for (var j = 0; j < line[i].VIAStations.Station.length; j++) {
							//得到点要素
	                    	var stationFeature = this._getPointFeatureByObj(line[i].VIAStations.Station[j]);
							stationFeatures.push(stationFeature);
	                    }
						line[i].Stations = stationFeatures;
						//得到线几何对象
						var lineGeometry = this._getLineGeometryByGMLLineStr(line[i].Geometry.gml_LineString);
						//得到线要素
	                    var lineFeature = new GeoGlobe.Feature(lineGeometry, line[i]);
						lineFeatures.push(lineFeature);
	                }
			
					features = lineFeatures;
				}
				successFn(features);
            },
            failure: failFn
        });

    },
	//解析queryStationInfo接口返回的结果中的xml串
    _parserQueryLineInfoNode: function(nodeName, xmlparser, resXML){
		switch (nodeName) {
            case "Line":
                //解析line
	            var element = resXML.selectNodes("/QueryLineInfoResponse");
				var xmlObj = xmlparser.write(element[0]);
                var jsonObj = this._parseToJSON(xmlObj);
				var l = jsonObj.QueryLineInfoResponse.Line;
				
	            var lines = new Array();
                if (l && !(GeoGlobe.Util.isArray(l))) {
                    lines = [l];
                }else{
					lines = l;
				}
	            return lines;
                break;
            default:
				return [];
                break;
        }
    },
	
	/**
     * 根据出入口ID获取与此出入口有关的站点信息，包括出入口所对应的车站信息。（公交2.0）
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Object} options  - 请求参数。
     * @param {Function} successFn   - 请求成功的回调函数。
     * @param {Function} failFn  -  请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * @param {String} networkName  - (必选) 网络模型名称。
     * @param {Integer} passagewayId  - (必选) 出入口ID。
     * 
     * @example
     * (code)
     *  busService.queryPassagewayInfo({
     *      networkName: "BusChangeModule",
     *      passagewayId : 2
     *  }
     *  (end)
     */
    queryPassagewayInfo: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryPassagewayInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.passagewayId === null || options.passagewayId === undefined || options.passagewayId === ""){
            throw "Error!Not passagewayId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
        
        if(options.passagewayId !== null && options.passagewayId !== undefined){
            params.PASSAGEWAYID = options.passagewayId;
        }
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var resXML = result.responseXML;
				var features = [];	
				if(!resXML) {
					successFn(features);
					return features;
				}
				var xmlparser = new GeoGlobe.Format.XML();
				var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
				//没有查询到数据的情况
				if(errorTemp && errorTemp.length > 0) {
					successFn(features);
					return features;
				}
				var responseText = this._parserResponseText(result.responseText);
				features = this._parserFeaturesNew(responseText, "Stations");
				successFn(features);
            }
        });
	},
	
	
	/**
     * 根据起点终点名称得到对应的坐标信息
     * 根据坐标信息请求_queryTransferScheme查询换乘方案信息
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {String} startName - 起点名称。
     * @param {String} endName - 终点名称。
     * @param {String} transferMode - 选择方式
     *
     * @returns {Object}   - 换乘方案信息
     * 
     * 返回对象属性包含：
     * @param startPoint  - 起点要素
     * @param transferScheme  - 所有换乘方案信息
     * @param endPoint  - 终点要素
     * @private
     */
    _queryByName: function(startName,endName,transferMode){
    	var that = this;
    	var featuresInfo = null;
    	 //查询起点信息
         that.queryKeyWord({
             networkName: that.networkName,
             keyWord: startName,
             keyWordType: 1,// 0-查线路，1-查车站，2-查出入口//-1:先查线路，然后查车站，最后查出入口
             SEARCHTYPE: 2//查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊,默认值为2；
         }, function(feature){
               if (feature.length == 0) {
				   alert("没有查询到起点");
	               return;
               }
			   var startPoint = feature[0].geometry.x + " " +feature[0].geometry.y;
			   //查询终点信息
			   that.queryKeyWord({
	               networkName: that.networkName,
	               keyWord: endName,
	               keyWordType: 1,// 0-查线路，1-查车站，2-查出入口//-1:先查线路，然后查车站，最后查出入口
	               SEARCHTYPE: 2//查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊,默认值为2；
       		  }, function(feature){
		            if (feature.length == 0) {
						alert("没有查询到终点");
		           		return;
		      		}
		   			var endPoint = feature[0].geometry.x + " " + feature[0].geometry.y;
		   			featuresInfo = that._queryTransferScheme(startPoint,endPoint,transferMode);//查询换乘方案信息
		    	});
			});
			return featuresInfo;
    },
	
	/**
     * 根据parameter1、parameter2、transferMode查询公交换乘方案。
     * 请求url，响应返回capabilities的XML文档信息，解析该XML文档，获得服务的networkName。
     * 根据得到的参数请求_queryTransferScheme方法得到换乘方案信息 
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {GeoGlobe.LngLat | String} parameter1  - 起点经纬度或者起点名称。
     * @param {GeoGlobe.LngLat | String} parameter2  - 终点经纬度或者终点名称。
     * @param {String} transferMode - 选择方式 0-较快捷   1-少换乘  2-少步行
     *
     * @returns {Object}  - 换乘方案信息
     * {flag:服务正常返回换乘信息为true,否则为false,featuresInfo：换乘方案信息}
     *
     */
    queryBus: function(parameter1, parameter2,transferMode){
    	var that = this;
    	var featuresInfo = null;
    	that.getCapabilities(GeoGlobe.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
            var format = new GeoGlobe.Format.BusCapabilities();
            var capabilities = format.read(data);
			if(capabilities.capability){
	            var layerName = capabilities.capability.networks[0];
	            that.networkName = layerName;
	            if(typeof(parameter1) == "string" && typeof(parameter2) == "string"){//站点名称查询
	            	featuresInfo = that._queryByName(parameter1,parameter2,transferMode);
	            }else{//坐标查询
	            	var startPoint = parameter1.lng + " " +parameter1.lat;
	            	var endPoint = parameter2.lng + " " + parameter2.lat;
	            	featuresInfo = that._queryTransferScheme(startPoint,endPoint,transferMode);//查询换乘方案信息
	            }
			}else{
				alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            	"请求地址：" + url + "\n操作类型：GetCapabilities");
			}
        }, this),
		function(){
            alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
        });
        var featureData = {
        	flag:featuresInfo ? true : false,
        	featuresInfo:featuresInfo
        }
        return featureData;
    },
    
    
    failFn: function(){
		alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
	},
	
	 /**
	  * 查询换乘方案信息
	  * 根据startPoint、endPoint、transferMode、networkName查询公交换乘方案。
	  * @memberof GeoGlobe.Query.BusQuery.prototype
      * @param {String}  url  - 公交服务地址。
      * @param {GeoGlobe.Geometry.Point} startPoint  -  起点坐标。
      * @param {GeoGlobe.Geometry.Point}  endPoint  - 终点坐标。
      * @param {String} transferMode - 选择方式 0-较快捷   1-少换乘  2-少步行
      *
      * @returns {Object}  - 换乘方案信息
      * 
      * 返回对象属性包含：
      * @param startPoint  - 起点要素
      * @param transferScheme  - 所有换乘方案信息
      * @param endPoint  - 终点要素
      * @private
	  *
	  */
	_queryTransferScheme: function(startPoint,endPoint,transferMode){
		var lineFeatures =  null;
        this.queryTransferScheme({
	         networkName: this.networkName,
	         transferMode: transferMode ? transferMode : 0,//0-较快捷   1-少换乘  2-少步行
	         inputMode: 0,//默认为0。0：传坐标。2：传ID。
	         startInput: startPoint,
	         endInput: endPoint
	    }, function(features){
	     	featuresInfo = features;
	    });
	    this.transferScheme = featuresInfo.transferScheme;
	    return featuresInfo;
	},
	
	/**
	 *
	 * 根据sortIndex查询单条换乘方案几何信息。
	 * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {String} sortIndex  - 换乘方案索引值。
     *
     * @returns {Object}    -  换乘方案几何信息
     * {lineFeatures:方案线要素 ,stationFeatures:换乘方案的起始点要素}
	 *
	 */
	queryBusTransferSchemeByIndex: function(sortIndex){
		var busSer = null;
		var lineData = null;
		var sortIdx = parseInt(sortIndex);
        var transferScheme = this.transferScheme[sortIdx];
        var sectionInfo = transferScheme.SectionInfo;
        
        //查询参数。
        var parameterInfo = new Array();
        var transferPointFeatures = new Array();
        for (i = 0; i < sectionInfo.length; i++) {
            var type = 0;
            var lineFeature = sectionInfo[i].SectionLine[0];
            var lineId = lineFeature.data.ID;
            var fromOrdinal = lineFeature.data.FromOrdinal;
            var toOrdinal = lineFeature.data.ToOrdinal;
            
            parameterInfo.push([type, lineId, fromOrdinal, toOrdinal]);
            transferPointFeatures.push(sectionInfo[i].FromStation);
            transferPointFeatures.push(sectionInfo[i].ToStation);
        }
        
        this.queryTransferGeometry({
            networkName: this.networkName,
            //单条几何信息的ID的类型(0或者1)，几何信息的ID(line:LID)，起点序号(upStation:NodeNumber)，终点序号(downStation:NodeNumber)；
            parameterInfo: parameterInfo//[[0, 67, 24, 60], [0, 221, 31, 85]]
        }, function(features){
            var lineFeatures = features;
            //将lineFeatures和transferPointFeatures转化为geojson数据类型
            var gjformat = new GeoGlobe.Format.GeoJSON();
			var geojsonRouteStr = gjformat.write(lineFeatures);
			var geojsonStationStr = gjformat.write(transferPointFeatures);
			var jformat = new GeoGlobe.Format.JSON();
			var geojsonRoute = jformat.read(geojsonRouteStr);
			var geojsonStation = jformat.read(geojsonStationStr);
			
            var data = {
            	lineFeatures:lineFeatures,
            	geojsonRoute:geojsonRoute,
            	stationFeatures: transferPointFeatures,
            	geojsonStation:geojsonStation
            }
            lineData = data;
        });
        return lineData;
	},
	
	
	
	CLASS_NAME: "GeoGlobe.Query.BusQuery"
});

//FF,chrome兼容selectNodes,selectSingleNode
(function xmlNodesTool(){
    if (document.implementation.hasFeature("XPath", "3.0")) {
        // prototying the XMLDocument 
        XMLDocument.prototype.selectNodes = function(cXPathString, xNode){
            if (!xNode) {
                xNode = this;
            }
            //name space resolver defined  
            function nsResolver(prefix){
                var ns = {
                    'csw': 'http://www.opengis.net/cat/csw',
                    'smmd': 'http://data.sbsm.gov.cn/smmd/2007',
                    'wfs': 'http://www.opengis.net/wfs',
                    'gml': 'http://www.opengis.net/gml',
                    'geoglobe': 'http://www.geostar.com.cn/geoglobe'
                };
                return ns[prefix] || null;
            }
            //var oNSResolver = this.createNSResolver(this.documentElement||this.ownerDocument.documentElement)||nsResolver;
            var aItems = this.evaluate(cXPathString, xNode, nsResolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
            var aResult = [];
            for (var i = 0; i < aItems.snapshotLength; i++) {
                aResult[i] = aItems.snapshotItem(i);
            }
            return aResult;
        };
        
        // prototying the Element 
        Element.prototype.selectNodes = function(cXPathString){
            if (this.ownerDocument.selectNodes) {
                return this.ownerDocument.selectNodes(cXPathString, this);
            }
            else {
                throw "For XML Elements Only";
            }
        };
        
    }
    if (document.implementation.hasFeature("XPath", "3.0")) {
        // prototying the XMLDocument 
        XMLDocument.prototype.selectSingleNode = function(cXPathString, xNode){
            if (!xNode) {
                xNode = this;
            }
            var xItems = this.selectNodes(cXPathString, xNode);
            if (xItems.length > 0) {
                return xItems[0];
            }
            else {
                return null;
            }
        };
        
        // prototying the Element 
        Element.prototype.selectSingleNode = function(cXPathString){
            if (this.ownerDocument.selectSingleNode) {
                return this.ownerDocument.selectSingleNode(cXPathString, this);
            }
            else {
                throw "For XML Elements Only";
            }
        };
    }
})();
/**
 * @class GeoGlobe.Query.WFSQuery
 * @classdesc WFS地图要素服务查询类。本类也适用于聚合网络要素服务（Aggregation Web Feature Service简称AWFS）和地名地址要素服务（Web Feature Service Gazetteer简称WFS-G）的查询。
 *
 */
GeoGlobe.Query.WFSQuery = GeoGlobe.Class4OL({
	
    /**
     *  WFS服务地址。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
	url: null,
	
	/**
     *  WFS服务版本
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
	version: "1.0.0",

    /**
     *  要素命名空间
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
    featureNS: null,
	
	/**
	 * 是否对请求结果中的几何信息进行轴序反转，默认值为false,
	 * 当取值为false时，对请求结果不做反转操作。
	 * 当取值为true时，对请求结果做反转操作。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {Boolean}
	 */
	isReverse: false,
	
	/**
	 * 要素类型前缀，默认值""
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
	 */
	featurePrefix:"",
	
    /**
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {Array}
     */	
	featureType: "",
	
    /**
     * 最大结果数。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String | Array(String)}
     */	
	maxFeatures: 10,
	
    /**
     *  查询条件。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {GeoGlobe.Filter}
     */
	filter: null,
    
    /**
     * 要素中geometry属性的名称，默认为"the_geom"。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
    geometryName: "the_geom",


    /**
     *  WFS查询协议对象。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {GeoGlobe.Protocol}
     */	
	protocol: null,

    /**
     *  用于对查询操作返回结果进行解析的格式解析器，默认为GML解析器。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {GeoGlobe.Format}
     */
	format: null,
    
    /**
     * 格式解析器构造参数。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {GeoGlobe.Format}
     */    
    formatOptions: null,
    
    /**
     * 设置是否将查询结果按图层名分类。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {Boolean}
     */  
    isSeparate: false,
	
    /**
     * 空间参考名。默认值为"EPSG:4326"。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
    srsName: "EPSG:4326",
	
    /**
     * 可选的。版本时间，此参数只针对多时态矢量数据集。默认为查询最新版本时间。时间格式：2015-5-19 12:12:01
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
	time: null,
	
    /**
     * 可选的。是否追溯(取值范围：true或false，true为返回最近匹配，false则精确匹配，默认值为true)
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
	userecent: true,
	
	/**
	 * 设置WFS查询结果的排序参数，该参数为一个数组对象。
     *  > sortBy数组内对象所包含的属性:
     *  > property - {String} 查询出的要素的某一属性的名称，根据该属性进行排序。
     *  > order - {String} 设置正序("ASC")或倒序("DESC")。
     *
	 * 说明：
	 * 1.wfsg和wfs服务都支持排序；如果wfsg服务中的Post请求串中没有sort节点，那么该服务就不进行排序了（此时用其他字段排序也不起作用了）。当服务在查询中
	 * 有sort节点的时候， 建议用户选择STANDARDNAME和sort字段之一进行排序。如果使用DoMainName作为查询关键字，也可以使用DoMainName进行作为排序字段。
	 * 
	 * 2.wfsg服务和wfs服务默认是以sort字段进行排序，sort字段的值是数字，如果用户以sort字段进行排序，那么sort字段的值（数字）越大，
	 * 在结果列表中越排在后面，相反，sort字段的值越小，则在结果列表中排在越前面，如果sort字段的值相同，则按照其在数据库中读出来的先后顺序排列，
	 * 如果sort字段没值，则排在结果的最后面。
	 * 
	 * 3.若是以STANDARDNAME作为排序字段，如果STANDARDNAME的值是中文，那么排序就是第一个汉字的拼音的首字母的先后顺序作为排序字段（如北京和安徽，
	 * 北京是b为拼音首字母，安徽是a为拼音首字母，那么就是安徽排在北京的前面），若值的第一个汉字拼音首字母相同，则是以第一个汉字拼音的第二个字
	 * 母的先后顺序排列；如果STANDARDNAME的值是英文，也一样，依次类推。
	 *@memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {Array}
	 * @example
	 * (code)
	 *		 wfsQueryObj.sortBy = [{
     *              property: "STANDARDNAME",
     *              order: "DESC"
     *          }]
	 * (end)
	 */
	sortBy: null,

	groupBy: null,
	
	resultType: "Results",
	
	startPosition: null,

	/**
	 * GeoGlobe.Query.WFSQuery类构造函数。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {String} url  -  WFS服务地址。
	 * @param {String} featureType  -  要素类型。
	 * @param {Object} options  - 相关属性的设置项，可选。
	 */	
	initialize: function(url,featureType,options){
		this.url = url;
		this.featureType = featureType;
		var xy = null;
		if(options) {
			if(options.isReverse === true) {
				this.isReverse = options.isReverse;
				xy = !options.isReverse;
			}else if(options.isReverse === false) {
				this.isReverse = options.isReverse;
				//xy顺序即是不反转
				xy = !options.isReverse;
			}else {
				//默认不反转
				xy = !this.isReverse;
			}
			if(!options.format) {
				this.format = new GeoGlobe.Format.GML({xy:xy});
			}else if(options.format instanceof GeoGlobe.Format.GML.v2 ||options.format instanceof GeoGlobe.Format.GML.v3) {
				options.format.setFeatureType_(featureType);
			}
		}
		GeoGlobe.Util.extend(this, options);
	},

	/**
	 * 开始查询。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {GeoGlobe.Filter}  filter  - 过滤器。
	 * 说明：
	 * 1.当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，参数filter中的
	 * 所有几何参数都需要改为纬度，经度的顺序。举例说明：
	 * 以矩形范围为例：
	 * new GeoGlobe.LngLatBounds([-180,-90],[180,90]);
	 * 在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该矩形范围应写成
	 * new GeoGlobe.LngLatBounds([-90,-180],[90,180]);
	 * 
	 * @param successFn - {Function} 请求成功的回调函数。
	 * > 该回调函数会提供一个形参，该形参是一个数组，名为features。在地名查询2.0及其以上的版本中，features有一个属性叫trueNames，
	 * > 该属性用于存放纠错词信息。在地名查询2.0以下的版本中不提供trueNames属性。
     * @param failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * @example
	 * (code)
	 *  	//查询范围
	 *		var queryBBOX = new GeoGlobe.LngLatBounds([-180,-90],[180,90]);
	 *		 //范围过滤
	 *		 var filter = new GeoGlobe.Filter.Spatial({
	 *           type: GeoGlobe.Filter.Spatial.BBOX,
	 *           property: this.geometryName,            
	 *		    value: queryBBOX
	 *       });
	 *		 wfsQueryObj.query(filter,successFn,failFn);
	 * (end)
	 */
	query: function(filter,successFn,failFn){
		this.protocol = new GeoGlobe.Protocol.WFS({
			readFormat: this.format,
            formatOptions: this.formatOptions,
			propertyNames: this.propertyNames,
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent,//是否追溯
			srsName: this.srsName
        });
		
        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;
        
		var callback = GeoGlobe.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}

			var features = result.features
            
            //根据要求进行按图层名分捡要素
            if(this.isSeparate){
                features = this._separateFeatures(features);
            }
            //对于容错给予提示的节点
            var trueNames = this._read_trueName(result);
			trueNames ? (features.trueNames = trueNames) : features;
			//querySuccessFn(features);
			
			var gjformat = new GeoGlobe.Format.GeoJSON();
			var gjStr = gjformat.write(features);
			var jformat = new GeoGlobe.Format.JSON();
			var gjObj = jformat.read(gjStr);
			querySuccessFn({
				features: features,
				geojson: gjObj
			});
			
		},this);

		this.response = this.protocol.read({
			sortBy: this.sortBy,
			filter: queryFilter,
			callback: callback
		});
	},
	
	/**
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {GeoGlobe.Filter} filter  - 过滤器。
	 * @param {Function} successFn  - 请求成功的回调函数。
	 *    > 该回调函数会提供一个形参，该形参是一个数组，名为features。在地名查询2.0及其以上的版本中，features有一个属性叫trueNames，
	 *    > 该属性用于存放纠错词信息。在地名查询2.0以下的版本中不提供trueNames属性。
     * @param {Function} failFn  - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * @param {Object} options  - 参数选项。
     * 
	 */
	queryPage: function(filter, successFn, failFn, options){
	    var perPageNumber = (options && options.perPageNumber) || 15,
	        pageNumber = (options && options.pageNumber) || 1;
	    
	    var startPosition = (pageNumber - 1) * perPageNumber + 1;
		this.protocol = new GeoGlobe.Protocol.WFS({
			readFormat: this.format,
			multi:true,
	        formatOptions: this.formatOptions,
			propertyNames: this.propertyNames,
	        maxFeatures: perPageNumber,
	        startPosition: startPosition,
	        featurePrefix:this.featurePrefix,
	        url: this.url,
	        featureNS: this.featureNS,
			version: this.version,
			geometryName : this.geometryName,
	        featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent,//是否追溯
			srsName:this.srsName
	    });
		
	    //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
	    var queryFilter = filter || this.filter;
	    var querySuccessFn = successFn || this.successFn;
	    var queryFailFn = failFn || this.failFn;
	    
		var callback = GeoGlobe.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}
	
			var features = result.features
	        
	        //根据要求进行按图层名分捡要素
	        if(this.isSeparate){
	            features = this._separateFeatures(features);
	        }
	        //对于容错给予提示的节点
	        var trueNames = this._read_trueName(result);
			features.trueNames = trueNames;
			//querySuccessFn(features);
			
			var gjformat = new GeoGlobe.Format.GeoJSON();
			var gjStr = gjformat.write(features);
			var jformat = new GeoGlobe.Format.JSON();
			var gjObj = jformat.read(gjStr);
			querySuccessFn({
				features: features,
				geojson: gjObj
			});
			
			
		},this);
		this.response = this.protocol.read({
			sortBy:this.sortBy,
	//		maxFeatures: this.maxFeatures,
			filter: queryFilter,
			callback: callback
		});
	},
	
	/**
	 * 查询总数据的总条数。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {GeoGlobe.Filter} filter  - 过滤器。
	 * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
	 * 
	 */
	queryTotalNumber: function(filter,successFn,failFn){

        var hitsParser = new GeoGlobe.Format.WFSHits();

		this.protocol = new GeoGlobe.Protocol.WFS({
			readFormat: hitsParser,
			propertyNames: this.propertyNames,
            resultType: "hits",
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent//是否追溯
        });
		
        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;
        
		var callback = GeoGlobe.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}

			var hitsResult = result.features
            
			querySuccessFn(hitsResult);
			
		},this);

		this.response = this.protocol.read({
			filter: queryFilter,
			callback: callback
		});

	},
    
	//读取容错提示节点
	_read_trueName: function(result) {
		var trueNames = [];
		if(result.priv && result.priv.responseText) {
			if(null == this.format){
				return null;
			}
			var trueNameDocs = this.format.getXMLDoc().getElementsByTagName("trueName");
			if (trueNameDocs == null || trueNameDocs.length == 0) {
                return null;
            }
			for(var i = 0; i < trueNameDocs.length; i++) {
				trueNames.push(trueNameDocs[i].text);
			}
			return trueNames;
		}
		return trueNames;
	},
	
	/**
	 *  得到缓冲区域。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @param {GeoGlobe.Feature} point  - 点要素。
     * @param {Integer} distance  - 半径。
     * @param {String} unit  - 缓冲单位。
     * 
	 * @returns {GeoGlobe.Geometry.Polygon}  - 几何多边形。
	 */
	getBufferRegion: function(point,distance,unit) {
		var lonlat = this._getFeaturesCenter(point);
		switch(unit){
			case "km":
				distance = 1000 * distance;
			case "m":
				distance = this._meterToDegree(distance,lonlat);				
		}
		return GeoGlobe.Geometry.Polygon.createRegularPolygon(point.geometry,distance,40,360); 
	},
	
    /**
     *  获取所有要素范围之合的中心点。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @param features  - 要执行缓冲分析的要素。
     * 
     * @returns {GeoGlobe.LonLat}  - 中心点的坐标。
	 * @private
     */
	_getFeaturesCenter: function(features){		
		var bounds = this._getFeaturesExtent(features);
		return bounds.getCenterLonLat();
	},
	
	/**
	 * 获取要素数组范围之合。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param features - 要查看的要素数组
	 * 
	 * @returns  {GeoGlobe.LngLatBounds}  - 要素数组的总的范围。
	 * @private
	 */
	_getFeaturesExtent: function (features) {
        if(!(GeoGlobe.Util.isArray(features))){
			features = [features];
		}
        var maxExtent = null;
        if(features && (features.length > 0)) {
            maxExtent = new GeoGlobe.LngLatBounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
	/**
	 * 根据地理坐标位置，将米转换成经纬度。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param meter  - 要转换的地理坐标。
	 * @param lonlat  - 经纬度。
	 * @private
	 */
	_meterToDegree: function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(GeoGlobe.Util.rad(templat)) );
	},
	
	/**
	 * 点查询。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param  {GeoGlobe.Geometry.Point} point  - 点要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的point参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个点要素为例：new GeoGlobe.Geometry.Point(112,20)。
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该点要素应写成new GeoGlobe.Geometry.Point(20,112)
	 * @param {Number} distance  - 缓冲半径。它是指指定线的距离范围。服务利用这个属性可以对线进行缓冲区分析得到一个面，再用面去进行查询。
 	 *		distance的取值范围：大于等于零。
	 * 		例如：如果距离是5，单位是米，那么服务内部会将这个线以5米为半径对其进行缓冲区分析得到成一个面，再使用面做查询。
	 * @param {String} unit  - 单位  值为"m"或degree。
	 * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * @example
	 * (code)
	 *   //距离
	 *	 var distance = 50000000;
	 *	 //单位
     *	 var unit = "m";
	 *   //点要素
	 *	 var queryPoint = new GeoGlobe.Geometry.Point(110.40056,39.93202);
	 *   wfsQueryObj.pointQuery(queryPoint,distance,unit,successFn,failFn);
	 * (end)
	 */
    pointQuery: function(point,distance,unit,successFn,failFn){
        distance = distance || 0;
        unit = unit || "degree";
        var filter = new GeoGlobe.Filter.Spatial({
            //type: GeoGlobe.Filter.Spatial.INTERSECTS,
            type: GeoGlobe.Filter.Spatial.DWITHIN, //GeoGlobe.Filter.Spatial.DWITHIN
            property: this.geometryName, 
            distance: distance,
            distanceUnits: unit,
            value: point
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * 线查询。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 *  @param {GeoGlobe.Geometry.LineString} path  - 线要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的path参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个线要素为例：new GeoGlobe.Geometry.LineString([new GeoGlobe.Geometry.Point(118,20),new GeoGlobe.Geometry.Point(118.8,20.8)])。
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该线要素应写成
     * 		new GeoGlobe.Geometry.LineString([new GeoGlobe.Geometry.Point(20,118),new GeoGlobe.Geometry.Point(20.8,118.8)])。
	 *  @param {Number} distance  - 缓冲半径。它是指指定线的距离范围。服务利用这个属性可以对线进行缓冲区分析得到一个面，再用面去进行查询。
 	 *		distance的取值范围：大于等于零。
	 * 		例如：如果距离是5，单位是米，那么服务内部会将这个线以5米为半径对其进行缓冲区分析得到成一个面，再使用面做查询。
	 *  @param {String} unit  -  单位  值为"m"或degree。
	 *  @param {Function} successFn  - 请求成功的回调函数。
     *  @param {Function} failFn  - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * @example
     * (code)
     *   //距离
	 *	 var distance = 50000000;
	 *	 //单位
     *	 var unit = "m";
     *   //线要素
	 *	 var queryPath = new GeoGlobe.Geometry.LineString([
     *         new GeoGlobe.Geometry.Point(110,35),
     *         new GeoGlobe.Geometry.Point(110,36)
     *    ]);
     * 	 wfsQueryObj.pathQuery(queryPath, distance, unit, successFn,failFn);
     * (end)
	 */
    pathQuery: function(path,distance,unit,successFn,failFn){
        distance = distance || 0;
        unit = unit || "degree";
        var filter = new GeoGlobe.Filter.Spatial({
            type:GeoGlobe.Filter.Spatial.DWITHIN,
            property: this.geometryName, 
            distance: distance,
            distanceUnits: unit,
            value: path
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * 面查询。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {GeoGlobe.Geometry.Polygon} polygon  - 面要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的polygon参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个面要素为例：
     * 		new GeoGlobe.Geometry.Polygon([
     *   	 new GeoGlobe.Geometry.LinearRing([
     *       new GeoGlobe.Geometry.Point(177.76672363281,37.655639648436),
     *       new GeoGlobe.Geometry.Point(177.8884299300619,38.21858951787163),
     *       new GeoGlobe.Geometry.Point(177.8884299300619,38.21858951787163),
     *       new GeoGlobe.Geometry.Point(177.8884299300619,38.21858951787163)
     *       ])
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该面要素应写成
     * 		new GeoGlobe.Geometry.Polygon([
     *   	 new GeoGlobe.Geometry.LinearRing([
     *       new GeoGlobe.Geometry.Point(37.655639648436,177.76672363281),
     *       new GeoGlobe.Geometry.Point(38.21858951787163,177.8884299300619),
     *       new GeoGlobe.Geometry.Point(38.21858951787163,177.8884299300619),
     *       new GeoGlobe.Geometry.Point(38.21858951787163,177.8884299300619)
     *       ])
	 * 
	 * @param {Boolean} isContain  - 是包含还是相交。
	 * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * @example
     * (code)
     * 	 var isContain = false;
	 *	 var queryPolygon = new GeoGlobe.Geometry.Polygon([
     *   	 new GeoGlobe.Geometry.LinearRing([
     *       new GeoGlobe.Geometry.Point(77.76672363281,37.655639648436),
     *       new GeoGlobe.Geometry.Point(77.8884299300619,38.21858951787163),
     *       new GeoGlobe.Geometry.Point(77.8884299300619,38.21858951787163),
     *       new GeoGlobe.Geometry.Point(77.8884299300619,38.21858951787163)
     *       ])                
     *   ]);
     * 	 wfsQueryObj.polygonQuery(queryPolygon, isContain, successFn,failFn);
     * (end)
	 */
    polygonQuery: function(polygon,isContain,successFn,failFn){
        var filterType = isContain ? GeoGlobe.Filter.Spatial.CONTAINS : 
                                     GeoGlobe.Filter.Spatial.INTERSECTS;
        var filter = new GeoGlobe.Filter.Spatial({
            type: filterType,
            property: this.geometryName, 
            value: polygon
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * 范围查询。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {GeoGlobe.LngLatBounds} bbox  - 范围。
	 * 说明：
	 * 1.当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，参数filter中的
	 * 所有几何参数都需要改为纬度，经度的顺序。举例说明：
	 * 以矩形范围为例：
	 * new GeoGlobe.LngLatBounds([-180,-90],[180,90]);
	 * 在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该矩形范围应写成
	 * new GeoGlobe.LngLatBounds([-90,-180],[90,180]);
	 * 
	 * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * @example
	 * (code)
	 *   //查询范围
		 var queryBBOX = new GeoGlobe.LngLatBounds([-180,-90],[180,90]);
	 * 	 wfsQueryObj.bboxQuery(queryBBOX, successFn,failFn);
	 * (end)
	 */
    bboxQuery: function(bbox,successFn,failFn){
        var filter = new GeoGlobe.Filter.Spatial({
            type: GeoGlobe.Filter.Spatial.BBOX,
            property: this.geometryName,            
		    value: bbox
        });
        this.query(filter,successFn,failFn);
    },
    
	/**
	 * 属性查询。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {String}  type  - 比较类型。
	 * @param {String} property  -  属性名。
	 * @param {Number} or {String} value  -  属性值。
	 * @param {Object} options  - 可选参数。
	 * @param {Number} or {String}  lowerBoundary  - 值小的边界。
	 * @param {Number} or {String} upperBoundary  -  值大的边界。
	 * @param {Function} successFn - 请求成功的回调函数。
     * @param {Function} failFn - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * @example
     * (code)
     *   var type = GeoGlobe.Filter.Comparison.LIKE;
	 *		var property = "label";
	 *		var value = "*";
	 *		wfsQueryObj.attributeQuery(type,property,value,{
	 *			matchCase : true
	 *	 },successFn,failFn);
     * (end)
	 * 
	 */
    attributeQuery: function(type, property, value, options, successFn,failFn){
        
        var matchCase = options && options.matchCase;
        var lowerBoundary = options ? options.lowerBoundary : null;
        var upperBoundary = options ? options.upperBoundary : null;
        
        var filter = new GeoGlobe.Filter.Comparison({
            type: type,
            property: property,            
		    value: value,
            matchCase: matchCase,
            lowerBoundary: lowerBoundary,
            upperBoundary: upperBoundary
        });
        this.query(filter,successFn,failFn);
    },

	statisticsQuery: function(filter,successFn,failFn){
		this.protocol = new GeoGlobe.Protocol.WFS({
			readFormat: this.format,
			formatOptions: this.formatOptions,
			propertyNames: this.propertyNames,
            resultType: "statistics",
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent//是否追溯
        });

        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;

		var callback = GeoGlobe.Function.bind(function(result){
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}
			try{
				/*var object = null;
				var x2j = new GeoGlobe.Util.Format.XML2JSON();			
				var text = result.priv.responseText;
				if (null != text && "" != text && undefined != text) {			
					object = x2j.read(result.priv.responseText);
				} else {
					var xmlParser = new GeoGlobe.Format.XML();
					text = xmlParser.write(result.priv.responseXML);
					object = x2j.read(text);
				}*/
				var doc = result.priv.responseXML;
				var StatisticsResult = this._analysis_StatisticsResult(doc);
			}catch(e) {
				querySuccessFn(result.priv.responseText);
				return;
			}
			querySuccessFn(StatisticsResult);
		},this);

		this.response = this.protocol.read({
			sortBy: this.sortBy,
			groupBy: this.groupBy,
			filter: queryFilter,
			callback: callback
		});
	},

	/**
	 *  解析返回的结果
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param 	doc
	 * @private
	 */
	_analysis_StatisticsResult: function(doc) {
		var StatisticsResult = {};
		var featureCollection = doc.documentElement;
		//var results = featureCollection.firstElementChild;
        var results = featureCollection.firstChild;
		var layerArray = results.childNodes;
		if(0 < layerArray.length){
			StatisticsResult.layers = this._analysis_StatisticsResult_results(layerArray);
		}
		return StatisticsResult;
	},

	/**
	 * 统计结果第二级结构
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param 	layerArray
	 * @private
	 */
	_analysis_StatisticsResult_results: function(layerArray) {
		var layers = [];
		for(var i = 0; i < layerArray.length; i++) {
			var layer = {};
			var results = [];
			var resultArray = layerArray[i].childNodes;
			for(var j = 0; j < resultArray.length; j++) {
				var result = {};
				result.layerName = resultArray[j].parentNode.nodeName;
                //根据浏览器类型进入不同的方法
                if(navigator.appName=="Microsoft Internet Explorer"){
                    //IE 浏览器
                    result.result = this._analysis_StatisticsResult_results_result_IE(resultArray[j]);
                }else{
                    //谷歌浏览器
                    result.result = this._analysis_StatisticsResult_results_result_google(resultArray[j]);
                }
				results.push(result);
			}
			layer.results = results;
			layers.push(layer);
		}
		return layers;
	},

	/**
	 * 统计结果第三级结构
	 * IE浏览器
     * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param 	result
	 * @private
	 */
	_analysis_StatisticsResult_results_result_IE: function(result) {
		var object = {};
		var i = 0;
		var nodeName = result.childNodes[0].nodeName;
		if("Key" == nodeName) {
			object.Key = result.childNodes[0].text;
			i = 1;
		}
		var names = [];
		var values = [];
		for(; i < result.childNodes.length; i++) {
			var name = {};
			var value = {};
			name.name = result.childNodes[i].getAttribute("name");
			value.Value = result.childNodes[i].text;
			names.push(name);
			values.push(value);
		}
        object.name = names;
		object.values = values;
		return object;
	},

    /**
     * 统计结果第三级结构
     * 谷歌浏览器
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @param 	result
	 * @private
     */
    _analysis_StatisticsResult_results_result_google: function(result) {
        var object = {};
        var i = 0;
        var nodeName = result.childNodes[0].nodeName;
        if("Key" == nodeName) {
            object.Key = result.childNodes[0].innerHTML;
            i = 1;
        }
        var names = [];
        var values = [];
        for(; i < result.childNodes.length; i++) {
            var name = {};
            var value = {};
            name.name = result.childNodes[i].getAttribute("name");
            value.Value = result.childNodes[i].innerHTML;
            names.push(name);
            values.push(value);
        }
        object.name = names;
        object.values = values;
        return object;
    },

    /**
     * 查询成功后的回调函数，用户可以自定义此方法。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {Array(GeoGlobe.Feature)} features - 结果要素数组。
     */
	successFn: function(features){
        
    },

    /**
     * WFS查询失败响应方法，默认提示"对不起,查询失败,请查询服务是否正常"，用户可以根据需要覆盖此方法。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     */
    failFn: function(){
    	alert("对不起,查询失败,请查询服务是否正常。");
    },
    
    //私有,按图层类型分离要素
    _separateFeatures: function(features){
        var result = {};
        for(var i=0; i<features.length; i++){
            var f = features[i];
            var featureType;
            
            //如果是经GML2解析器则判断gml属性中的featureType，如果是GML3则判断type
            if (f.gml) {
                featureType = f.gml.featureType;
            }
            else {
                featureType = f.type;
            }
            
            if(!result[featureType]){
                result[featureType] = [];
            }
            result[featureType].push(f);
        }
        return result;
    },
	
    /**
     * 设置时间。时间格式：2015-5-19 12:12:01
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
     *
	 * @param {String}  time  - 结果要素数组。
     */
	setTime: function(time){
		this.time = time;
	},
	
    /**
     *  设置是否追溯。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {Boolean} userecent - 结果要素数组。
     */
	setUserecent: function(userecent){
		this.userecent = userecent;
	},
    	
	CLASS_NAME: "GeoGlobe.Query.WFSQuery"
});

GeoGlobe.Query.WFSQuery.reverseGeometryXY = function(geometry) {
	
	var geometryTypes = {
        "GeoGlobe.Geometry.Point": "Point",
        "GeoGlobe.Geometry.MultiPoint": "MultiPoint",
        "GeoGlobe.Geometry.LineString": "LineString",
        "GeoGlobe.Geometry.MultiLineString": "MultiLineString",
        "GeoGlobe.Geometry.Polygon": "Polygon",
        "GeoGlobe.Geometry.MultiPolygon": "MultiPolygon",
        "GeoGlobe.Geometry.Collection": "GeometryCollection"
    };
	var types = {
		"Point": function(geometry,types) {
			var pointx = geometry.x;
			var pointy = geometry.y;
			var point = geometry.clone(geometry);
			point.x = pointy;
			point.y = pointx;
			return point;
		},
		"LineString": function(geometry,types) {
			var lineString = geometry.clone(geometry);
			for(var i = 0; i < lineString.components.length; i++) {
				var point = types["Point"](lineString.components[i]);
				lineString.components[i] = point;
			}
			return lineString;
		},
		"Polygon": function(geometry,types) {
			var polygon = geometry.clone(geometry);
			for(var i = 0; i < polygon.components.length; i++) {
				for(var j = 0; j <polygon.components[i].components.length - 1; j++) {
					var point = types["Point"](polygon.components[i].components[j]);
					polygon.components[i].components[j] = point;
				}
			}
			return polygon;
		}
	}
	var ageometry = types[geometryTypes[geometry.CLASS_NAME]](geometry,types);
	return ageometry;
};

GeoGlobe.Format.WFSHits = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {

    wfsns: "http://www.opengis.net/wfs",
    
    featureCollection: "FeatureCollection",
    
    read: function(data){
        if (typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var featureCollectionNodes = data.documentElement;
        var numberOfFeatures = parseInt(featureCollectionNodes.getAttribute("numberOfFeatures"));
        return {
            numberOfFeatures: numberOfFeatures
        }
    }
	
});
/**
* @class GeoGlobe.Query.GeoCodingQuery
* @classdesc 地址匹配查询类。默认版本是1.0.0。
*
 * @example
 * (code)
 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
 *			version:"1.1.0"
 *		});
 * (end)
 */
GeoGlobe.Query.GeoCodingQuery = function(url, options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Query.GeoCodingQuery.DEFAULTS
    );
    var cls = GeoGlobe.Query.GeoCodingQuery["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "不支持的地址匹配服务版本: " + options.version;
    }
    return new cls(url, options);
};

GeoGlobe.Query.GeoCodingQuery.DEFAULTS = {
    "version": "1.0.0"
};

/**
 * @class GeoGlobe.Query.GeoCodingQuery.v1
 * @classdesc 地址匹配服务查询接口的抽象类,抽象类不能实例化。
 *
 * @example
 * (code)
 *      //根据范围和地址进行查询：
 * 		var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.42.76:7021/GeoCoding/geocoding");
 * 		coding.getCategoryByCode(1012001008000000,
 * 		function(GeoCoding){},function(){});
 * (end)
 */
GeoGlobe.Query.GeoCodingQuery.v1 = GeoGlobe.Class4OL({
	
	/**
	 * 服务版本，默认值是"1.0.0"。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 */
	version:"1.0.0",
	
	/**
     * 服务地址。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
     *  @type {String}
     */
	url: null,
	
	/**
     * GeoGlobe.Query.GeoCodingQuery.v1类的构造函数。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
     * @param {String} url  - 服务地址。
     * @param {Object} options   - 相关属性的设置项，可选。
     *
     * 服务版本。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
     * @type {String}
     */
	initialize: function(url, options){
		this.url = url;
        GeoGlobe.Util.extend(this,options);
		this.format = new GeoGlobe.Format.JSON();
	},
	
	/**
	 * 获取公共的参数
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param options
	 * @private
	 */
	getCommonParams: function(options) {
		var params = {
			request: "GetCategory",
			service:"GeoCoding",
			version:this.version,
			output:"json"
		};
        GeoGlobe.Util.extend(params,options);
		return params;
	},
	
	/**
	 * 根据类别名称查询类别及子类别。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param {String} name   - 类别名称。
	 * @param {Function} successFn   - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * @param {Function} failFn   - 请求失败的回调函数。
	 */
	getCategoryByName:function(name,successFn,failFn) {
		var params = this.getCommonParams();
		if(typeof name === "string" && name.length !== 0) {
			params.categoryName = name;
		}
		var failFn = failFn || this.failFn;
        GeoGlobe.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},

	/**
	 * 根据类别编码查询类别及子类别。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param {Number} code  - 类别编码。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * @param {Function}  failFn  - 请求失败的回调函数。
	 *
	 */
	getCategoryByCode: function(code,successFn,failFn) {
		var params = this.getCommonParams();
		if(typeof code === "number") {
			params.categoryCode = code;
		}
        GeoGlobe.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},
	
	/**
	 * 查询所有类别信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param {Function} successFn   - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 */
	getAllCategory: function(successFn,failFn) {
		var params = this.getCommonParams();
        GeoGlobe.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},
	
	/**
	 * 执行get请求操作
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param   params
	 * @param   successFn
	 * @param   failFn
	 * @private
	 */
	_requestCategory:function(params,successFn,failFn) {
		var failFn = failFn || this.failFn;
        GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var category = this.format.read(result.responseText);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(category);
		},failFn);
	},
	
	/**
	 * 解析返回的结果，getCoder接口查询结果第一级结构
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param json
	 * @private
	 */
	_analysis_GeoCodeResult: function(json) {
		var queryResult = {
			status:json.status
		};
		switch(json.status) {
			case "OK":
				var results = json.results;
				if(results) {
					queryResult.results = this._analysis_GeoCodeResult_results(results);
				}
			break;
			case "INVALID_REQUEST":
				
			break;
			case "NO_RESULTS":
				
			break;
			case "UNKNOWN_ERROR":
				
			break;
			default:
				queryResult = {
					requestKeyWord:json.requestKeyWord,
					count:json.count,
					statisticsLevel:json.statisticsLevel,
					statisticsLevelName:json.statisticsLevelName
				};

				if(json && json.count > 0){
					var results = json.results;
					if(results) {
						queryResult.results = this._analysis_GeoCodeResult_statistics(results);
					}
				}
			break;
		}
		return queryResult;
	},
	
	/**
	 * getCoder接口查询结果第二级结构
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param  results
	 * @private
	 */
	_analysis_GeoCodeResult_results: function(results) {
		var aresults = [];
		//如果存在results节点，那么它就是一个数组
		if(GeoGlobe.Util.isArray(results)) {
			for(var i = 0,j = results.length; i < j;i++) {
				var result = {};
				result.requestKeyWord = results[i].requestKeyWord;
				if(results[i].errorCorrectionTips) {
					result.errorCorrectionTips = results[i].errorCorrectionTips;
				}
				//匹配结果总数
				result.count = results[i].count;
				if(results[i].result) {
					result.result = this._analysis_GeoCodeResult_results_result(results[i].result);
				}
				aresults.push(result);
			}
			return aresults;
		}
	},

	/**
	 * getCoder接口按行政区划统计结果值第二级结构
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param  results
	 * @private
	 */
	_analysis_GeoCodeResult_statistics: function(results) {
		var aresults = [];
		//如果存在results节点，那么它就是一个数组
		if(GeoGlobe.Util.isArray(results)) {
			for(var i = 0,j = results.length; i < j;i++) {
				var result = {};
				if(results[i].errorCorrectionTips) {
					result.errorCorrectionTips = results[i].errorCorrectionTips;
				}

				if(results[i]) {
					result.name = results[i].name;
					result.value = results[i].value;
					result.remark = results[i].remark;
				}
				aresults.push(result);
			}
			return aresults;
		}
	},
	
	/**
	 * getCoder接口查询结果第三级结构
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param   result
	 * @private
	 */
	_analysis_GeoCodeResult_results_result: function(result) {
		var addresss = [];
		for(var i = 0,j = result.length; i < j;i++) {
			var address = {};
            var street_path = {};
			//匹配结果的类型
			address.resultType = result[i].resultType;
			//匹配地址是否为精确地址
			address.precise = result[i].precise;
			//该条匹配结果是否为摘要信息
			address.isBrief = result[i].isBrief;
			//匹配结果与请求关键字的匹配度，值域为1到100，值越大匹配度就越高
			address.score = result[i].score;
            if(result[i].addressComponent.street){
                street_path = result[i].addressComponent.street;
            }
			if(address.isBrief == false) {
				address.addressComponent = this._analysis_GeoCodeResult_results_result_address(result[i].addressComponent,address.resultType);
			}
			address.poiArray = this._analysispoiArray(result[i].poiArray);
			if(result[i].location) {
				address.location = result[i].location;
			}
			//TODO:referenceAddressArray
			if(address.precise == 0) {
				address.referenceAddressArray = result[i].referenceAddressArray;
			}
            if(street_path){
                address.street_path = street_path;
            }
			addresss.push(address);
		}
		return addresss;
	},
	
	/**
	 * getCoder接口查询结果第四级结构，当前匹配结果的地址详细信息
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param addressComponent
	 * @param 	resultType
	 * @private
	 */
	_analysis_GeoCodeResult_results_result_address:function(addressComponent,resultType) {
		var addressC = {
			country: addressComponent.country
		};
		//行政区划的第二级-省、直辖市、自治区
		if(addressComponent.province) {
			addressC.province = addressComponent.province;
		}
		//行政区划第三级-市
		if(addressComponent.city) {
			addressC.city = addressComponent.city;
		}
		//行政区划第四级-区或县
		if(addressComponent.district) {
			addressC.district = addressComponent.district;
		}
		//行政区划第五级-乡镇
		if(addressComponent.town) {
			addressC.town = addressComponent.town;
		}
		if(addressComponent.street) {
			addressC.street = {
				name:addressComponent.street.name
			};
			
			if(resultType === "street") {
				//需要增加对线的json串的解析
				if(addressComponent.street.geometry) {
					//var sgeometry = addressComponent.street.geometry;
					var sgeometry = this.format.read(addressComponent.street.geometry);
					var streetGeometry = null;
					if(sgeometry["paths"]) {
						//这个需要做测试，这里的几何信息一般来说是线，不过也有可能不是线
						streetGeometry = this._getGeometry(sgeometry);
						addressC.street.geometry = streetGeometry;
					}else if(sgeometry["rings"]){
						streetGeometry = this._getGeometry(sgeometry);
						addressC.street.geometry = streetGeometry;
					}else if(sgeometry["x"] && sgeometry["y"]){
						streetGeometry = this._getGeometry(sgeometry);
						addressC.street.geometry = streetGeometry;
					}
				}
			}
		}
		if(addressComponent.streetNumber) {
			addressC.streetNumber = addressComponent.streetNumber;
		}
		if(addressComponent.buildingNumber) {
			addressC.buildingNumber = addressComponent.buildingNumber;
		}
		if(resultType === "adminArea") {
			//当前匹配最小级行政区划的空间信息,本属性需要被转换成GeoGlobe.Geometry类型
			if(addressComponent.geometry) {
				//var geometry = addressComponent.geometry;
				var geometry = this.format.read(addressComponent.geometry);
				var areaGeometry = null;
				//如果它是面，我们解析它
				if(geometry["rings"]) {
					areaGeometry = this._getGeometry(geometry);
					addressC.geometry = areaGeometry;
				}else if(geometry["paths"]) {
					areaGeometry = this._getGeometry(geometry);
					addressC.geometry = areaGeometry;
				}else if(typeof geometry["x"] === "number" && typeof geometry["y"] === "number") {
					addressC.geometry = this._getGeometry(geometry);
				}
			}
			//当前匹配最小级行政区划下属的其它行政区划名称，多个以逗号隔开
			if(addressComponent.subordinate) {
				addressC.subordinate = addressComponent.subordinate;
			}
			//行政区的邮政编码
			if(addressComponent.zipCode) {
				addressC.zipCode = addressComponent.zipCode;
			}
			//电话长途区划
			if(addressComponent.callingCode) {
				addressC.callingCode = addressComponent.callingCode;
			}
		}
		return addressC;
	},
	
	/**
	 * result节点的儿子节点
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param poiArray
	 * @private
	 */
	_analysispoiArray: function(poiArray) {
		var pointFeatures = [];
		for(var i = 0,j = poiArray.length; i < j;i++) {
			var point = {};
			for(var pro in poiArray[i]) {
				point[pro] = poiArray[i][pro];
			}
			if("" != point.geometry && undefined != point.geometry){
				var geometry = this.format.read(point.geometry);
				point.geometry = this._getGeometry(geometry);
			}
			pointFeatures.push(point);
		}
		return pointFeatures;
	},
	
	/**
	 * result节点的儿子节点
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param location
	 * @private
	 */
	_analysisLocation:function(location) {
		
	},
	
	/**
	 * 得到GeoGlobe几何对象
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param {Object} geometry
	 * @private
	 */
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new GeoGlobe.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				var geometry = new GeoGlobe.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
				//需要增加多点类型
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
	
	/**
	 * 将几何信息的json表示转换成
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param {Object} geometry
	 * @private
	 */	
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(GeoGlobe.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new GeoGlobe.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(GeoGlobe.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new GeoGlobe.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new GeoGlobe.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new GeoGlobe.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(GeoGlobe.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new GeoGlobe.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new GeoGlobe.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new GeoGlobe.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	/**
     * 请求失败的回调函数，可以用自定义函数覆盖。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
     *  @type {Function}
     */
	failFn: function(error) {
		if(typeof error == "string") {
			alert(error);
		}
		alert("对不起，查询请求失败！请检查地址匹配服务是否正常运行。\n" + 
				"当前服务地址为：" + this.url);
	},

	CLASS_NAME: "GeoGlobe.Query.GeoCodingQuery.v1"
});

/**
 * @class GeoGlobe.Query.GeoCodingQuery.v1_0_0
 * @classdesc 地址匹配服务查询接口1.0.0版本，继承GeoGlobe.Query.GeoCodingQuery.v1，本类可以实现如下功能：
 *
 * > 1.根据地址(例如：湖北省武汉市江夏区武大园一路9号)获取地理坐标(例如纬度29.58123和经度113.41321)或者执行反向转换。
 * > 2.根据地理坐标获取地址信息。
 * > 3.可以根据地名地址分类名称或者地名地址分类编码获取地名地址分类信息。
 * > 说明:本类提供的五个接口的成功回调的返回内容存在两种情况：第一：是返回json对象，第二：是返回xml串。如果返回xml串，
 * > 表示服务器内部发生错误或者客户端解析服务返回的结果时，发生了错误。
 *
 */
GeoGlobe.Query.GeoCodingQuery.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Query.GeoCodingQuery.v1, {
	
	/**
     * GeoGlobe.Query.GeoCodingQuery.v1_0_0类的构造函数。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
     * @param  {String} url  - 服务地址。
     * @param  {Object} options  - 相关属性的设置项，可选。
     *
     * 服务版本。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
     *  @type {String}
     */
	
	/**
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String | Array(String)} address  - (必选) 查询的地址名称集合。
	 * @param {Integer} categoryCode  - (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * @param {GeoGlobe.LngLatBounds | GeoGlobe.Geometry.Polygon} extent  - (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * @param {Boolean} fuzzyMatch  - (可选) 是否模糊匹配，true表示精确匹配，false表示模糊匹配。默认值为false。
	 * @param {String} resultType   - (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount  - (可选) ：查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer}  startPosition  - (可选) ： 从第几条开始查询，缺省值是1。
	 * 无customWeight参数 ，1.0.0版本当前只按匹配度排序。
	 * 
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.0.0"
	 *		});
	 * 		coding.addressesToLocations({
	 *			extent:GeoGlobe.LngLatBounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {},function() {});
	 * (end)
	 */
	addressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		if(typeof options.address === "string") {
			params.address = options.address;
		}else if(GeoGlobe.Util.isArray(options.address)) {
			var address = "";
			for(var i = 0; i < options.address.length;i++) {
				address += (options.address[i] + ",");
			}
			address = address.substr(0, address.length - 1);
			params.address = address;
		}else if(options.address == undefined || options.address == null) {
			throw "address是必选参数！";
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = options.categoryCode;
		}
		if(options.extent instanceof GeoGlobe.LngLatBounds) {
			params.bbox = options.extent.toBBOX(null,true);
		} else if(options.extent instanceof GeoGlobe.Geometry.Polygon) {
			//params.bbox = options.extent.getComponentsString();
			var polygon = options.extent;
			var strings = [];
			for(var i=0, len=polygon.components.length; i<len; i++) {
				var items = polygon.components[i].components;
				for(var j = 0; j < items.length; j++){
					strings.push(items[j].toShortString());
				}
			}
			params.bbox = strings.join(",");
		}
		if(typeof options.fuzzyMatch === "boolean") {
			params.fuzzyMatch = options.fuzzyMatch;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}

        GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				//var GeoCodingResult = this._analysis_GeoCodeResult(json);
                if(params.resultType == "result"){
                    var GeoCodingResult = this._parseQueryResultToFeature(json);
                }else{
                    var GeoCodingResult = this._analysis_GeoCodeResult(json);
                }
                //var res = this._parseQueryResultToFeature_v_0(GeoCodingResult);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
	},

	/**
	 * 根据位置查找匹配的地址信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {GeoGlobe.LonLat} lonlat   - (必选) 位置。
	 * @param {Number} tolerance  - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit  - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {String} resultType  - (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition  - (可选) 从第几条开始查询，缺省值是1。
	 * 
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.0.0"
	 *		});
	 * 		coding.locationToAddresses({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	locationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		if(options.lonlat) {
			params.latlng = options.lonlat.lat+","+options.lonlat.lng;
		}else  {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
        GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				//var GeoCodingResult = this._analysis_GeoCodeResult(json);
                if(params.resultType == "result"){
                    var GeoCodingResult = this._parseQueryResultToFeature(json);
                }else{
                    var GeoCodingResult = this._analysis_GeoCodeResult(json);
                }
                //var res = this._parseQueryResultToFeature_v_0(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult,json);
		},this.failFn);
	},
	/**
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Feature} – 地址信息要素。
	 * @param {Function} failFn   - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String| Array(String)} address  - (可选) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * @param {Integer} categoryCode  - (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * @param {GeoGlobe.LngLatBounds} extent  - (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * @param {String} resultType  - (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition  - (可选) 从第几条开始查询，缺省值是1。
	 * @param {Boolean} semanticAnalysis  - (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter  - (可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocations({
	 *			extent:GeoGlobe.LngLatBounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 		},function() {});
	 * (end)
	 */
	getLocations: function(options, successFn, failFn){
		this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn)
	},
	
	/**
	 * 根据地址匹配查询参数查询匹配的地址信息-分页查询。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Featur } – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String| Array(String)} address  - (可选) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * @param categoryCode {Integer}  - (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * @param {GeoGlobe.LngLatBounds} extent  - (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Boolean} semanticAnalysis  - (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter  - (可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocationsByPage({
	 *			extent:GeoGlobe.LngLatBounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 		},function() {});
	 * (end)
	 */
	getLocationsByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * 根据位置查找匹配的地址信息。
	 *  @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Feature } – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {GeoGlobe.LonLat} lonlat  - (必选) 位置。
	 * @param {Number} tolerance   -  (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit  - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {String}resultType  -  (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition  - (可选) 从第几条开始查询，缺省值是1。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddresses({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddresses: function(options, successFn, failFn){
		this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn);
	},
	
	/**
	 * 根据位置查找匹配的地址信息-分页查询。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Feature} – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {GeoGlobe.LonLat} lonlat  - (必选) 位置。
	 * @param {Number} tolerance  - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit  - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddressesByPage({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddressesByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * 根据地址/坐标匹配查询结果解析为包含状态和feature数组的对象
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} params  - 键值对
	 *
	 * @returns {Object}  - 包含状态和feature数组的对象
	 * @private
	 */
	_parseQueryResultToFeature: function(queryResult){
		var features = [];
		if(queryResult.status == "OK"){
			if(queryResult.results){
				for(var i = 0; i < queryResult.results.length; i++){
					var result = queryResult.results[i].result;
					if(result){
						for(var j = 0; j < result.length; j++){
							var attribute = {};
							var geometry = null;
							attribute.requestKeyWord = queryResult.results[i].requestKeyWord;
							
							if(GeoGlobe.Util.isArray(result[j].poiArray)){
								for(var k = 0; k < result[j].poiArray.length; k++){
									attribute.CONTINENT = result[j].poiArray[k].CONTINENT;
									attribute.GBCODE = result[j].poiArray[k].GBCODE;
									attribute.STANDARDNAME = result[j].poiArray[k].STANDARDNAME;
									attribute.name = result[j].poiArray[k].name;
								}
							}
							if(result[j].addressComponent){
								var addressComponent = result[j].addressComponent;
								attribute.address = this._getAddress(addressComponent, attribute.name);
								attribute.country = result[j].addressComponent.country;
								attribute.province = result[j].addressComponent.province;
								attribute.city = result[j].addressComponent.city;
								attribute.district = result[j].addressComponent.district;
								if(result[j].addressComponent.street){
									attribute.streetName = result[j].addressComponent.street.name;
                                    attribute.streetgeometry = result[j].addressComponent.street.geometry;
								}else{
									attribute.streetName = "";
								}
								attribute.streetNumber = result[j].addressComponent.streetNumber;
							}
							if(result[j].location){
								if(result[j].location.lng){
									attribute.lng = result[j].location.lng;
								}
								if(result[j].location.lat){
									attribute.lat = result[j].location.lat;
								}
								geometry = new GeoGlobe.Geometry.Point(result[j].location.lng, result[j].location.lat);
							}
							
							attribute.isBrief = result[j].isBrief;
							attribute.precise = result[j].precise;
							attribute.resultType = result[j].resultType;
							attribute.score = result[j].score;
							//创建feature
							var feature = new GeoGlobe.Feature(geometry,attribute);
							features.push(feature);
						}
					}
				}
			}
		}
        var gjformat = new GeoGlobe.Format.GeoJSON();
        var geojsonStr = gjformat.write(features);
        var jsonformat = new GeoGlobe.Format.JSON;
        var geojsonFeature = jsonformat.read(geojsonStr);
		return {
			status: queryResult.status,
			features: features,
            geojsonFeatures:geojsonFeature
		};
	},
	
	/**
     * 拼装详细地址。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
     * @param {Object} addressComponent  - 地址对象。
     * @param {String}  name  - 名称。
     *
     * @returns {String}  - 详细地址。
	 * @private
     */
	_getAddress: function(addressComponent, name){
		var address = "";
		if(addressComponent["country"]){
			address += addressComponent["country"];
		}
		if(addressComponent["province"]){
			address += addressComponent["province"];
		}
		if(addressComponent["city"]){
			address += addressComponent["city"];
		}
		if(addressComponent["district"]){
			address += addressComponent["district"];
		}
		if(addressComponent["street"]){
			if(addressComponent["street"]["name"]){
				address += addressComponent["street"]["name"];
			}
			/*if(addressComponent["street"]["streetNumber"]){
				address += addressComponent["street"]["streetNumber"]+"号";//门牌号
			}*/
			if(addressComponent["streetNumber"]){
				address += addressComponent["streetNumber"]+"号";//门牌号
			}
		}
		if(name){ //名称
			address += name;
		}
		return address
	},
	
	CLASS_NAME: "GeoGlobe.Query.GeoCodingQuery.v1_0_0"
});

/**
 * @class GeoGlobe.Query.GeoCodingQuery.v1_1_0
 * @classdesc 地址匹配服务查询接口1.1.0版本，继承GeoGlobe.Query.GeoCodingQuery.v1类，本类可以实现如下功能：
 *
 * > 1.根据地址(例如：湖北省武汉市江夏区武大园一路9号)获取地理坐标(例如纬度29.58123 和经度113.41321)或者执行反向转换。
 * > 2.根据地理坐标获取地址信息。
 * > 3.可以根据地名地址分类名称或者地名地址分类编码获取地名地址分类信息。
 * > 4.可以根据多个地址信息查询到地理坐标信息。
 * > 5.可以根据多个地理坐标值获取地址信息。
 * > 说明:本类提供的五个接口的成功回调的返回内容存在两种情况：第一：是返回json对象，第二：是返回xml串。如果返回xml串，
 * > 表示服务器内部发生错误或者客户端解析服务返回的结果时，发生了错误。
 *
 */
GeoGlobe.Query.GeoCodingQuery.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Query.GeoCodingQuery.v1, {
	
	/**
	 * 数据请求方式，默认值是"get"。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 */
	method: "get",
	
	/**
     * GeoGlobe.Query.GeoCodingQuery.v1_1_0类的构造函数。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
     * @param {String} url  - 服务地址。
     * @param {Object} options  - 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * 服务版本。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
     */
	initialize: function(url, options){
        GeoGlobe.Util.extend(this,options);
		this.filterFormat = new GeoGlobe.Format.Filter();
        GeoGlobe.Query.GeoCodingQuery.v1.prototype.initialize.apply(this, arguments);
	},
	
	/**
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String | Array(String)} address  - (可选，address和categoryCode必选一) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * @param {Integer} categoryCode  - (可选，address和categoryCode必选一) 类别编码，该编码值可以通过获取分类的接口获取。
	 * @param {GeoGlobe.Bounds | GeoGlobe.Geometry.Polygon} extent  - (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * @param {String}  resultType  - (可选) 返回匹配结果的类型。 可供选择的值：(1)hits：返回匹配结果的总数；(2)result：返回匹配结果；(3)statistics：统计结果值。缺省值：result。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition  -  (可选) 从第几条开始查询，缺省值是1。
	 * @param {Boolean} semanticAnalysis  - (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter  -(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @param {Integer} statisticsLevel  - (可选) 统计级别。可供选择的值：1(省级)；2(市(县)级)；3(区级)。默认值为2。
	 * @param {Boolean} customWeight  - (可选) 是否启动自定义权重排序，缺省为true。如设置为false，则按匹配度排序。
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.addressesToLocations({
	 *			extent:GeoGlobe.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {},function() {});
	 * (end)
	 */
	addressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		params.reverseMatch = false;
		if(typeof options.address === "string") {
			params.keyword = options.address;
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = options.categoryCode;
		}
		if((options.address == undefined || options.address == null) && 
				(options.categoryCode == undefined || options.categoryCode == null)) {
			throw "address是必选参数！";
		}
		if(options.extent instanceof GeoGlobe.LngLatBounds) {
			params.bbox = options.extent.toBBOX(null,true);
		} else if(options.extent instanceof GeoGlobe.Geometry.Polygon) {
			//params.bbox = options.extent.getComponentsString();
			var polygon = options.extent;
			var strings = [];
			for(var i=0, len=polygon.components.length; i<len; i++) {
				var items = polygon.components[i].components;
				for(var j = 0; j < items.length; j++){
					strings.push(items[j].toShortString());
				}
			}
			params.bbox = strings.join(",");
		}
		if(options.filter instanceof GeoGlobe.Filter) {
			var domFilter = this.filterFormat.write(options.filter);
			var filterStr = GeoGlobe.Format.XML.prototype.write.apply(
				this.filterFormat, [domFilter]
			);
			params.filter = filterStr;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(options.resultType == "statistics") {
			params.statisticsLevel = options.statisticsLevel;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		if(typeof options.semanticAnalysis  === "boolean") {
			params.semanticAnalysis = options.semanticAnalysis;
		}
		if(typeof options.customWeight  === "boolean") {
			params.customWeight = options.customWeight;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		
	},
	
	/**
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object}	params  - 键值对
	 * @param {Function}  successFn  - 成功回调
	 * @param {Function} failFn  - 失败回调
	 * @private
	 */
	_getCodingRequest: function(params,successFn,failFn) {
		if(this.method == "get") {
			GeoGlobe.loadURL(this.url,params,this,function(result) {
				try{
					var json = this.format.read(result.responseText);
                    //_parseQueryResultToFeature
                    if(params.resultType == "result"){
                        var GeoCodingResult = this._parseQueryResultToFeature(json);
                    }else{
                        var GeoCodingResult = this._analysis_GeoCodeResult(json);
                    }

				}catch(e) {
					successFn(result.responseText);
					return;
				}
				successFn(GeoCodingResult);
			},this.failFn);
		}else {
			var paramsStr = GeoGlobe.Util.getParameterString(params);
            GeoGlobe.Request.POST({
	            url: this.url,
	            data: paramsStr,
	            success: function(result) {
					try{
						var json = this.format.read(result.responseText);
						var GeoCodingResult = this._analysis_GeoCodeResult(json);
					}catch(e) {
						successFn(result.responseText);
						return;
					}
					successFn(GeoCodingResult);
				},
	            failure: this.failFn,
	            scope: this
	        });
		}
	},
	
	/**
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object}	params  - 键值对
	 * @param	options
	 * @private
	 */
	_setGeoCoderCommonProperty: function(params,options) {
		if(typeof options.sortFields  === "string") {
			params.sortFields = options.sortFields;
		}
		if(typeof options.scoreFilter  === "string") {
			params.scoreFilter = options.scoreFilter;
		}
	},
	
	/**
	 * 根据位置查找匹配的地址信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {GeoGlobe.LonLat} lonlat - (必选) 位置。
	 * @param {Number}  tolerance  - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {String} resultType  - (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition - (可选) 从第几条开始查询，缺省值是1。
	 * @param {String} sortFields - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * 
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.locationToAddresses({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *
	 *		},function() {});
	 * (end)
	 */
	locationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		params.reverseMatch = true;
		if(options.lonlat) {
			params.keyword = options.lonlat.lat+","+options.lonlat.lng;
		}else  {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(options.resultType == "statistics") {
			params.statisticsLevel = options.statisticsLevel;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		if(typeof options.customWeight  === "boolean") {
			params.customWeight = options.customWeight;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
	},

	/**
	 * 根据一到多个地址查询坐标位置信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param  {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {Array(String)} address  - (必选) 查询的地址名称集合。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter  - (可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95
	 * @param {Integer} singleKeywordResultCount  - (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 *
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchAddressesToLocations({
	 *			address:["小学"],
	 *			singleKeywordResultCount:2,
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	batchAddressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "BatchGeoCoder",
			service:"GeoCoding"
		});
		params.reverseMatch = false;
		if(GeoGlobe.Util.isArray(options.address)) {
			var address = "";
			for(var i = 0; i < options.address.length;i++) {
				address += (options.address[i] + ",");
			}
			address = address.substr(0, address.length - 1);
			params.keywords = address;
		}else if(options.address == undefined || options.address == null) {
			throw "address是必选参数！";
		}
		if(typeof options.singleKeywordResultCount === "number") {
			params.singleKeywordResultCount  = options.singleKeywordResultCount;
		}
		if(options.filter instanceof GeoGlobe.Filter) {
			var domFilter = this.filterFormat.write(options.filter);
			var filterStr = GeoGlobe.Format.XML.prototype.write.apply(
				this.filterFormat, [domFilter]
			);
			params.filter = filterStr;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		/*
         GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
		*/
	},
	
	/**
	 * 根据多个坐标位置查找匹配的地址信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param Array(GeoGlobe.LonLat)} lonlats  - {(必选) 坐标位置数组。
	 * @param {Number} tolerance  - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit  - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @param {Integer} singleKeywordResultCount  - (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 *   
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchLocationToAddresses({
	 *			lonlats:[new GeoGlobe.LonLat(123.43888042, 41.759929371),new GeoGlobe.LonLat(123.423848649, 41.771748608)],
	 *			singleKeywordResultCount:2,
	 *			tolerance:0.5,
	 *			unit:"degree",
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *
	 *		},function() {});
	 * (end)
	 */
	batchLocationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "BatchGeoCoder",
			service:"GeoCoding"
		});
		params.reverseMatch = true;
		if(options.lonlats instanceof GeoGlobe.LonLat) {
			options.lonlats = [options.lonlats];
		//	params.keywords = options.lonlat.lat+","+options.lonlat.lng;
		}else  if(!GeoGlobe.Util.isArray(options.lonlats)) {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(GeoGlobe.Util.isArray(options.lonlats)) {
			var lonlatsStr = "";
			for(var i = 0; i < options.lonlats.length;i++) {
				lonlatsStr += options.lonlats[i].lat+","+options.lonlats[i].lng+";";
			}
			lonlatsStr = lonlatsStr.substr(0, lonlatsStr.length - 1);
			params.keywords = lonlatsStr;
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.singleKeywordResultCount === "number") {
			params.singleKeywordResultCount  = options.singleKeywordResultCount;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		/*
         GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
		*/
	},
	
	/**
     * 拼装详细地址。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} addressComponent  - 地址对象。
     * @param {String} name  - 名称。
     *
     * @returns {String}  - 详细地址。
	 * @private
     */
	_getAddress: function(addressComponent, name){
		var address = "";
		if(addressComponent["country"]){
			address += addressComponent["country"];
		}
		if(addressComponent["province"]){
			address += addressComponent["province"];
		}
		if(addressComponent["city"]){
			address += addressComponent["city"];
		}
		if(addressComponent["district"]){
			address += addressComponent["district"];
		}
		if(addressComponent["street"]){
			if(addressComponent["street"]["name"]){
				address += addressComponent["street"]["name"];
			}
			/*if(addressComponent["street"]["streetNumber"]){
				address += addressComponent["street"]["streetNumber"]+"号";//门牌号
			}*/
			if(addressComponent["streetNumber"]){
				address += addressComponent["streetNumber"]+"号";//门牌号
			}
		}
		if(name){ //名称
			address += name;
		}
		return address
	},
	
	
	/**
	 * 根据地址匹配查询参数查询匹配的地址信息。成功回调返回的结果数据为地址信息要素({GeoGlobe.Feature})。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object }options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{GeoGlobe.Feature} – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String | Array(String)} address  - (可选，address和categoryCode必选一) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * @param {Integer} categoryCode  - (可选，address和categoryCode必选一) 类别编码，该编码值可以通过获取分类的接口获取。
	 * @param {GeoGlobe.Bounds} extent  - (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * @param {String} resultType  - (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition  - (可选) 从第几条开始查询，缺省值是1。
	 * @param {Boolean} semanticAnalysis  - (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter  - (可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocations({
	 *			extent:GeoGlobe.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getLocations: function(options, successFn, failFn){
		this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn)
	},
	
	/**
	 * 根据地址匹配查询参数查询匹配的地址信息-分页查询。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String| Array(String)} address  - (可选，address和categoryCode必选一) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * @param {Integer} categoryCode  - (可选，address和categoryCode必选一) 类别编码，该编码值可以通过获取分类的接口获取。
	 * @param {GeoGlobe.Bounds} extent -  (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * @param {Integer} maxCount  -  (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Boolean} semanticAnalysis  - (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * @param {String} sortFields - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter - (可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocationsByPage({
	 *			extent:GeoGlobe.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getLocationsByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * 根据位置查找匹配的地址信息。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {GeoGlobe.LonLat} lonlat - (必选) 位置。
	 * @param {Number} tolerance - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {String} resultType - (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition - (可选) 从第几条开始查询，缺省值是1。
	 * @param {String} sortFields - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddresses({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddresses: function(options, successFn, failFn){
		this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn);
	},
	
	/**
	 * 根据位置查找匹配的地址信息-分页查询。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {GeoGlobe.LonLat} lonlat  - (必选) 位置。
	 * @param {Number} tolerance  - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit  - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {Integer} maxCount   - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddressesByPage({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddressesByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * 根据多个坐标位置查找匹配的地址信息。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options - 请求参数。
	 * @param {Function} successFn  -  请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * @param {Function} failFn -  请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {Array(GeoGlobe.LonLat)} lonlats  - (必选) 坐标位置数组。
	 * @param {Number} tolerance  - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit  - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @param {Integer} singleKeywordResultCount  - (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 *   
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchGetAddresses({
	 *			lonlats:[new GeoGlobe.LonLat(123.43888042, 41.759929371),new GeoGlobe.LonLat(123.423848649, 41.771748608)],
	 *			singleKeywordResultCount:2,
	 *			tolerance:0.5,
	 *			unit:"degree",
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			//返回值 GeoCodingResult - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	batchGetAddresses: function(options, successFn, failFn){
		this.batchLocationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult));
		}, this), failFn);
	},
	
	/**
	 * 根据一到多个地址查询坐标位置信息。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Feature} – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {Array(String)} address  - (必选) 查询的地址名称集合。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter  - (可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95
	 * @param {Integer} singleKeywordResultCount  - (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 * 
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchGetLocations({
	 *			address:["小学"],
	 *			singleKeywordResultCount:2,
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			//返回值 GeoCodingResult - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	batchGetLocations: function(options, successFn, failFn){
		this.batchAddressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult));
		}, this), failFn);
	},
	
	/**
	 * 根据地址/坐标匹配查询结果解析为包含状态和feature数组的对象。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} params  - 键值对
	 *
	 * @returns {Object}   - 包含状态和feature数组的对象
	 * @private
	 */
	_parseQueryResultToFeature: function(queryResult){
		var features = [];
		if(queryResult.status == "OK"){
			if(queryResult.results){
				for(var i = 0; i < queryResult.results.length; i++){
					var result = queryResult.results[i].result;
					if(result){
						for(var j = 0; j < result.length; j++){
							var attribute = {};
							var geometry = null;
							attribute.requestKeyWord = queryResult.results[i].requestKeyWord;
							
							if(GeoGlobe.Util.isArray(result[j].poiArray)){
								for(var k = 0; k < result[j].poiArray.length; k++){
									attribute.CONTINENT = result[j].poiArray[k].CONTINENT;
									attribute.GBCODE = result[j].poiArray[k].GBCODE;
									attribute.STANDARDNAME = result[j].poiArray[k].STANDARDNAME;
									attribute.name = result[j].poiArray[k].name;
								}
							}
							if(result[j].addressComponent){
								var addressComponent = result[j].addressComponent;
								attribute.address = this._getAddress(addressComponent, attribute.name);
								attribute.country = result[j].addressComponent.country;
								attribute.province = result[j].addressComponent.province;
								attribute.city = result[j].addressComponent.city;
								attribute.district = result[j].addressComponent.district;
								if(result[j].addressComponent.street){
									attribute.streetName = result[j].addressComponent.street.name;
                                    attribute.streetgeometry = result[j].addressComponent.street.geometry;
								}else{
									attribute.streetName = "";
								}
								attribute.streetNumber = result[j].addressComponent.streetNumber;
							}
							if(result[j].location){
								if(result[j].location.lng){
									attribute.lng = result[j].location.lng;
								}
								if(result[j].location.lat){
									attribute.lat = result[j].location.lat;
								}
								geometry = new GeoGlobe.Geometry.Point(result[j].location.lng, result[j].location.lat);
							}
							
							attribute.isBrief = result[j].isBrief;
							attribute.precise = result[j].precise;
							attribute.resultType = result[j].resultType;
							attribute.score = result[j].score;
							//创建feature
							var feature = new GeoGlobe.Feature(geometry,attribute);
							features.push(feature);
						}
					}
				}
			}
		}

        var gjformat = new GeoGlobe.Format.GeoJSON();
        var geojsonStr = gjformat.write(features);
        var jsonformat = new GeoGlobe.Format.JSON;
        var geojsonFeature = jsonformat.read(geojsonStr);
		return {
			status: queryResult.status,
			features: features,
            geojsonFeatures:geojsonFeature
		};
	},
	
	CLASS_NAME: "GeoGlobe.Query.GeoCodingQuery.v1_1_0"
});
 /**
  * @class GeoGlobe.Service
  * @classdesc 服务类。本类是服务类的基类，需要由子类去实现。
  *
  */
GeoGlobe.Service = GeoGlobe.Class({
	
	/**
     * 服务名称。
     * @memberof GeoGlobe.Service.prototype
     * @type {String}
     */
	name: null,
	
	/**
     *  服务地址。
     * @memberof GeoGlobe.Service.prototype
     * @type {String}
     */	
	url: null,
	
	/**
     * 服务版本号。
     * @memberof GeoGlobe.Service.prototype
     * @type {String}
     */		
	version: null,

	
	/**
     *用户名。
     * @memberof GeoGlobe.Service.prototype
     * @type {String}
     */			
	userid: "test@liferay.com",
	
	/**
     * GeoGlobe.Service.Bus类的构造函数。
     * @memberof GeoGlobe.Service.prototype
     * @param  {String} name  -  服务名称。
     * @param  {String} url  - 服务地址。
     * @param  {Object} options  - 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
        GeoGlobe.Util.extend(this, options);
	},


	/**
     * 获取服务能力描述信息，由子类实现。
     * @memberof GeoGlobe.Service.prototype
     * @param  {Function} successFn - 请求成功的回调函数。
     * @param  {Function} failFn - 请求失败的回调函数。
     */		
	getCapabilities: function(successFn,failFn){
		//由子类实现
	},

	/**
     * 检查服务是否存在，由子类实现。
     * @memberof GeoGlobe.Service.prototype
     */		
	isExist: function(){
		//由子类实现
	},


	/**
     * 服务操作失败响应回调函数。
     *  @memberof GeoGlobe.Service.prototype
     * @param  {Object} operate - 失败的操作类型。
     */		
	failFn: function(operate){
		alert("服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" + 
			"请求地址：" + this.url + "\n操作类型：" + operate);
	},

	//将结果解析成XML
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new GeoGlobe.Format.XML();
		return xmlParser.read(doc);
	},
	
	//对返回结果进行检查，是否为错误信息
	_checkIsError: function(xmlString){
		var xmlparser = new GeoGlobe.Format.XML();
		var xml = xmlparser.read(xmlString);
		var exceptions = xml.selectNodes("ServiceExceptionReport");
        if(exceptions.length > 0){
            return this._parseToJSON(xmlString);
        }
        return null;
	},
	
	//对解析后的JSON对象进行判断是否为服务抛出的异常
	_isException:function(result){
		if(result && result.ServiceExceptionReport){
			return true;
		}
		return false;
		
	},
	
	_parseToJSON: function(result){
		var parser = new GeoGlobe.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	CLASS_NAME: "GeoGlobe.Service"
	
});
/**
 * @class GeoGlobe.Service.WFST
 * @classdesc OGC-WFST服务类。继承GeoGlobe.Service类，Web要素服务-T（Web Feature Service-Transaction简称WFST）遵循OGC的WFS1.0.0规范，
 * 本服务提供对要素的增加、修改、删除等事务操作。
 *
 */
GeoGlobe.Service.WFST = GeoGlobe.Class4OL(GeoGlobe.Service, {
	
    /**
     * 值为true时，为(x,y)顺序。值为false时，为(y,x)顺序。
     * @memberof GeoGlobe.Service.WFST.prototype
     *  @type {Boolaen}
     */ 
    xy: true,

    /**
     * GeoGlobe.Service.WFST类的构造函数。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {String} name  -  服务名称。
     * @param {String} url  - 服务地址。
     * @param {Object} options  - 实例的选项设置，此参数可选。
     */
    initialize: function(name, url, options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * 获取服务能力描述信息。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },

    /**
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @returns {Boolean}  - 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },

    /**
     *  获取要素类型描述操作。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {Object} params  - 请求参数，具体内容参考OGC-WFS标准。
     *   params有三个参数(service,version,request)默认可以不填，其中version默认值是1.0.0，如果要设置其他版本请设置version参数。
     * @param {Function} successFn  -  请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     *
     * @example
     * (code)
     * serviceObj.describeFeatureType({
     *     TypeName: "RES1_T_PN"
     * }, showResult);
     * (end)
     */
    describeFeatureType: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "WFS",
            VERSION: "1.0.0",
            REQUEST: "DescribeFeatureType"
        };
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * 获取要素操作。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {Object} params  - 请求参数，具体内容参考OGC-WFS标准。
     * @param {String} TypeName  -  必选 类型名称。
     * @param {String} version  - 版本，默认值是1.0.0,如果用户请求的服务版本不是1.0.0，请设置该参数。
     * @param {Integer} MaxFeatures  - 可选 查询的返回的结果总数。
     * @param  {GeoGlobe.Filter} filter  - 可选 过滤器。
     *  以上是常用的属性，其他属性请参考OGC-WFS标准。
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  -  请求失败的回调函数。
     *
     * @example
     * (code)
     * 	 serviceObj.getFeature({
     *      TypeName: "RES1_T_PN",
     *      MaxFeatures: 10
     *   }, function(){});
     * (end)
     */
    getFeature: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "WFS",
            VERSION: "1.0.0",
            REQUEST: "GetFeature"
        };
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * 锁定要素操作。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {Object} params - 请求参数，具体内容参考OGC-WFS标准。
     * @param {String} typeName - 必选 指定操作的图层类型名称。
     * @param {String}  version - 可选 版本号，默认值是1.0.0，如果用户请求的服务版本不是1.0.0，请设置该参数。
     * @param {Number} expiry - 可选 锁定的分钟数，如果没有则默认为1分钟。
     * @param {String} lockAction - 可选 指定如何获得锁，如果没有则默认为"ALL"。
     * @param {GeoGlobe.Filter} filter -  可选 操作要素的条件过滤器。
     * @param {Function} successFn - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    lockFeature: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            service: "WFS",
            version: "1.0.0",
            request: "LockFeature",
            expiry: 1,
            lockAction: "ALL"
        };
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
        
		//解析filter对象，转换为XML字符串。
		var filterXMLString = this._parserFilterToString(params.filter);
        
        var requestStringTemplate = '<?xml version="1.0" encoding="UTF-8"?>' +
        '<LockFeature version="${version}" service="${service}" lockAction="${lockAction}" expiry="${expiry}" ' +
	        'xmlns:wfs=" http://www.opengis.net/wfs" ' +
	        'xmlns:gml=" http://www.opengis.net/gml" ' +
	        'xmlns:myns=" http://www.someserver.com/myns" ' +
	        'xmlns:ogc=" http://www.opengis.net/ogc" ' +
	        'xmlns:xsi=" http://www.w3.org/2001/XMLSchema-instance" ' +
	        'xsi:schemaLocation="http://www.opengis.net/wfs ../wfs/1.1.0/WFS.xsd">' +
	        '<Lock typeName="${typeName}">' +
		        '${filterXMLString}' +
	        '</Lock>' +
        '</LockFeature>';
        
        var requestString = GeoGlobe.String.format(requestStringTemplate, {
            version: params.version,
            service: params.service,
            lockAction: params.lockAction,
            expiry: params.expiry,
            typeName: params.typeName,
            filterXMLString: filterXMLString
        });
        
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.request);
            };
        }
        
        var xhr = new GeoGlobe.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
        
        //        GeoGlobe.loadURL(url, params, this, function(result){
        //            successFn(result);
        //        }, failFn);
    },
    
    /**
     * 要素的事务操作，可以对服务中的要素内容进行增加、删除和修改操作。
     * @memberof GeoGlobe.Service.WFST.prototype
     *  @param {Object} params  - 请求参数，具体内容参考OGC-WFS标准。
     * 	@param {String} version  - 可选 版本号，默认值是1.0.0，如果用户请求的服务版本不是1.0.0，请设置该参数。
     * 	@param {String} releaseAction  - 可选 指定如何释放锁，提供有"ALL"和"SOME"两种方式，默认值是"ALL"。
     *             在做更新或删除要素的时候，releaseAction="ALL"或"SOME"决定LockId对应的所有要素是否全部释放。
     *             如果是"ALL",表示LockId对应的所有要素全部解锁释放。
     *             如果是"SOME",表示LockId只对正在操作的要素解锁释放，其他要素还是保持锁定状态。
     *  @param {String} lockId  - 可选 锁定编号。
     *  @param {Object} inserts - 添加要素的请求参数。
     *  @param {Array(GeoGlobe.Feature)} features  - 必选 一系列要素的集合。
     *  @param {String} typeName  - 必选 指定操作的图层类型名称。
     *  @param {Object} updates - 修改要素的请求参数。
     *  @param {Array(GeoGlobe.Feature)} features  - 必选 一系列要素的集合。
     *  @param {String} typeName   - 必选 指定操作的图层类型名称。
     *  @param {GeoGlobe.Filter} filter  - 可选 操作要素的条件过滤器。
     *  @param {Object} deletes  - 删除要素的请求参数。
     *  @param {String} typeName  - 必选 指定操作的图层类型名称。
     *  @param {GeoGlobe.Filter} filter  - 可选 操作要素的条件过滤器。
     *  @param {Function} successFn  - 请求成功的回调函数。
     *  @param {Function} failFn  - 请求失败的回调函数。
     */
    transaction: function(params, inserts, updates, deletes, successFn, failFn){
		var url = this.url;
		//默认参数
        var DEFAULT_PARAMS = {
            service: "WFS",
            version: "1.0.0",
            request: "Transaction",
            releaseAction: "ALL"
        };
		//合并默认参数，获得实际请求参数
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
		
		//定义post请求模板
		var requestStringTemplate = '<?xml version="1.0" encoding="UTF-8"?>' +
        '<wfs:Transaction releaseAction="${releaseAction}" handle="Transaction 01" version="${version}" service="${service}" '+
		'xmlns="http://www.someserver.com/myns" ' +
		'xmlns:gml="http://www.opengis.net/gml" ' +
		'xmlns:ogc="http://www.opengis.net/ogc" ' +
		'xmlns:wfs="http://www.opengis.net/wfs" ' +
		'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
	        '${lockIdString}' +
	        '${transactionString}' +
        '</wfs:Transaction>';
		
		//lockId的请求标签
        var lockId = params.lockId;
		var lockIdString = "";
		if(lockId){
			lockIdString += '<LockId>' + lockId + '</LockId>';
		}
		
		var transactionString = "";
		//添加
        if (inserts) {
            transactionString += this._getInsertString(inserts);
        }
		//修改
		if(updates){
			transactionString += this._getUpdateString(updates);
		}
		//删除
		if(deletes){
			transactionString += this._getDeleteString(deletes);
		}
		//根据模板，获得post请求串
        var requestString = GeoGlobe.String.format(requestStringTemplate, {
            releaseAction: params.releaseAction,
            version: params.version,
            service: params.service,
            lockIdString: lockIdString,
            transactionString: transactionString
        });
		
		//请求失败的回调函数
		if (!failFn) {
            failFn = function(){
                this.failFn(params.request);
            };
        }
		
		//发送post请求
		var xhr = new GeoGlobe.Request.POST({
            url: url,
            data: requestString,
            scope: this,
            success: successFn,
//          success: function(result){
//				if(typeof successFn == "function"){
//	            	successFn(this._parseTransactionResult(result));
//	            }
//			},
            failure: failFn
        });
	},
	
	/**
     * 解析服务返回的要素事务操作的响应结果。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {object} result  - 服务返回的要素事务操作的响应结果。
     *
     * @returns {object}  - 返回要素事务操作的JSON返回结果。
	 */
    parseTransactionResult: function(result){
	    var format = new GeoGlobe.Format.XML2JSON();
	    var obj = format.read(result.responseText);
	    var res = new Array();
	    var wfs_Status = this._objToArray(obj.wfs_WFS_TransactionResponse.wfs_TransactionResult.wfs_Status);
	    var wfs_InsertResults = this._objToArray(obj.wfs_WFS_TransactionResponse.wfs_InsertResults);
	    //不存在则返回空数组。
	    if(!wfs_Status){
	    	return res;
	    }
	    for (var i = 0; i < wfs_Status.length; i++) {
	        if (wfs_Status[i].wfs_SUCCESS !== undefined) {
	            res.push({
	                status: "SUCCESS",
	                fid: (wfs_InsertResults && wfs_InsertResults[i]) ? wfs_InsertResults[i].ogc_FeatureId.fid : null
	            });
	        }
	        else {
	            res.push({
	                status: "FAILED",
	                fid: null
	            });
	        }
	    }
	    return res;
	},
	
	/**
     * 对象转数组。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {object} obj  - 对象。
     *
     * @returns {Array}  - 返回数组。
     * @private
	 */
    _objToArray: function(obj){
		if (obj && !(obj instanceof Array)) {
	        obj = [obj];
	    }
	    return obj;
	},
	
	/**
     * 获取插入的XML字符串。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {object} insert  - 添加要素的参数对象。
     *
     * @returns {String}  - 返回插入的XML字符串。
     * @private
	 */
    _getInsertString: function(inserts){
		var features = inserts.features;
		var typeName = inserts.typeName;
		var insertStr = "";
        for (var i = 0; i < features.length; i++) {
            var feature = features[i];
            insertStr += '<wfs:Insert handle="Insert ' + i + '">' +
			this._getInsertFeatureString(feature, typeName) +
			'</wfs:Insert>';
        };
		return insertStr;
	},
	
	/**
     * 获取保存要素所需的外部属性串。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {GeoGlobe.Feature} feature  - 要素。
     * @param {String} typeName  - 指定操作的图层类型名称。
     *
     * @returns {String}   - 返回保存要素所需的外部属性串。
     * @private
	 */
    _getInsertFeatureString: function(feature, typeName){
        var str = "";
        
        var featureTemplate = '<${typeName}>${content}</${typeName}>';
        var geoTemplate = "<GEOMETRY>${geometry}</GEOMETRY>";
        
        var attrTemplate = "<${tag}><![CDATA[${value}]]></${tag}>"
        
        for (var item in feature.attributes) {
            if (item == "OID") {
                continue;
            }
            str += GeoGlobe.String.format(attrTemplate, {
                value: (feature.attributes[item] ? feature.attributes[item] : ""),
                tag: item
            });
        }
        str += GeoGlobe.String.format(geoTemplate, {
            geometry: this._getGeometryStringByFeature(feature)
        });
        
        str = GeoGlobe.String.format(featureTemplate, {
            typeName: typeName,
            content: str
        });
        return str;
    },
	
	/**
     * 获取插入的XML字符串。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {object}  updates  - 修改要素的参数对象。
     *
     * @returns {String}  - 返回XML字符串。
     * @private
	 */
	 /*
    _getUpdateString: function(updates){
        var filter = updates.filter;
        var typeName = updates.typeName;
        var feature = updates.feature;
        
        //要素的要修改的属性和值的XML字符串
        var propertyString = this._getUpdatePropertyString(feature);
        //解析filter对象，转换为XML字符串。
        var filterXMLString = this._parserFilterToString(filter);
        var updateStr = '<wfs:Update typeName="' + typeName + '" handle="Update 1">' +
	        propertyString +
	        filterXMLString +
        '</wfs:Update>';
        
        return updateStr;
    },
    */
    _getUpdateString: function(updates){
        var filter = updates.filter;
        var typeName = updates.typeName;
        var features = updates.features;
        var updateStr = '';
        for (var i = 0; i < features.length; i++) {
        	if(features[i].geometry){
		        //要素的要修改的属性和值的XML字符串
		        var propertyString = this._getUpdatePropertyString(features[i]);
		        var filterTmp = new GeoGlobe.Filter.FeatureId({fids: [typeName + "." + features[i].attributes.OID]});
		        //解析filter对象，转换为XML字符串。
		        var filterXMLString = this._parserFilterToString(filterTmp);
		        updateStr += '<wfs:Update typeName="' + typeName + '" handle="Update ' + i + '">' +
			        propertyString +
			        filterXMLString +
		        '</wfs:Update>';
        	}
        }
        return updateStr;
        /*
        for (var i = 0; i < filter.fids.length; i++) {
	        deleteStr += '<wfs:Delete typeName="' + typeName + '" handle="Delete ' + i + '">';
	        var filterTmp = new GeoGlobe.Filter.FeatureId({fids: [filter.fids[i]]});
	        //解析filter对象，转换为XML字符串。
	        deleteStr += this._parserFilterToString(filterTmp);
	        deleteStr += '</wfs:Delete>';
        };
        */
    },
	
	/**
     * 获取修改的要素属性的XML字符串。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param  {GeoGlobe.Feature} feature  - 要素。
     *
     * @returns {String}  - 返回修改的要素属性的XML字符串。
     * @private
	 */
    _getUpdatePropertyString: function(feature){
        var str = "";
        for (var item in feature.data) {
            if (item == "OID") {
                continue;
            }
                if(feature.data[item]){
                str += '<wfs:Property>' +
                '<wfs:Name><![CDATA[' +
                item +
                ']]></wfs:Name>' +
                '<wfs:Value><![CDATA[' +
                (feature.data[item] ? feature.data[item] : "") +
                ']]></wfs:Value>' +
                '</wfs:Property>';
            }
        }
        str += '<wfs:Property>' +
	        '<wfs:Name>Geometry</wfs:Name>' +
	        '<wfs:Value>' +
	        this._getGeometryStringByFeature(feature) +
	        '</wfs:Value>' +
        '</wfs:Property>';
        return str;
    },
	
	/**
     * 获取修改的要素geometry的XML字符串。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {GeoGlobe.Feature} feature  - 要素。
     *
     * @returns {String}   - 返回修改的要素geometry的XML字符串。
     * @private
	 */
	_getGeometryStringByFeature: function(feature){
		var gmlFormat = new GeoGlobe.Format.GML({xy: this.xy});
        gmlFormat.buildCoordinatesNode = GeoGlobe.Function.bind(function(geometry){
			var coordinatesNode = this.createElementNS(this.gmlns, "gml:coordinates");
            coordinatesNode.setAttribute("decimal", ".");
            coordinatesNode.setAttribute("cs", ",");
            coordinatesNode.setAttribute("ts", " ");

            var parts = [];

            if (geometry instanceof GeoGlobe.LngLatBounds) {
                if (this.xy) {
                    parts.push(geometry.left + "," + geometry.bottom);
                    parts.push(geometry.right + "," + geometry.top);
                }
                else {
                    parts.push(geometry.bottom + "," + geometry.left);
                    parts.push(geometry.top + "," + geometry.right);
                }
            }
            else {
                var points = (geometry.components) ? geometry.components : [geometry];
                for (var i = 0; i < points.length; i++) {
                    if (this.xy) {
                        parts.push(points[i].x + "," + points[i].y);
                    }
                    else {
                        parts.push(points[i].y + "," + points[i].x);
                    }
                }
            }

            var txtNode = this.createTextNode(parts.join(" "));
            coordinatesNode.appendChild(txtNode);

            return coordinatesNode;

        }, gmlFormat);

		//DOMElement. A GML polygon node.
		var gmlDOMElement = gmlFormat.buildGeometryNode(feature.geometry);
		//gmlDOMElement.setAttribute("srsName", "urn:ogc:def:crs:EPSG:6.9:4326");
		var xmlParser = new GeoGlobe.Format.XML();
		var geometrtXmlStr = xmlParser.write(gmlDOMElement);
		return geometrtXmlStr;
    },

	/**
     * 获取插入的XML字符串。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {object} deletes  - 删除要素的参数对象。
     *
     * @returns {String}  - 返回插入的XML字符串。
     * @private
	 */
	 /*
    _getDeleteString: function(deletes){
        var filter = deletes.filter;
        var typeName = deletes.typeName;
        
        //解析filter对象，转换为XML字符串。
        var filterXMLString = this._parserFilterToString(filter);
        
        var deleteStr = "";
        deleteStr += '<wfs:Delete typeName="' + typeName + '" handle="Delete 1">';
        deleteStr += filterXMLString;
        deleteStr += '</wfs:Delete>';
        return deleteStr;
    },
    */
    _getDeleteString: function(deletes){
        var filter = deletes.filter;
        var typeName = deletes.typeName;
        var deleteStr = "";
		for (var i = 0; i < filter.fids.length; i++) {
	        deleteStr += '<wfs:Delete typeName="' + typeName + '" handle="Delete ' + i + '">';
	        var filterTmp = new GeoGlobe.Filter.FeatureId({fids: [filter.fids[i]]});
	        //解析filter对象，转换为XML字符串。
	        deleteStr += this._parserFilterToString(filterTmp);
	        deleteStr += '</wfs:Delete>';
        };
        return deleteStr;
    },
	
	/**
     * 解析filter对象，转换为XML字符串。
     * @memberof GeoGlobe.Service.WFST.prototype
     *  @param {GeoGlobe.Filter} filter  -  可选 操作要素的条件过滤器。
     *
     * @returns {String}  - 过滤器字符串。
     * @private
	 */
    _parserFilterToString: function(filter){
		//解析filter对象，转换为XML字符串。
		var filterXMLString = "";
        if (filter) {
            var filterFormatter = new GeoGlobe.Format.Filter.v1();
            var result = filterFormatter.write(filter);//{DOMElement} An ogc:Filter element.
			var xmlParser = new GeoGlobe.Format.XML();
			filterXMLString = xmlParser.write(result);
			return filterXMLString;
        }
		return filterXMLString;
	},
	
    CLASS_NAME: "GeoGlobe.Service.WFST"
});

/**
 * @class GeoGlobe.Service.CTS
 * @classdesc CTS坐标转换服务。继承GeoGlobe.Service类。
 * 坐标转换服务是GeoGlobe Server的应用服务之一。
 * 主要用于坐标投影转换、坐标仿射变换
 *
 */
GeoGlobe.Service.CTS = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * GeoGlobe.Service.CTS类的构造函数。
     * @memberof GeoGlobe.Service.CTS.prototype
     *
     * @param {String} name  - 服务名称。
     * @param {String} url  - 服务地址。
     * @param {Object} options  -  实例的选项设置，此参数可选。
     */
    initialize: function(name, url, options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     * 获取服务能力描述信息的XML。
     * @memberof GeoGlobe.Service.CTS.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "CTS"
            //VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },

    /**
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * @memberof GeoGlobe.Service.CTS.prototype
     * @returns {Boolean}  - 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "CTS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },

    /**
     * 坐标投影转换,并返回变换的结果。
     * @memberof GeoGlobe.Service.CTS.prototype
     * @param {Object} params  - 请求参数
     * @param {string} FORMAT  - 输出方式(XML或JSON)，默认为XML
     * @param {string} FROMEPSG  - 原始EPSG号
     * @param {string} TOEPSG   - 目标EPSG号
     * @param {string} COORDINATE  - 需转换的坐标串，中间以逗号隔开
     * @param {string} DIM  - 二维(2)，缺省值为2
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     *
     */
    TransCoords: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "CTS",
            //VERSION: "1.0.0",
            REQUEST: "TransCoords"
        };

        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);

        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
            if(params.FORMAT == "xml"){
                var json = {};
                var xml = result.responseXML;
                GeoGlobe.Function.bind(this.xmltoJson, this);
                var obj = this.xmltoJson(xml);
                json.attributes = obj.CTS_TransResult["cts:Coordinate"].attributes.dim;
                var coords = obj.CTS_TransResult["cts:Coordinate"].text;
                var arr = coords.split(",");
                var intcoord = [];
                for(var i = 0; i< arr.length;i++){
                    intcoord.push(arr[i]);
                }
                json.coordvalue = intcoord;
            }else if(params.FORMAT == "json"){
                var json = {};
                var obj = result.responseText;
                var jformat = new GeoGlobe.Format.JSON();
                var geojson = jformat.read(obj);
                json.attributes = geojson.CTS_TransResult.dim;
                json.coordvalue = geojson.CTS_TransResult.Coordinate;
            }
            successFn(json);
        }, failFn);
    },
    xmltoJson:function(xml){
        // Create the return object
        var obj = {};
        if (xml.nodeType == 1) { // element
            // do attributes
            if (xml.attributes.length > 0) {
                obj["attributes"] = {};
                for (var j = 0; j < xml.attributes.length; j++) {
                    var attribute = xml.attributes.item(j);
                    obj["attributes"][attribute.nodeName] = attribute.nodeValue;
                }
            }
        } else if (xml.nodeType == 3) { // text
            obj = xml.nodeValue;
        }
        // do children
        if (xml.hasChildNodes()) {
            for(var i = 0; i < xml.childNodes.length; i++) {
                var item = xml.childNodes.item(i);
                var nodeName = item.nodeName.replace('ows:','');
                nodeName = nodeName.replace('#','');
                if (typeof(obj[nodeName]) == "undefined") {
                    obj[nodeName] = this.xmltoJson(item);
                } else {
                    if (typeof(obj[nodeName].push) == "undefined") {
                        var old = obj[nodeName];
                        obj[nodeName] = [];
                        obj[nodeName].push(old);
                    }
                    obj[nodeName].push(this.xmltoJson(item));
                }
            }
        }
        return obj;
    },
    /**
     *  坐标仿射变换。
     * @memberof GeoGlobe.Service.CTS.prototype
     * @param {Object} params  - 请求参数。
     * @param {string} FORMAT  - 输出方式(XML或JSON)，默认为XML
     * @param {string} COORDINATE  -  需转换的坐标串，中间以逗号隔开
     * @param {string}  DIM  - 二维(2)，缺省值为2
     * @param {Function} successFn  -  请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     *
     */
    AffineTransform: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "CTS",
            //VERSION: "1.0.0",
            REQUEST: "AffineTransform"
        };
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);

        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.loadURL(url, params, this, function(result){
            if(params.FORMAT == "xml"){
                var json = {};
                var xml = result.responseXML;
                GeoGlobe.Function.bind(this.xmltoJson, this);
                var obj = this.xmltoJson(xml);
                json.attributes = obj.CTS_AffineTransResult["cts:Coordinate"].attributes.dim;
                var coords = obj.CTS_AffineTransResult["cts:Coordinate"].text;
                var arr = coords.split(",");
                var intcoord = [];
                for(var i = 0; i< arr.length;i++){
                    intcoord.push(arr[i]);
                }
                json.coordvalue = intcoord;
            }else if(params.FORMAT == "json"){
                var json = {};
                var obj = result.responseText;
                var jformat = new GeoGlobe.Format.JSON();
                var geojson = jformat.read(obj);
                json.attributes = geojson.CTS_AffineTransResult.dim;
                json.coordvalue = geojson.CTS_AffineTransResult.Coordinate;
            }
            successFn(json);
        }, failFn);
    },

    CLASS_NAME: "GeoGlobe.Service.CTS"
});

/**
 * @class GeoGlobe.Service.WMS
 * @classdesc OGC-WMS服务类。继承GeoGlobe.Service类。
 *
 */
GeoGlobe.Service.WMS = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * GeoGlobe.Service.WMS类的构造函数。
     * @memberof GeoGlobe.Service.WMS.prototype
     * @param {String} name  - 服务名称。
     * @param {String} url  - 服务地址。
     * @param {Object} options  - 实例的选项设置，此参数可选。
     *
     */
    initialize: function(name, url,  options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     * 获取服务能力描述信息。
     * @memberof GeoGlobe.Service.WMS.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilities: function(successFn,failFn){
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMS"
        };
        if(!failFn){
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url,params,this,function(result){
            var doc = result.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var json = this.xmlToJson(doc);
            var capabilities ={};
            var jsonOnj = json.WMT_MS_Capabilities;
            var Layer = jsonOnj.Capability.Layer.Layer;
            var request_service =jsonOnj.Capability.Request;
            var layers;
            if(Layer.length){
                layers = Layer[0];
            }else{
                layers = Layer;
            }
            capabilities.version = jsonOnj.attributes.version;
            capabilities.format = request_service.GetMap.Format[1].text;
            capabilities.layer = layers.Title.text;
            capabilities.bbox = layers.BoundingBox.attributes.SRS;
            capabilities.maxExtent = jsonOnj.Capability.Layer.LatLonBoundingBox.attributes;
            successFn(capabilities,json);
        },failFn);
    },

    /**
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * @memberof GeoGlobe.Service.WMS.prototype
     * @returns {Boolean}  - 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    xmlToJson:function(xml){
        // Create the return object
        var obj = {};
        if (xml.nodeType == 1) { // element
            // do attributes
            if (xml.attributes.length > 0) {
                obj["attributes"] = {};
                for (var j = 0; j < xml.attributes.length; j++) {
                    var attribute = xml.attributes.item(j);
                    obj["attributes"][attribute.nodeName] = attribute.nodeValue;
                }
            }
        } else if (xml.nodeType == 3) { // text
            obj = xml.nodeValue;
        }
        // do children
        if (xml.hasChildNodes()) {
            for(var i = 0; i < xml.childNodes.length; i++) {
                var item = xml.childNodes.item(i);
                var nodeName = item.nodeName.replace('ows:','');
                nodeName = nodeName.replace('#','');
                if (typeof(obj[nodeName]) == "undefined") {
                    obj[nodeName] = this.xmlToJson(item);
                } else {
                    if (typeof(obj[nodeName].push) == "undefined") {
                        var old = obj[nodeName];
                        obj[nodeName] = [];
                        obj[nodeName].push(old);
                    }
                    obj[nodeName].push(this.xmlToJson(item));
                }
            }
        }
        return obj;
    },
    /**
     *  获取地图内容操作。
     * @memberof GeoGlobe.Service.WMS.prototype
     *  @param {Object} params  - 请求参数，具体内容参考OGC-WMS标准。
     * 	@param {String} version  - 版本，默认值是1.1.1。
     *  @param {String} layers  - 图层名称。
     *  @param {String} styles  -  样式，默认是空串。
     *  @param {String} srs  -  默认值是"EPSG:4326"。
     *  @param {Integer} width  - 必选 宽。
     *  @param {Integer} height  - 必选 长。
     *  @param {String} format  - 默认值是"image/jpeg"。
     *  @param {String}  bbox   - 必选 范围。
     * @returns  {String}  - 地图内容图片地址。
     *
     * @example
     * (code)
     * var url = wmsService.getMap({
     *     layers: "basic",
     *     bbox: "-180,-90,180,270",
     *     width: 256,
     *     height: 256
     * });
     * (end)
     */
    getMap: function(options){
        var url = this.url;
        var DEFAULT_PARAMS = {
            service: "WMS",
            request: "GetMap",
            TRANSPARENT: true
        };
        var params = {};
        if( options.layers ) {
            params.LAYERS = options.layers;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.bbox) {
            params.BBOX = '{bbox-epsg-3857}';
        }
        if(options.width ) {
            params.WIDTH = options.width;
        }

        if(options.height ) {
            params.HEIGHT = options.height;
        }
        if( options.version ) {
            params.VERSION = options.version;
        }
        if( options.SRS ) {
            params.SRS = options.SRS;
        }
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
       // var paramsString = GeoGlobe.Util.getParameterString(params);
       //var wms_url = GeoGlobe.Util.urlAppend(url, paramsString);
        var url = this.urlAppend(this.url,
            this.getParameterString(params || {}));
        return url;
    },

    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     * @memberof GeoGlobe.Service.WMS.prototype
     * @param {String} url  - The url to append to
     * @param {String}  paramStr  - The param string to append
     *
     * @returns {String}  -  The new url
     * @private
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },

    CLASS_NAME: "GeoGlobe.Service.WMS"
});
/**
 * @class GeoGlobe.Service.WMTS
 * @classdesc OGC-WMTS服务类。继承GeoGlobe.Service类。
 *
 */
GeoGlobe.Service.WMTS = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * GeoGlobe.Service.WMTS类的构造函数。
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {String}  name  - 服务名称。
     * @param {String} url  - 服务地址。
     * @param {Object} options  - 实例的选项设置，此参数可选。
     */
    initialize: function(name, url,  options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     *  获取服务能力描述信息。
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilities: function(successFn,failFn){
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMTS"
        };
        if(!failFn){
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url,params,this,function(result){
            var doc = result.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var json = this.xmlToJson(doc);
            var jsonOnj = json.Capabilities;
            var capabilities = {};
            var layers = jsonOnj.Contents.Layer;
            if(layers.length){
                layers = layers[0];
            }else{
                layers = layers;
            }
            
            capabilities.version = jsonOnj.attributes.version;
            var contents = jsonOnj.Contents;
            capabilities.layer = layers.Title.text;
            capabilities.LayerIdentifier = layers.Identifier.text;
            capabilities.StyleIdentifier =  layers.Style.Identifier.text;
            capabilities.MatrixSet = layers.TileMatrixSetLink[0].TileMatrixSet.text;
            capabilities.Format = layers.Format[1].text;
            capabilities.Bounding = layers.BoundingBox;
            var Scales = "";
            var matrixs = contents.TileMatrixSet[0].TileMatrix;
            if(matrixs.length > 0) {
//							for(var i = 0; i < matrixs.length; i++) {
                for(var i=0, len=matrixs.length; i<len; i++) {
                    if(i == len){
                        break;
                    }
                    Scales += (matrixs[i].ScaleDenominator.text + ",");
                }
            }
            capabilities.Scales =  Scales.substr(0,Scales.length - 1);
            capabilities.zoomOffset = matrixs[0].Identifier.text;
            successFn(capabilities,json);

        },failFn);
    },
    xmlToJson:function(xml){
        // Create the return object
        var obj = {};
        if (xml.nodeType == 1) { // element
            // do attributes
            if (xml.attributes.length > 0) {
                obj["attributes"] = {};
                for (var j = 0; j < xml.attributes.length; j++) {
                    var attribute = xml.attributes.item(j);
                    obj["attributes"][attribute.nodeName] = attribute.nodeValue;
                }
            }
        } else if (xml.nodeType == 3) { // text
            obj = xml.nodeValue;
        }
        // do children
        if (xml.hasChildNodes()) {
            for(var i = 0; i < xml.childNodes.length; i++) {
                var item = xml.childNodes.item(i);
                var nodeName = item.nodeName.replace('ows:','');
                nodeName = nodeName.replace('#','');
                if (typeof(obj[nodeName]) == "undefined") {
                    obj[nodeName] = this.xmlToJson(item);
                } else {
                    if (typeof(obj[nodeName].push) == "undefined") {
                        var old = obj[nodeName];
                        obj[nodeName] = [];
                        obj[nodeName].push(old);
                    }
                    obj[nodeName].push(this.xmlToJson(item));
                }
            }
        }
        return obj;
    },
    /**
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @returns {Boolean}  - 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMTS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },

    /**
     * 获取瓦片内容操作。
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {Object} params - 请求参数，具体内容参考OGC-WMTS标准。
     * @param {String} service - 默认值是"WMTS"。
     * @param {String} version - 默认值是"1.0.0"。
     * @param {String} layer - 必选 图层标示。
     * @param {String} style - 必选 图层样式标示。
     * @param {String} format - 默认值是"image/png"。
     * @param {String} TileMatrixSet - 必选 矩阵集。
     * @param {String} TileMatrix - 必选 矩阵。
     * @param {Integer} TileRow - 必选 瓦片行号。
     * @param {Integer} TileCol - 必选 瓦片列号。
     *
     * @returns {String}  - 瓦片内容图片地址。
     *
     * @example
     * (code)
     * var url = wmtsService.getTile({
     *     layer: "dgdom0624",
     *     style: "dgdom0624",
     *     TileMatrixSet: "Matrix_0",
     *     TileMatrix: "12",
     *     TileRow: 761,
     *     TileCol: 3342
     * });
     * (end)
     */
    getTile:function(options){
        var DEFAULT_PARAMS = {
            service: "WMTS",
            request: "GetTile"
        };
        var params = {};
        if( options.layer ) {
            params.LAYER = options.layer;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.tileMatrixSet) {
            params.TILEMATRIXSET = options.tileMatrixSet;
        }
        if( options.TILEMATRIX ) {
            params.TILEMATRIX = options.TILEMATRIX;
        }
        if(options.TILEROW ) {
            params.TILEROW = options.TILEROW;
        }
        if( options.TILECOL) {
            params.TILECOL = options.TILECOL;
        }
        if( options.version ) {
            params.VERSION = options.version;
        }
        if( options.style ) {
            params.STYLE = options.style;
        }
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        var url = this.urlAppend(this.url,
            this.getParameterString(params || {}));
        return url;
    },
    /**
     * 获取参数字符串
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {Object} params-参数对象
     * @returns {String} 参数字符串
     * @private
     */ 
    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {String} url -  The url to append to
     * @param {String} paramStr - The param string to append
     *
     * @returns {String}  - The new url
     * @private
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },

    /**
     * WMTS-RESTful的获取服务能力描述信息。
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {Function}  successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilitiesForRest: function(successFn, failFn){
        var version = "1.0.0";
        var docName = "WMTSCapabilities.xml";
        var path = version + "/" + docName;
        var url = this.url;
        if (!url.match(/\/$/)) {
            url = url + "/";
        }
        url = url + path;

        if (!failFn) {
            failFn = function(){
                this.failFn("GetCapabilities");
            };
        }

        GeoGlobe.loadURL(url, null, this, function(result){
            successFn(result);
        }, failFn);
    },

    /**
     * WMTS-RESTful的获取瓦片内容操作。
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {Object}  params  - 请求参数，具体内容参考OGC-WMTS标准。
     *
     * @returns {String}  - 瓦片内容图片地址。
     * 	layer {String} -  必选 图层标示。
     * 	style {String} - 必选 图层样式标示。
     * 	format {String} - 必选 瓦片图片格式。默认值是"image/png"。
     * 	TileMatrixSet {String} - 必选 矩阵集。
     * 	TileMatrix {String} - 必选 矩阵。
     * 	TileRow {Integer} - 必选 瓦片行号。
     * 	TileCol Integer} - {必选 瓦片列号。
     *
     * @example
     * (code)
     * var url = wmtsService.getTile({
     *     layer: "dgdom0624",
     *     style: "dgdom0624",
     *     TileMatrixSet: "Matrix_0",
     *     TileMatrix: "12",
     *     TileRow: 761,
     *     TileCol: 3342
     * });
     * (end)
     */
    getTileForRest: function(params){
        var layer = params.layer;
        var style = params.style;
        var tileMatrixSet = params.tileMatrixSet;
        var tileMatrix = params.tileMatrix;
        var tileRow = params.tileRow;
        var tileCol = params.tileCol;

        var formatSuffix = null;
        var format = params.format ? params.format : "image/png";
        var formatSuffixMap = {
            "image/png": "png",
            "image/png8": "png",
            "image/png24": "png",
            "image/png32": "png",
            "png": "png",
            "image/jpeg": "jpg",
            "image/jpg": "jpg",
            "jpeg": "jpg",
            "jpg": "jpg"
        };
        if (!formatSuffix) {
            formatSuffix = formatSuffixMap[format] || format.split("/").pop();
        }

        var path = layer + "/" + style + "/" + tileMatrixSet +
            "/" + tileMatrix + "/" + tileRow + "/" + tileCol + "." + formatSuffix;
        var url = this.url;
        if (!url.match(/\/$/)) {
            url = url + "/";
        }
        url = url + path;
        return url;
    },

    CLASS_NAME: "GeoGlobe.Service.WMTS"
});